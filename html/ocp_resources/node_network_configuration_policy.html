<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ocp_resources.node_network_configuration_policy API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocp_resources.node_network_configuration_policy</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import re

from openshift.dynamic.exceptions import ConflictError

from ocp_resources.node_network_configuration_enactment import (
    NodeNetworkConfigurationEnactment,
)
from ocp_resources.node_network_state import NodeNetworkState
from ocp_resources.resource import Resource
from ocp_resources.utils import TimeoutExpiredError, TimeoutSampler


LOGGER = logging.getLogger(__name__)


class NNCPConfigurationFailed(Exception):
    pass


class NodeNetworkConfigurationPolicy(Resource):
    api_group = Resource.ApiGroup.NMSTATE_IO

    class Conditions:
        class Type:
            FAILING = &#34;Failing&#34;
            AVAILABLE = &#34;Available&#34;
            PROGRESSING = &#34;Progressing&#34;
            MATCHING = &#34;Matching&#34;

        class Reason:
            CONFIGURING = &#34;ConfigurationProgressing&#34;
            SUCCESS = &#34;SuccessfullyConfigured&#34;
            FAILED = &#34;FailedToConfigure&#34;

    def __init__(
        self,
        name,
        client=None,
        worker_pods=None,
        node_selector=None,
        teardown=True,
        mtu=None,
        ports=None,
        ipv4_enable=False,
        ipv4_dhcp=False,
        ipv4_addresses=None,
        ipv6_enable=False,
        node_active_nics=None,
        dns_resolver=None,
        routes=None,
    ):
        &#34;&#34;&#34;
        ipv4_addresses should be sent in this format:
        [{&#34;ip&#34;: &lt;ip1-string&gt;, &#34;prefix-length&#34;: &lt;prefix-len1-int&gt;},
         {&#34;ip&#34;: &lt;ip2-string&gt;, &#34;prefix-length&#34;: &lt;prefix-len2-int&gt;}, ...]
        For example:
        [{&#34;ip&#34;: &#34;10.1.2.3&#34;, &#34;prefix-length&#34;: 24},
         {&#34;ip&#34;: &#34;10.4.5.6&#34;, &#34;prefix-length&#34;: 24},
         {&#34;ip&#34;: &#34;10.7.8.9&#34;, &#34;prefix-length&#34;: 23}]
        &#34;&#34;&#34;
        super().__init__(name=name, client=client, teardown=teardown)
        self.desired_state = {&#34;interfaces&#34;: []}
        self.worker_pods = worker_pods
        self.mtu = mtu
        self.mtu_dict = {}
        self.ports = ports or []
        self.iface = None
        self.ifaces = []
        self.node_active_nics = node_active_nics or []
        self.ipv4_enable = ipv4_enable
        self._ipv4_dhcp = ipv4_dhcp
        self.ipv4_addresses = ipv4_addresses or []
        self.ipv6_enable = ipv6_enable
        self.ipv4_iface_state = {}
        self.node_selector = node_selector
        self.dns_resolver = dns_resolver
        self.routes = routes
        if self.node_selector:
            self._node_selector = {
                f&#34;{self.ApiGroup.KUBERNETES_IO}/hostname&#34;: self.node_selector
            }
            if self.worker_pods:
                for pod in self.worker_pods:
                    if pod.node.name == node_selector:
                        self.worker_pods = [pod]
                        break
        else:
            self._node_selector = {
                f&#34;node-role.{self.ApiGroup.KUBERNETES_IO}/worker&#34;: &#34;&#34;
            }

    def set_interface(self, interface):
        # First drop the interface if it&#39;s already in the list
        interfaces = [
            iface
            for iface in self.desired_state[&#34;interfaces&#34;]
            if not (iface[&#34;name&#34;] == interface[&#34;name&#34;])
        ]
        # Add the interface
        interfaces.append(interface)
        self.desired_state[&#34;interfaces&#34;] = interfaces

    def to_dict(self):
        res = super().to_dict()
        if self.dns_resolver or self.routes or self.iface:
            res.setdefault(&#34;spec&#34;, {}).setdefault(&#34;desiredState&#34;, {})

        if self._node_selector:
            res.setdefault(&#34;spec&#34;, {}).setdefault(&#34;nodeSelector&#34;, self._node_selector)

        if self.dns_resolver:
            res[&#34;spec&#34;][&#34;desiredState&#34;][&#34;dns-resolver&#34;] = self.dns_resolver

        if self.routes:
            res[&#34;spec&#34;][&#34;desiredState&#34;][&#34;routes&#34;] = self.routes

        if self.iface:
            &#34;&#34;&#34;
            It&#39;s the responsibility of the caller to verify the desired configuration they send.
            For example: &#34;ipv4.dhcp.enabled: false&#34; without specifying any static IP address
            is a valid desired state and therefore not blocked in the code, but nmstate would
            reject it. Such configuration might be used for negative tests.
            &#34;&#34;&#34;
            self.iface[&#34;ipv4&#34;] = {&#34;enabled&#34;: self.ipv4_enable, &#34;dhcp&#34;: self.ipv4_dhcp}
            if self.ipv4_addresses:
                self.iface[&#34;ipv4&#34;][&#34;address&#34;] = self.ipv4_addresses

            self.iface[&#34;ipv6&#34;] = {&#34;enabled&#34;: self.ipv6_enable}

            self.set_interface(interface=self.iface)
            if self.iface[&#34;name&#34;] not in [_iface[&#34;name&#34;] for _iface in self.ifaces]:
                self.ifaces.append(self.iface)

            res[&#34;spec&#34;][&#34;desiredState&#34;][&#34;interfaces&#34;] = self.desired_state[&#34;interfaces&#34;]

        return res

    def apply(self, resource=None):
        resource = resource if resource else super().to_dict()
        samples = TimeoutSampler(
            wait_timeout=3,
            sleep=1,
            exceptions=ConflictError,
            func=self.update,
            resource_dict=resource,
        )
        LOGGER.info(f&#34;Applying {resource}&#34;)
        for _ in samples:
            return

    def deploy(self):
        if self._ipv4_dhcp:
            self._ipv4_state_backup()

        if self.mtu:
            for pod in self.worker_pods:
                for port in self.ports:
                    mtu = pod.execute(
                        command=[&#34;cat&#34;, f&#34;/sys/class/net/{port}/mtu&#34;]
                    ).strip()
                    LOGGER.info(
                        f&#34;Backup MTU: {pod.node.name} interface {port} MTU is {mtu}&#34;
                    )
                    self.mtu_dict[port] = mtu

        self.create()

        try:
            self.wait_for_status_success()
            self.validate_create()
            return self
        except Exception as e:
            LOGGER.error(e)
            self.clean_up()
            raise

    @property
    def ipv4_dhcp(self):
        return self._ipv4_dhcp

    @ipv4_dhcp.setter
    def ipv4_dhcp(self, ipv4_dhcp):
        if ipv4_dhcp != self._ipv4_dhcp:
            self._ipv4_dhcp = ipv4_dhcp

            if self._ipv4_dhcp:
                self._ipv4_state_backup()
                self.iface[&#34;ipv4&#34;] = {&#34;dhcp&#34;: True, &#34;enabled&#34;: True}

            self.set_interface(interface=self.iface)
            self.apply()

    def clean_up(self):
        if self.mtu:
            for port in self.ports:
                _port = {
                    &#34;name&#34;: port,
                    &#34;type&#34;: &#34;ethernet&#34;,
                    &#34;state&#34;: self.Interface.State.UP,
                    &#34;mtu&#34;: int(self.mtu_dict[port]),
                }
                self.set_interface(interface=_port)

        for iface in self.ifaces:
            &#34;&#34;&#34;
            If any physical interfaces are part of the policy - we will skip them,
            because we don&#39;t want to delete them (and we actually can&#39;t, and this attempt
            would end with failure).
            &#34;&#34;&#34;
            if iface[&#34;name&#34;] in self.node_active_nics:
                continue
            try:
                self._absent_interface()
                self.wait_for_status_success()
                self.wait_for_interface_deleted()
            except Exception as e:
                LOGGER.error(e)

        self.delete()

    def wait_for_interface_deleted(self):
        for pod in self.worker_pods:
            for iface in self.ifaces:
                iface_name = iface[&#34;name&#34;]
                node_network_state = NodeNetworkState(name=pod.node.name)
                iface_dict = node_network_state.get_interface(name=iface_name)
                if iface_dict.get(&#34;type&#34;) == &#34;ethernet&#34;:
                    LOGGER.info(f&#34;{iface_name} is type ethernet, skipping.&#34;)
                    continue

                node_network_state.wait_until_deleted(name=iface_name)

    def validate_create(self):
        for pod in self.worker_pods:
            for bridge in self.ifaces:
                node_network_state = NodeNetworkState(name=pod.node.name)
                node_network_state.wait_until_up(name=bridge[&#34;name&#34;])

    def _ipv4_state_backup(self):
        # Backup current state of dhcp for the interfaces which arent veth or current bridge
        for pod in self.worker_pods:
            node_network_state = NodeNetworkState(name=pod.node.name)
            self.ipv4_iface_state[pod.node.name] = {}
            for interface in node_network_state.instance.status.currentState.interfaces:
                if interface[&#34;name&#34;] in self.ports:
                    self.ipv4_iface_state[pod.node.name].update(
                        {
                            interface[&#34;name&#34;]: {
                                k: interface[&#34;ipv4&#34;][k] for k in (&#34;dhcp&#34;, &#34;enabled&#34;)
                            }
                        }
                    )

    def _absent_interface(self):
        for bridge in self.ifaces:
            bridge[&#34;state&#34;] = self.Interface.State.ABSENT
            self.set_interface(interface=bridge)

            if self._ipv4_dhcp:
                temp_ipv4_iface_state = {}
                for pod in self.worker_pods:
                    node_network_state = NodeNetworkState(name=pod.node.name)
                    temp_ipv4_iface_state[pod.node.name] = {}
                    # Find which interfaces got changed (of those that are connected to bridge)
                    for (
                        interface
                    ) in node_network_state.instance.status.currentState.interfaces:
                        if interface[&#34;name&#34;] in self.ports:
                            x = {k: interface[&#34;ipv4&#34;][k] for k in (&#34;dhcp&#34;, &#34;enabled&#34;)}
                            if (
                                self.ipv4_iface_state[pod.node.name][interface[&#34;name&#34;]]
                                != x
                            ):
                                temp_ipv4_iface_state[pod.node.name].update(
                                    {
                                        interface[&#34;name&#34;]: self.ipv4_iface_state[
                                            pod.node.name
                                        ][interface[&#34;name&#34;]]
                                    }
                                )

                previous_state = next(iter(temp_ipv4_iface_state.values()))

                # Restore DHCP state of the changed bridge connected ports
                for iface_name, ipv4 in previous_state.items():
                    interface = {&#34;name&#34;: iface_name, &#34;ipv4&#34;: ipv4}
                    self.set_interface(interface=interface)

        self.apply(resource=self._resource_dict_for_cleanup())

    def status(self):
        for condition in self.instance.status.conditions:
            if condition[&#34;type&#34;] == self.Conditions.Type.AVAILABLE:
                return condition[&#34;reason&#34;]

    def wait_for_status_success(self):
        # if we get here too fast there are no conditions, we need to wait.
        self.wait_for_conditions()

        samples = TimeoutSampler(wait_timeout=480, sleep=1, func=self.status)
        try:
            for sample in samples:
                if sample == self.Conditions.Reason.SUCCESS:
                    LOGGER.info(&#34;NNCP configured Successfully&#34;)
                    return sample

                if sample == self.Conditions.Reason.FAILED:
                    for failed_nnce in self._get_failed_nnce():
                        nnce_dict = failed_nnce.instance.to_dict()
                        for cond in nnce_dict[&#34;status&#34;][&#34;conditions&#34;]:
                            error = re.findall(
                                r&#34;libnmstate.error.*&#34;, cond.get(&#34;message&#34;, &#34;&#34;)
                            )
                            if error:
                                LOGGER.error(
                                    f&#34;NNCE {nnce_dict[&#39;metadata&#39;][&#39;name&#39;]}: {error[0]}&#34;
                                )

                    raise NNCPConfigurationFailed(
                        f&#34;Reason: {self.Conditions.Reason.FAILED}&#34;
                    )

        except (TimeoutExpiredError, NNCPConfigurationFailed):
            LOGGER.error(&#34;Unable to configure NNCP for node&#34;)
            raise

    def _get_failed_nnce(self):
        for nnce in NodeNetworkConfigurationEnactment.get(dyn_client=self.client):
            try:
                nnce.wait_for_conditions()
            except TimeoutExpiredError:
                LOGGER.error(f&#34;Failed to get NNCE {nnce.name} status&#34;)
                continue

            for nnce_cond in nnce.instance.status.conditions:
                if (
                    nnce_cond.type == &#34;Failing&#34;
                    and nnce_cond.status == Resource.Condition.Status.TRUE
                ):
                    yield nnce

    def _resource_dict_for_cleanup(self):
        resource_dict = self.to_dict()
        desired_state = {&#34;interfaces&#34;: self.ifaces}
        resource_dict.update({&#34;spec&#34;: {&#34;desiredState&#34;: desired_state}})
        if self.routes:
            resource_dict[&#34;spec&#34;][&#34;desiredState&#34;][&#34;routes&#34;] = None

        return resource_dict</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ocp_resources.node_network_configuration_policy.NNCPConfigurationFailed"><code class="flex name class">
<span>class <span class="ident">NNCPConfigurationFailed</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NNCPConfigurationFailed(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy"><code class="flex name class">
<span>class <span class="ident">NodeNetworkConfigurationPolicy</span></span>
<span>(</span><span>name, client=None, worker_pods=None, node_selector=None, teardown=True, mtu=None, ports=None, ipv4_enable=False, ipv4_dhcp=False, ipv4_addresses=None, ipv6_enable=False, node_active_nics=None, dns_resolver=None, routes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for API resources</p>
<p>ipv4_addresses should be sent in this format:
[{"ip": <ip1-string>, "prefix-length": <prefix-len1-int>},
{"ip": <ip2-string>, "prefix-length": <prefix-len2-int>}, &hellip;]
For example:
[{"ip": "10.1.2.3", "prefix-length": 24},
{"ip": "10.4.5.6", "prefix-length": 24},
{"ip": "10.7.8.9", "prefix-length": 23}]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeNetworkConfigurationPolicy(Resource):
    api_group = Resource.ApiGroup.NMSTATE_IO

    class Conditions:
        class Type:
            FAILING = &#34;Failing&#34;
            AVAILABLE = &#34;Available&#34;
            PROGRESSING = &#34;Progressing&#34;
            MATCHING = &#34;Matching&#34;

        class Reason:
            CONFIGURING = &#34;ConfigurationProgressing&#34;
            SUCCESS = &#34;SuccessfullyConfigured&#34;
            FAILED = &#34;FailedToConfigure&#34;

    def __init__(
        self,
        name,
        client=None,
        worker_pods=None,
        node_selector=None,
        teardown=True,
        mtu=None,
        ports=None,
        ipv4_enable=False,
        ipv4_dhcp=False,
        ipv4_addresses=None,
        ipv6_enable=False,
        node_active_nics=None,
        dns_resolver=None,
        routes=None,
    ):
        &#34;&#34;&#34;
        ipv4_addresses should be sent in this format:
        [{&#34;ip&#34;: &lt;ip1-string&gt;, &#34;prefix-length&#34;: &lt;prefix-len1-int&gt;},
         {&#34;ip&#34;: &lt;ip2-string&gt;, &#34;prefix-length&#34;: &lt;prefix-len2-int&gt;}, ...]
        For example:
        [{&#34;ip&#34;: &#34;10.1.2.3&#34;, &#34;prefix-length&#34;: 24},
         {&#34;ip&#34;: &#34;10.4.5.6&#34;, &#34;prefix-length&#34;: 24},
         {&#34;ip&#34;: &#34;10.7.8.9&#34;, &#34;prefix-length&#34;: 23}]
        &#34;&#34;&#34;
        super().__init__(name=name, client=client, teardown=teardown)
        self.desired_state = {&#34;interfaces&#34;: []}
        self.worker_pods = worker_pods
        self.mtu = mtu
        self.mtu_dict = {}
        self.ports = ports or []
        self.iface = None
        self.ifaces = []
        self.node_active_nics = node_active_nics or []
        self.ipv4_enable = ipv4_enable
        self._ipv4_dhcp = ipv4_dhcp
        self.ipv4_addresses = ipv4_addresses or []
        self.ipv6_enable = ipv6_enable
        self.ipv4_iface_state = {}
        self.node_selector = node_selector
        self.dns_resolver = dns_resolver
        self.routes = routes
        if self.node_selector:
            self._node_selector = {
                f&#34;{self.ApiGroup.KUBERNETES_IO}/hostname&#34;: self.node_selector
            }
            if self.worker_pods:
                for pod in self.worker_pods:
                    if pod.node.name == node_selector:
                        self.worker_pods = [pod]
                        break
        else:
            self._node_selector = {
                f&#34;node-role.{self.ApiGroup.KUBERNETES_IO}/worker&#34;: &#34;&#34;
            }

    def set_interface(self, interface):
        # First drop the interface if it&#39;s already in the list
        interfaces = [
            iface
            for iface in self.desired_state[&#34;interfaces&#34;]
            if not (iface[&#34;name&#34;] == interface[&#34;name&#34;])
        ]
        # Add the interface
        interfaces.append(interface)
        self.desired_state[&#34;interfaces&#34;] = interfaces

    def to_dict(self):
        res = super().to_dict()
        if self.dns_resolver or self.routes or self.iface:
            res.setdefault(&#34;spec&#34;, {}).setdefault(&#34;desiredState&#34;, {})

        if self._node_selector:
            res.setdefault(&#34;spec&#34;, {}).setdefault(&#34;nodeSelector&#34;, self._node_selector)

        if self.dns_resolver:
            res[&#34;spec&#34;][&#34;desiredState&#34;][&#34;dns-resolver&#34;] = self.dns_resolver

        if self.routes:
            res[&#34;spec&#34;][&#34;desiredState&#34;][&#34;routes&#34;] = self.routes

        if self.iface:
            &#34;&#34;&#34;
            It&#39;s the responsibility of the caller to verify the desired configuration they send.
            For example: &#34;ipv4.dhcp.enabled: false&#34; without specifying any static IP address
            is a valid desired state and therefore not blocked in the code, but nmstate would
            reject it. Such configuration might be used for negative tests.
            &#34;&#34;&#34;
            self.iface[&#34;ipv4&#34;] = {&#34;enabled&#34;: self.ipv4_enable, &#34;dhcp&#34;: self.ipv4_dhcp}
            if self.ipv4_addresses:
                self.iface[&#34;ipv4&#34;][&#34;address&#34;] = self.ipv4_addresses

            self.iface[&#34;ipv6&#34;] = {&#34;enabled&#34;: self.ipv6_enable}

            self.set_interface(interface=self.iface)
            if self.iface[&#34;name&#34;] not in [_iface[&#34;name&#34;] for _iface in self.ifaces]:
                self.ifaces.append(self.iface)

            res[&#34;spec&#34;][&#34;desiredState&#34;][&#34;interfaces&#34;] = self.desired_state[&#34;interfaces&#34;]

        return res

    def apply(self, resource=None):
        resource = resource if resource else super().to_dict()
        samples = TimeoutSampler(
            wait_timeout=3,
            sleep=1,
            exceptions=ConflictError,
            func=self.update,
            resource_dict=resource,
        )
        LOGGER.info(f&#34;Applying {resource}&#34;)
        for _ in samples:
            return

    def deploy(self):
        if self._ipv4_dhcp:
            self._ipv4_state_backup()

        if self.mtu:
            for pod in self.worker_pods:
                for port in self.ports:
                    mtu = pod.execute(
                        command=[&#34;cat&#34;, f&#34;/sys/class/net/{port}/mtu&#34;]
                    ).strip()
                    LOGGER.info(
                        f&#34;Backup MTU: {pod.node.name} interface {port} MTU is {mtu}&#34;
                    )
                    self.mtu_dict[port] = mtu

        self.create()

        try:
            self.wait_for_status_success()
            self.validate_create()
            return self
        except Exception as e:
            LOGGER.error(e)
            self.clean_up()
            raise

    @property
    def ipv4_dhcp(self):
        return self._ipv4_dhcp

    @ipv4_dhcp.setter
    def ipv4_dhcp(self, ipv4_dhcp):
        if ipv4_dhcp != self._ipv4_dhcp:
            self._ipv4_dhcp = ipv4_dhcp

            if self._ipv4_dhcp:
                self._ipv4_state_backup()
                self.iface[&#34;ipv4&#34;] = {&#34;dhcp&#34;: True, &#34;enabled&#34;: True}

            self.set_interface(interface=self.iface)
            self.apply()

    def clean_up(self):
        if self.mtu:
            for port in self.ports:
                _port = {
                    &#34;name&#34;: port,
                    &#34;type&#34;: &#34;ethernet&#34;,
                    &#34;state&#34;: self.Interface.State.UP,
                    &#34;mtu&#34;: int(self.mtu_dict[port]),
                }
                self.set_interface(interface=_port)

        for iface in self.ifaces:
            &#34;&#34;&#34;
            If any physical interfaces are part of the policy - we will skip them,
            because we don&#39;t want to delete them (and we actually can&#39;t, and this attempt
            would end with failure).
            &#34;&#34;&#34;
            if iface[&#34;name&#34;] in self.node_active_nics:
                continue
            try:
                self._absent_interface()
                self.wait_for_status_success()
                self.wait_for_interface_deleted()
            except Exception as e:
                LOGGER.error(e)

        self.delete()

    def wait_for_interface_deleted(self):
        for pod in self.worker_pods:
            for iface in self.ifaces:
                iface_name = iface[&#34;name&#34;]
                node_network_state = NodeNetworkState(name=pod.node.name)
                iface_dict = node_network_state.get_interface(name=iface_name)
                if iface_dict.get(&#34;type&#34;) == &#34;ethernet&#34;:
                    LOGGER.info(f&#34;{iface_name} is type ethernet, skipping.&#34;)
                    continue

                node_network_state.wait_until_deleted(name=iface_name)

    def validate_create(self):
        for pod in self.worker_pods:
            for bridge in self.ifaces:
                node_network_state = NodeNetworkState(name=pod.node.name)
                node_network_state.wait_until_up(name=bridge[&#34;name&#34;])

    def _ipv4_state_backup(self):
        # Backup current state of dhcp for the interfaces which arent veth or current bridge
        for pod in self.worker_pods:
            node_network_state = NodeNetworkState(name=pod.node.name)
            self.ipv4_iface_state[pod.node.name] = {}
            for interface in node_network_state.instance.status.currentState.interfaces:
                if interface[&#34;name&#34;] in self.ports:
                    self.ipv4_iface_state[pod.node.name].update(
                        {
                            interface[&#34;name&#34;]: {
                                k: interface[&#34;ipv4&#34;][k] for k in (&#34;dhcp&#34;, &#34;enabled&#34;)
                            }
                        }
                    )

    def _absent_interface(self):
        for bridge in self.ifaces:
            bridge[&#34;state&#34;] = self.Interface.State.ABSENT
            self.set_interface(interface=bridge)

            if self._ipv4_dhcp:
                temp_ipv4_iface_state = {}
                for pod in self.worker_pods:
                    node_network_state = NodeNetworkState(name=pod.node.name)
                    temp_ipv4_iface_state[pod.node.name] = {}
                    # Find which interfaces got changed (of those that are connected to bridge)
                    for (
                        interface
                    ) in node_network_state.instance.status.currentState.interfaces:
                        if interface[&#34;name&#34;] in self.ports:
                            x = {k: interface[&#34;ipv4&#34;][k] for k in (&#34;dhcp&#34;, &#34;enabled&#34;)}
                            if (
                                self.ipv4_iface_state[pod.node.name][interface[&#34;name&#34;]]
                                != x
                            ):
                                temp_ipv4_iface_state[pod.node.name].update(
                                    {
                                        interface[&#34;name&#34;]: self.ipv4_iface_state[
                                            pod.node.name
                                        ][interface[&#34;name&#34;]]
                                    }
                                )

                previous_state = next(iter(temp_ipv4_iface_state.values()))

                # Restore DHCP state of the changed bridge connected ports
                for iface_name, ipv4 in previous_state.items():
                    interface = {&#34;name&#34;: iface_name, &#34;ipv4&#34;: ipv4}
                    self.set_interface(interface=interface)

        self.apply(resource=self._resource_dict_for_cleanup())

    def status(self):
        for condition in self.instance.status.conditions:
            if condition[&#34;type&#34;] == self.Conditions.Type.AVAILABLE:
                return condition[&#34;reason&#34;]

    def wait_for_status_success(self):
        # if we get here too fast there are no conditions, we need to wait.
        self.wait_for_conditions()

        samples = TimeoutSampler(wait_timeout=480, sleep=1, func=self.status)
        try:
            for sample in samples:
                if sample == self.Conditions.Reason.SUCCESS:
                    LOGGER.info(&#34;NNCP configured Successfully&#34;)
                    return sample

                if sample == self.Conditions.Reason.FAILED:
                    for failed_nnce in self._get_failed_nnce():
                        nnce_dict = failed_nnce.instance.to_dict()
                        for cond in nnce_dict[&#34;status&#34;][&#34;conditions&#34;]:
                            error = re.findall(
                                r&#34;libnmstate.error.*&#34;, cond.get(&#34;message&#34;, &#34;&#34;)
                            )
                            if error:
                                LOGGER.error(
                                    f&#34;NNCE {nnce_dict[&#39;metadata&#39;][&#39;name&#39;]}: {error[0]}&#34;
                                )

                    raise NNCPConfigurationFailed(
                        f&#34;Reason: {self.Conditions.Reason.FAILED}&#34;
                    )

        except (TimeoutExpiredError, NNCPConfigurationFailed):
            LOGGER.error(&#34;Unable to configure NNCP for node&#34;)
            raise

    def _get_failed_nnce(self):
        for nnce in NodeNetworkConfigurationEnactment.get(dyn_client=self.client):
            try:
                nnce.wait_for_conditions()
            except TimeoutExpiredError:
                LOGGER.error(f&#34;Failed to get NNCE {nnce.name} status&#34;)
                continue

            for nnce_cond in nnce.instance.status.conditions:
                if (
                    nnce_cond.type == &#34;Failing&#34;
                    and nnce_cond.status == Resource.Condition.Status.TRUE
                ):
                    yield nnce

    def _resource_dict_for_cleanup(self):
        resource_dict = self.to_dict()
        desired_state = {&#34;interfaces&#34;: self.ifaces}
        resource_dict.update({&#34;spec&#34;: {&#34;desiredState&#34;: desired_state}})
        if self.routes:
            resource_dict[&#34;spec&#34;][&#34;desiredState&#34;][&#34;routes&#34;] = None

        return resource_dict</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ocp_resources.resource.Resource" href="resource.html#ocp_resources.resource.Resource">Resource</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.Conditions"><code class="name">var <span class="ident">Conditions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.api_group"><code class="name">var <span class="ident">api_group</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.ipv4_dhcp"><code class="name">var <span class="ident">ipv4_dhcp</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ipv4_dhcp(self):
    return self._ipv4_dhcp</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, resource=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, resource=None):
    resource = resource if resource else super().to_dict()
    samples = TimeoutSampler(
        wait_timeout=3,
        sleep=1,
        exceptions=ConflictError,
        func=self.update,
        resource_dict=resource,
    )
    LOGGER.info(f&#34;Applying {resource}&#34;)
    for _ in samples:
        return</code></pre>
</details>
</dd>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.clean_up"><code class="name flex">
<span>def <span class="ident">clean_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up(self):
    if self.mtu:
        for port in self.ports:
            _port = {
                &#34;name&#34;: port,
                &#34;type&#34;: &#34;ethernet&#34;,
                &#34;state&#34;: self.Interface.State.UP,
                &#34;mtu&#34;: int(self.mtu_dict[port]),
            }
            self.set_interface(interface=_port)

    for iface in self.ifaces:
        &#34;&#34;&#34;
        If any physical interfaces are part of the policy - we will skip them,
        because we don&#39;t want to delete them (and we actually can&#39;t, and this attempt
        would end with failure).
        &#34;&#34;&#34;
        if iface[&#34;name&#34;] in self.node_active_nics:
            continue
        try:
            self._absent_interface()
            self.wait_for_status_success()
            self.wait_for_interface_deleted()
        except Exception as e:
            LOGGER.error(e)

    self.delete()</code></pre>
</details>
</dd>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.deploy"><code class="name flex">
<span>def <span class="ident">deploy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deploy(self):
    if self._ipv4_dhcp:
        self._ipv4_state_backup()

    if self.mtu:
        for pod in self.worker_pods:
            for port in self.ports:
                mtu = pod.execute(
                    command=[&#34;cat&#34;, f&#34;/sys/class/net/{port}/mtu&#34;]
                ).strip()
                LOGGER.info(
                    f&#34;Backup MTU: {pod.node.name} interface {port} MTU is {mtu}&#34;
                )
                self.mtu_dict[port] = mtu

    self.create()

    try:
        self.wait_for_status_success()
        self.validate_create()
        return self
    except Exception as e:
        LOGGER.error(e)
        self.clean_up()
        raise</code></pre>
</details>
</dd>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.set_interface"><code class="name flex">
<span>def <span class="ident">set_interface</span></span>(<span>self, interface)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_interface(self, interface):
    # First drop the interface if it&#39;s already in the list
    interfaces = [
        iface
        for iface in self.desired_state[&#34;interfaces&#34;]
        if not (iface[&#34;name&#34;] == interface[&#34;name&#34;])
    ]
    # Add the interface
    interfaces.append(interface)
    self.desired_state[&#34;interfaces&#34;] = interfaces</code></pre>
</details>
</dd>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.validate_create"><code class="name flex">
<span>def <span class="ident">validate_create</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_create(self):
    for pod in self.worker_pods:
        for bridge in self.ifaces:
            node_network_state = NodeNetworkState(name=pod.node.name)
            node_network_state.wait_until_up(name=bridge[&#34;name&#34;])</code></pre>
</details>
</dd>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.wait_for_interface_deleted"><code class="name flex">
<span>def <span class="ident">wait_for_interface_deleted</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_interface_deleted(self):
    for pod in self.worker_pods:
        for iface in self.ifaces:
            iface_name = iface[&#34;name&#34;]
            node_network_state = NodeNetworkState(name=pod.node.name)
            iface_dict = node_network_state.get_interface(name=iface_name)
            if iface_dict.get(&#34;type&#34;) == &#34;ethernet&#34;:
                LOGGER.info(f&#34;{iface_name} is type ethernet, skipping.&#34;)
                continue

            node_network_state.wait_until_deleted(name=iface_name)</code></pre>
</details>
</dd>
<dt id="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.wait_for_status_success"><code class="name flex">
<span>def <span class="ident">wait_for_status_success</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_status_success(self):
    # if we get here too fast there are no conditions, we need to wait.
    self.wait_for_conditions()

    samples = TimeoutSampler(wait_timeout=480, sleep=1, func=self.status)
    try:
        for sample in samples:
            if sample == self.Conditions.Reason.SUCCESS:
                LOGGER.info(&#34;NNCP configured Successfully&#34;)
                return sample

            if sample == self.Conditions.Reason.FAILED:
                for failed_nnce in self._get_failed_nnce():
                    nnce_dict = failed_nnce.instance.to_dict()
                    for cond in nnce_dict[&#34;status&#34;][&#34;conditions&#34;]:
                        error = re.findall(
                            r&#34;libnmstate.error.*&#34;, cond.get(&#34;message&#34;, &#34;&#34;)
                        )
                        if error:
                            LOGGER.error(
                                f&#34;NNCE {nnce_dict[&#39;metadata&#39;][&#39;name&#39;]}: {error[0]}&#34;
                            )

                raise NNCPConfigurationFailed(
                    f&#34;Reason: {self.Conditions.Reason.FAILED}&#34;
                )

    except (TimeoutExpiredError, NNCPConfigurationFailed):
        LOGGER.error(&#34;Unable to configure NNCP for node&#34;)
        raise</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ocp_resources.resource.Resource" href="resource.html#ocp_resources.resource.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="ocp_resources.resource.Resource.api" href="resource.html#ocp_resources.resource.Resource.api">api</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.api_request" href="resource.html#ocp_resources.resource.Resource.api_request">api_request</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.client_wait_deleted" href="resource.html#ocp_resources.resource.Resource.client_wait_deleted">client_wait_deleted</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.create" href="resource.html#ocp_resources.resource.Resource.create">create</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.exists" href="resource.html#ocp_resources.resource.Resource.exists">exists</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.get" href="resource.html#ocp_resources.resource.Resource.get">get</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.instance" href="resource.html#ocp_resources.resource.Resource.instance">instance</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.labels" href="resource.html#ocp_resources.resource.Resource.labels">labels</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.status" href="resource.html#ocp_resources.resource.Resource.status">status</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.to_dict" href="resource.html#ocp_resources.resource.Resource.to_dict">to_dict</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.update" href="resource.html#ocp_resources.resource.Resource.update">update</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.update_replace" href="resource.html#ocp_resources.resource.Resource.update_replace">update_replace</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait" href="resource.html#ocp_resources.resource.Resource.wait">wait</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_deleted" href="resource.html#ocp_resources.resource.Resource.wait_deleted">wait_deleted</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_for_condition" href="resource.html#ocp_resources.resource.Resource.wait_for_condition">wait_for_condition</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_for_status" href="resource.html#ocp_resources.resource.Resource.wait_for_status">wait_for_status</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocp_resources" href="index.html">ocp_resources</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ocp_resources.node_network_configuration_policy.NNCPConfigurationFailed" href="#ocp_resources.node_network_configuration_policy.NNCPConfigurationFailed">NNCPConfigurationFailed</a></code></h4>
</li>
<li>
<h4><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy">NodeNetworkConfigurationPolicy</a></code></h4>
<ul class="">
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.Conditions" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.Conditions">Conditions</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.api_group" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.api_group">api_group</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.apply" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.apply">apply</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.clean_up" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.clean_up">clean_up</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.deploy" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.deploy">deploy</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.ipv4_dhcp" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.ipv4_dhcp">ipv4_dhcp</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.set_interface" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.set_interface">set_interface</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.validate_create" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.validate_create">validate_create</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.wait_for_interface_deleted" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.wait_for_interface_deleted">wait_for_interface_deleted</a></code></li>
<li><code><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.wait_for_status_success" href="#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy.wait_for_status_success">wait_for_status_success</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

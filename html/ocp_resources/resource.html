<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ocp_resources.resource API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocp_resources.resource</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import logging
import os
import re
from distutils.version import Version

import kubernetes
import urllib3
from openshift.dynamic import DynamicClient
from openshift.dynamic.exceptions import InternalServerError, NotFoundError
from urllib3.exceptions import ProtocolError

from ocp_resources.utils import TimeoutExpiredError, TimeoutSampler


LOGGER = logging.getLogger(__name__)
TIMEOUT = 240
MAX_SUPPORTED_API_VERSION = &#34;v1&#34;


def _collect_instance_data(directory, resource_object):
    with open(os.path.join(directory, f&#34;{resource_object.name}.yaml&#34;), &#34;w&#34;) as fd:
        fd.write(resource_object.instance.to_str())


def _collect_pod_logs(dyn_client, resource_item, **kwargs):
    kube_v1_api = kubernetes.client.CoreV1Api(api_client=dyn_client.client)
    return kube_v1_api.read_namespaced_pod_log(
        name=resource_item.metadata.name,
        namespace=resource_item.metadata.namespace,
        **kwargs,
    )


def _collect_virt_launcher_data(dyn_client, directory, resource_object):
    if resource_object.kind == &#34;VirtualMachineInstance&#34;:
        for pod in dyn_client.resources.get(kind=&#34;Pod&#34;).get().items:
            pod_name = pod.metadata.name
            pod_instance = dyn_client.resources.get(
                api_version=pod.apiVersion, kind=pod.kind
            ).get(name=pod_name, namespace=pod.metadata.namespace)
            if pod_name.startswith(&#34;virt-launcher&#34;):
                with open(os.path.join(directory, f&#34;{pod_name}.log&#34;), &#34;w&#34;) as fd:
                    fd.write(
                        _collect_pod_logs(
                            dyn_client=dyn_client,
                            resource_item=pod,
                            container=&#34;compute&#34;,
                        )
                    )

                with open(os.path.join(directory, f&#34;{pod_name}.yaml&#34;), &#34;w&#34;) as fd:
                    fd.write(pod_instance.to_str())


def _collect_data_volume_data(dyn_client, directory, resource_object):
    if resource_object.kind == &#34;DataVolume&#34;:
        cdi_worker_prefixes = (&#34;importer&#34;, &#34;cdi-upload&#34;)
        for pod in dyn_client.resources.get(kind=&#34;Pod&#34;).get().items:
            pod_name = pod.metadata.name
            pod_instance = dyn_client.resources.get(
                api_version=pod.apiVersion, kind=pod.kind
            ).get(name=pod_name, namespace=pod.metadata.namespace)
            if pod_name.startswith(cdi_worker_prefixes) or pod_name.endswith(
                &#34;source-pod&#34;
            ):
                with open(os.path.join(directory, f&#34;{pod_name}.log&#34;), &#34;w&#34;) as fd:
                    fd.write(
                        _collect_pod_logs(dyn_client=dyn_client, resource_item=pod)
                    )

                with open(os.path.join(directory, f&#34;{pod_name}.yaml&#34;), &#34;w&#34;) as fd:
                    fd.write(pod_instance.to_str())


def _collect_data(resource_object, dyn_client=None):
    dyn_client = (
        dyn_client
        if dyn_client
        else DynamicClient(kubernetes.config.new_client_from_config())
    )
    directory = os.environ.get(&#34;TEST_DIR_LOG&#34;)
    _collect_instance_data(directory=directory, resource_object=resource_object)
    _collect_virt_launcher_data(
        dyn_client=dyn_client, directory=directory, resource_object=resource_object
    )
    _collect_data_volume_data(
        dyn_client=dyn_client, directory=directory, resource_object=resource_object
    )


def _find_supported_resource(dyn_client, api_group, kind):
    results = dyn_client.resources.search(group=api_group, kind=kind)
    sorted_results = sorted(
        results, key=lambda result: KubeAPIVersion(result.api_version), reverse=True
    )
    for result in sorted_results:
        if KubeAPIVersion(result.api_version) &lt;= KubeAPIVersion(
            MAX_SUPPORTED_API_VERSION
        ):
            return result


def _get_api_version(dyn_client, api_group, kind):
    # Returns api_group/api_version
    res = _find_supported_resource(
        dyn_client=dyn_client, api_group=api_group, kind=kind
    )
    if not res:
        log = f&#34;Couldn&#39;t find {kind} in {api_group} api group&#34;
        LOGGER.warning(log)
        raise NotImplementedError(log)
    return res.group_version


def sub_resource_level(current_class, owner_class, parent_class):
    # return the name of the last class in MRO list that is not one of base
    # classes; otherwise return None
    for class_iterator in reversed(
        list(
            class_iterator
            for class_iterator in current_class.mro()
            if class_iterator not in owner_class.mro()
            and issubclass(class_iterator, parent_class)
        )
    ):
        return class_iterator.__name__


class KubeAPIVersion(Version):
    &#34;&#34;&#34;
    Implement the Kubernetes API versioning scheme from
    https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-versioning
    &#34;&#34;&#34;

    component_re = re.compile(r&#34;(\d+ | [a-z]+)&#34;, re.VERBOSE)

    def __init__(self, vstring=None):
        self.vstring = vstring
        self.version = None
        super().__init__(vstring=vstring)

    def parse(self, vstring):
        components = [x for x in self.component_re.split(vstring) if x]
        for i, obj in enumerate(components):
            try:
                components[i] = int(obj)
            except ValueError:
                pass

        errmsg = f&#34;version &#39;{vstring}&#39; does not conform to kubernetes api versioning guidelines&#34;

        if (
            len(components) not in (2, 4)
            or components[0] != &#34;v&#34;
            or not isinstance(components[1], int)
        ):
            raise ValueError(errmsg)
        if len(components) == 4 and (
            components[2] not in (&#34;alpha&#34;, &#34;beta&#34;) or not isinstance(components[3], int)
        ):
            raise ValueError(errmsg)

        self.version = components

    def __str__(self):
        return self.vstring

    def __repr__(self):
        return &#34;KubeAPIVersion (&#39;{0}&#39;)&#34;.format(str(self))

    def _cmp(self, other):
        if isinstance(other, str):
            other = KubeAPIVersion(vstring=other)

        myver = self.version
        otherver = other.version

        for ver in myver, otherver:
            if len(ver) == 2:
                ver.extend([&#34;zeta&#34;, 9999])

        if myver == otherver:
            return 0
        if myver &lt; otherver:
            return -1
        if myver &gt; otherver:
            return 1


class classproperty(object):  # noqa: N801
    def __init__(self, func):
        self.func = func

    def __get__(self, obj, owner):
        return self.func(owner)


class ValueMismatch(Exception):
    &#34;&#34;&#34;
    Raises when value doesn&#39;t match the class value
    &#34;&#34;&#34;

    pass


class Resource(object):
    &#34;&#34;&#34;
    Base class for API resources
    &#34;&#34;&#34;

    api_group = None
    api_version = None
    singular_name = None

    class Status:
        SUCCEEDED = &#34;Succeeded&#34;
        FAILED = &#34;Failed&#34;
        DELETING = &#34;Deleting&#34;
        DEPLOYED = &#34;Deployed&#34;
        PENDING = &#34;Pending&#34;
        COMPLETED = &#34;Completed&#34;

    class Condition:
        UPGRADEABLE = &#34;Upgradeable&#34;
        AVAILABLE = &#34;Available&#34;
        DEGRADED = &#34;Degraded&#34;
        PROGRESSING = &#34;Progressing&#34;
        CREATED = &#34;Created&#34;
        RECONCILE_COMPLETE = &#34;ReconcileComplete&#34;
        READY = &#34;Ready&#34;

        class Status:
            TRUE = &#34;True&#34;
            FALSE = &#34;False&#34;
            UNKNOWN = &#34;Unknown&#34;

        class Phase:
            INSTALL_READY = &#34;InstallReady&#34;
            SUCCEEDED = &#34;Succeeded&#34;

        class Reason:
            ALL_REQUIREMENTS_MET = &#34;AllRequirementsMet&#34;
            INSTALL_SUCCEEDED = &#34;InstallSucceeded&#34;

    class Interface:
        class State:
            UP = &#34;up&#34;
            DOWN = &#34;down&#34;
            ABSENT = &#34;absent&#34;

    class ApiGroup:
        ADMISSIONREGISTRATION_K8S_IO = &#34;admissionregistration.k8s.io&#34;
        APIEXTENSIONS_K8S_IO = &#34;apiextensions.k8s.io&#34;
        APIREGISTRATION_K8S_IO = &#34;apiregistration.k8s.io&#34;
        APPS = &#34;apps&#34;
        CDI_KUBEVIRT_IO = &#34;cdi.kubevirt.io&#34;
        CONFIG_OPENSHIFT_IO = &#34;config.openshift.io&#34;
        CONSOLE_OPENSHIFT_IO = &#34;console.openshift.io&#34;
        FORKLIFT_KONVEYOR_IO = &#34;forklift.konveyor.io&#34;
        HCO_KUBEVIRT_IO = &#34;hco.kubevirt.io&#34;
        HOSTPATHPROVISIONER_KUBEVIRT_IO = &#34;hostpathprovisioner.kubevirt.io&#34;
        IMAGE_OPENSHIFT_IO = &#34;image.openshift.io&#34;
        K8S_CNI_CNCF_IO = &#34;k8s.cni.cncf.io&#34;
        K8S_V1_CNI_CNCF_IO = &#34;k8s.v1.cni.cncf.io&#34;
        KUBERNETES_IO = &#34;kubernetes.io&#34;
        KUBEVIRT_IO = &#34;kubevirt.io&#34;
        KUBEVIRT_KUBEVIRT_IO = &#34;kubevirt.kubevirt.io&#34;
        LITMUS_IO = &#34;litmuschaos.io&#34;
        MACHINE_OPENSHIFT_IO = &#34;machine.openshift.io&#34;
        MACHINECONFIGURATION_OPENSHIFT_IO = &#34;machineconfiguration.openshift.io&#34;
        MONITORING_COREOS_COM = &#34;monitoring.coreos.com&#34;
        NETWORKADDONSOPERATOR_NETWORK_KUBEVIRT_IO = (
            &#34;networkaddonsoperator.network.kubevirt.io&#34;
        )
        NETWORKING_K8S_IO = &#34;networking.k8s.io&#34;
        NMSTATE_IO = &#34;nmstate.io&#34;
        NODEMAINTENANCE_KUBEVIRT_IO = &#34;nodemaintenance.kubevirt.io&#34;
        OPERATOR_OPENSHIFT_IO = &#34;operator.openshift.io&#34;
        OPERATORS_COREOS_COM = &#34;operators.coreos.com&#34;
        OS_TEMPLATE_KUBEVIRT_IO = &#34;os.template.kubevirt.io&#34;
        PACKAGES_OPERATORS_COREOS_COM = &#34;packages.operators.coreos.com&#34;
        PROJECT_OPENSHIFT_IO = &#34;project.openshift.io&#34;
        RBAC_AUTHORIZATION_K8S_IO = &#34;rbac.authorization.k8s.io&#34;
        RIPSAW_CLOUDBULLDOZER_IO = &#34;ripsaw.cloudbulldozer.io&#34;
        ROUTE_OPENSHIFT_IO = &#34;route.openshift.io&#34;
        SCHEDULING_K8S_IO = &#34;scheduling.k8s.io&#34;
        SECURITY_OPENSHIFT_IO = &#34;security.openshift.io&#34;
        SNAPSHOT_STORAGE_K8S_IO = &#34;snapshot.storage.k8s.io&#34;
        SNAPSHOT_KUBEVIRT_IO = &#34;snapshot.kubevirt.io&#34;
        SRIOVNETWORK_OPENSHIFT_IO = &#34;sriovnetwork.openshift.io&#34;
        SSP_KUBEVIRT_IO = &#34;ssp.kubevirt.io&#34;
        STORAGE_K8S_IO = &#34;storage.k8s.io&#34;
        STORAGECLASS_KUBERNETES_IO = &#34;storageclass.kubernetes.io&#34;
        TEMPLATE_KUBEVIRT_IO = &#34;template.kubevirt.io&#34;
        TEMPLATE_OPENSHIFT_IO = &#34;template.openshift.io&#34;
        UPLOAD_CDI_KUBEVIRT_IO = &#34;upload.cdi.kubevirt.io&#34;
        V2V_KUBEVIRT_IO = &#34;v2v.kubevirt.io&#34;

    class ApiVersion:
        V1 = &#34;v1&#34;
        V1BETA1 = &#34;v1beta1&#34;
        V1ALPHA1 = &#34;v1alpha1&#34;

    def __init__(
        self, name, client=None, teardown=True, timeout=TIMEOUT, privileged_client=None
    ):
        &#34;&#34;&#34;
        Create a API resource

        Args:
            name (str): Resource name
        &#34;&#34;&#34;
        if not self.api_group and not self.api_version:
            raise NotImplementedError(
                &#34;Subclasses of Resource require self.api_group or self.api_version to be defined&#34;
            )
        self.namespace = None
        self.name = name
        self.client = client
        self.privileged_client = privileged_client
        if not self.client:
            try:
                self.client = DynamicClient(
                    client=kubernetes.config.new_client_from_config()
                )
            except (
                kubernetes.config.ConfigException,
                urllib3.exceptions.MaxRetryError,
            ):
                LOGGER.error(
                    &#34;You need to be logged into a cluster or have $KUBECONFIG env configured&#34;
                )
                raise
        if not self.api_version:
            self.api_version = _get_api_version(
                dyn_client=self.client, api_group=self.api_group, kind=self.kind
            )

        self.teardown = teardown
        self.timeout = timeout

    @classproperty
    def kind(cls):  # noqa: N805
        return sub_resource_level(cls, NamespacedResource, Resource)

    def _base_body(self):
        return {
            &#34;apiVersion&#34;: self.api_version,
            &#34;kind&#34;: self.kind,
            &#34;metadata&#34;: {&#34;name&#34;: self.name},
        }

    def to_dict(self):
        &#34;&#34;&#34;
        Generate intended dict representation of the resource.
        &#34;&#34;&#34;
        return self._base_body()

    def __enter__(self):
        return self.deploy()

    def __exit__(self, exception_type, exception_value, traceback):
        if self.teardown:
            self.clean_up()

    def deploy(self):
        self.create()
        return self

    def clean_up(self):
        if os.environ.get(&#34;CNV_TEST_COLLECT_LOGS&#34;, &#34;0&#34;) == &#34;1&#34;:
            try:
                _collect_data(resource_object=self)
            except Exception as exception_:
                LOGGER.warning(exception_)

        data = self.to_dict()
        LOGGER.info(f&#34;Deleting {data}&#34;)
        self.delete(wait=True, timeout=self.timeout)

    @classmethod
    def _prepare_resources(cls, dyn_client, singular_name, *args, **kwargs):
        if not cls.api_version:
            cls.api_version = _get_api_version(
                dyn_client=dyn_client, api_group=cls.api_group, kind=cls.kind
            )

        get_kwargs = {&#34;singular_name&#34;: singular_name} if singular_name else {}
        return dyn_client.resources.get(
            kind=cls.kind, api_version=cls.api_version, **get_kwargs
        ).get(*args, **kwargs)

    def api(self, **kwargs):
        &#34;&#34;&#34;
        Get resource API

        Keyword Args:
            pretty
            _continue
            include_uninitialized
            field_selector
            label_selector
            limit
            resource_version
            timeout_seconds
            watch
            async_req

        Returns:
            Resource: Resource object.
        &#34;&#34;&#34;
        if self.singular_name:
            kwargs[&#34;singular_name&#34;] = self.singular_name
        return self.client.resources.get(
            api_version=self.api_version, kind=self.kind, **kwargs
        )

    def wait(self, timeout=TIMEOUT, sleep=1):
        &#34;&#34;&#34;
        Wait for resource

        Args:
            timeout (int): Time to wait for the resource.
            sleep (int): Time to wait between retries

        Raises:
            TimeoutExpiredError: If resource not exists.
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Wait until {self.kind} {self.name} is created&#34;)
        samples = TimeoutSampler(
            wait_timeout=timeout,
            sleep=sleep,
            exceptions=(ProtocolError, NotFoundError),
            func=lambda: self.exists,
        )
        for sample in samples:
            if sample:
                return

    def wait_deleted(self, timeout=TIMEOUT):
        &#34;&#34;&#34;
        Wait until resource is deleted

        Args:
            timeout (int): Time to wait for the resource.

        Raises:
            TimeoutExpiredError: If resource still exists.
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Wait until {self.kind} {self.name} is deleted&#34;)
        return self.client_wait_deleted(timeout=timeout)

    @property
    def exists(self):
        &#34;&#34;&#34;
        Whether self exists on the server
        &#34;&#34;&#34;
        try:
            return self.instance
        except NotFoundError:
            return None

    def client_wait_deleted(self, timeout):
        &#34;&#34;&#34;
        client-side Wait until resource is deleted

        Args:
            timeout (int): Time to wait for the resource.

        Raises:
            TimeoutExpiredError: If resource still exists.
        &#34;&#34;&#34;
        samples = TimeoutSampler(
            wait_timeout=timeout, sleep=1, func=lambda: self.exists
        )
        for sample in samples:
            if not sample:
                return

    def wait_for_status(self, status, timeout=TIMEOUT, stop_status=None, sleep=1):
        &#34;&#34;&#34;
        Wait for resource to be in status

        Args:
            status (str): Expected status.
            timeout (int): Time to wait for the resource.
            stop_status (str): Status which should stop the wait and failed.

        Raises:
            TimeoutExpiredError: If resource in not in desire status.
        &#34;&#34;&#34;
        stop_status = stop_status if stop_status else self.Status.FAILED
        LOGGER.info(f&#34;Wait for {self.kind} {self.name} status to be {status}&#34;)
        samples = TimeoutSampler(
            wait_timeout=timeout,
            sleep=sleep,
            exceptions=ProtocolError,
            func=self.api().get,
            field_selector=f&#34;metadata.name=={self.name}&#34;,
            namespace=self.namespace,
        )
        current_status = None
        try:
            for sample in samples:
                if sample.items:
                    sample_status = sample.items[0].status
                    if sample_status:
                        current_status = sample_status.phase
                        if current_status == status:
                            return

                        if current_status == stop_status:
                            raise TimeoutExpiredError(
                                f&#34;Status of {self.kind} {self.name} is {current_status}&#34;
                            )

        except TimeoutExpiredError:
            if current_status:
                LOGGER.error(f&#34;Status of {self.kind} {self.name} is {current_status}&#34;)
            raise

    def create(self, body=None, wait=False):
        &#34;&#34;&#34;
        Create resource.

        Args:
            body (dict): Resource data to create.
            wait (bool) : True to wait for resource status.

        Returns:
            bool: True if create succeeded, False otherwise.

        Raises:
            ValueMismatch: When body value doesn&#39;t match class value
        &#34;&#34;&#34;
        data = self.to_dict()
        if body:
            kind = body[&#34;kind&#34;]
            name = body.get(&#34;name&#34;)
            api_version = body[&#34;apiVersion&#34;]
            if kind != self.kind:
                ValueMismatch(f&#34;{kind} != {self.kind}&#34;)
            if name and name != self.name:
                ValueMismatch(f&#34;{name} != {self.name}&#34;)
            if api_version != self.api_version:
                ValueMismatch(f&#34;{api_version} != {self.api_version}&#34;)

            data.update(body)

        LOGGER.info(f&#34;Posting {data}&#34;)
        LOGGER.info(f&#34;Create {self.kind} {self.name}&#34;)
        res = self.api().create(body=data, namespace=self.namespace)
        if wait and res:
            return self.wait()
        return res

    def delete(self, wait=False, timeout=TIMEOUT):
        resource_list = self.api()
        try:
            res = resource_list.delete(name=self.name, namespace=self.namespace)
        except NotFoundError:
            return False

        LOGGER.info(f&#34;Delete {self.kind} {self.name}&#34;)
        if wait and res:
            return self.wait_deleted(timeout=timeout)
        return res

    @property
    def status(self):
        &#34;&#34;&#34;
        Get resource status

        Status: Running, Scheduling, Pending, Unknown, CrashLoopBackOff

        Returns:
           str: Status
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Get {self.kind} {self.name} status&#34;)
        return self.instance.status.phase

    def update(self, resource_dict):
        &#34;&#34;&#34;
        Update resource with resource dict

        Args:
            resource_dict: Resource dictionary
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Update {self.kind} {self.name}: {resource_dict}&#34;)
        self.api().patch(
            body=resource_dict,
            namespace=self.namespace,
            content_type=&#34;application/merge-patch+json&#34;,
        )

    def update_replace(self, resource_dict):
        &#34;&#34;&#34;
        Replace resource metadata.
        Use this to remove existing field. (update() will only update existing fields)
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Replace {self.kind} {self.name}: {resource_dict}&#34;)
        self.api().replace(body=resource_dict, name=self.name, namespace=self.namespace)

    @staticmethod
    def _retry_etcd_changed(func):
        sampler = TimeoutSampler(
            wait_timeout=10,
            sleep=1,
            func=func,
            exceptions=InternalServerError,
            exceptions_msg=&#34;etcdserver: leader changed&#34;,
            print_log=False,
        )
        for sample in sampler:
            return sample

    @classmethod
    def get(cls, dyn_client, singular_name=None, *args, **kwargs):
        &#34;&#34;&#34;
        Get resources

        Args:
            dyn_client (DynamicClient): Open connection to remote cluster
            singular_name (str): Resource kind (in lowercase), in use where we have multiple matches for resource

        Returns:
            generator: Generator of Resources of cls.kind
        &#34;&#34;&#34;

        def _get():
            _resources = cls._prepare_resources(
                dyn_client=dyn_client, singular_name=singular_name, *args, **kwargs
            )
            try:
                for resource_field in _resources.items:
                    yield cls(client=dyn_client, name=resource_field.metadata.name)
            except TypeError:
                yield cls(client=dyn_client, name=_resources.metadata.name)

        return Resource._retry_etcd_changed(func=_get)

    @property
    def instance(self):
        &#34;&#34;&#34;
        Get resource instance

        Returns:
            openshift.dynamic.client.ResourceInstance
        &#34;&#34;&#34;

        def _instance():
            return self.api().get(name=self.name)

        return self._retry_etcd_changed(func=_instance)

    @property
    def labels(self):
        &#34;&#34;&#34;
        Method to get dict of labels for this resource

        Returns:
           labels(dict): dict labels
        &#34;&#34;&#34;
        return self.instance[&#34;metadata&#34;][&#34;labels&#34;]

    def wait_for_condition(self, condition, status, timeout=300):
        &#34;&#34;&#34;
        Wait for Pod condition to be in desire status.

        Args:
            condition (str): Condition to query.
            status (str): Expected condition status.
            timeout (int): Time to wait for the resource.

        Raises:
            TimeoutExpiredError: If Pod condition in not in desire status.
        &#34;&#34;&#34;
        LOGGER.info(
            f&#34;Wait for {self.kind}/{self.name}&#39;s &#39;{condition}&#39; condition to be &#39;{status}&#39;&#34;
        )
        samples = TimeoutSampler(
            wait_timeout=timeout,
            sleep=1,
            exceptions=ProtocolError,
            func=self.api().get,
            field_selector=f&#34;metadata.name=={self.name}&#34;,
            namespace=self.namespace,
        )
        for sample in samples:
            if (
                sample.items
                and sample.items[0].get(&#34;status&#34;)
                and sample.items[0].status.get(&#34;conditions&#34;)
            ):
                sample_conditions = sample.items[0].status.conditions
                if sample_conditions:
                    for cond in sample_conditions:
                        if cond.type == condition and cond.status == status:
                            return

    def api_request(self, method, action, url, **params):
        &#34;&#34;&#34;
        Handle API requests to resource.

        Args:
            method (str): Request method (GET/PUT etc.).
            action (str): Action to perform (stop/start/guestosinfo etc.).
            url (str): URL of resource.

        Returns:
           data(dict): response data

        &#34;&#34;&#34;
        client = self.privileged_client or self.client
        response = client.client.request(
            method=method,
            url=f&#34;{url}/{action}&#34;,
            headers=self.client.configuration.api_key,
            **params,
        )

        try:
            return json.loads(response.data)
        except json.decoder.JSONDecodeError:
            return response.data

    def wait_for_conditions(self):
        samples = TimeoutSampler(
            wait_timeout=30, sleep=1, func=lambda: self.instance.status.conditions
        )
        for sample in samples:
            if sample:
                return


class NamespacedResource(Resource):
    &#34;&#34;&#34;
    Namespaced object, inherited from Resource.
    &#34;&#34;&#34;

    def __init__(
        self,
        name,
        namespace,
        client=None,
        teardown=True,
        timeout=TIMEOUT,
        privileged_client=None,
    ):
        super().__init__(
            name=name,
            client=client,
            teardown=teardown,
            timeout=timeout,
            privileged_client=privileged_client,
        )
        self.namespace = namespace

    @classmethod
    def get(cls, dyn_client, singular_name=None, *args, **kwargs):
        &#34;&#34;&#34;
        Get resources

        Args:
            dyn_client (DynamicClient): Open connection to remote cluster
            singular_name (str): Resource kind (in lowercase), in use where we have multiple matches for resource


        Returns:
            generator: Generator of Resources of cls.kind
        &#34;&#34;&#34;
        _resources = cls._prepare_resources(
            dyn_client=dyn_client, singular_name=singular_name, *args, **kwargs
        )
        try:
            for resource_field in _resources.items:
                yield cls(
                    client=dyn_client,
                    name=resource_field.metadata.name,
                    namespace=resource_field.metadata.namespace,
                )
        except TypeError:
            yield cls(
                client=dyn_client,
                name=_resources.metadata.name,
                namespace=_resources.metadata.namespace,
            )

    @property
    def instance(self):
        &#34;&#34;&#34;
        Get resource instance

        Returns:
            openshift.dynamic.client.ResourceInstance
        &#34;&#34;&#34;
        return self.api().get(name=self.name, namespace=self.namespace)

    def _base_body(self):
        return {
            &#34;apiVersion&#34;: self.api_version,
            &#34;kind&#34;: self.kind,
            &#34;metadata&#34;: {&#34;name&#34;: self.name, &#34;namespace&#34;: self.namespace},
        }

    def to_dict(self):
        return self._base_body()


class ResourceEditor(object):
    def __init__(self, patches, action=&#34;update&#34;, user_backups=None):
        &#34;&#34;&#34;
        Args:
            patches (dict): {&lt;Resource object&gt;: &lt;yaml patch as dict&gt;}
                e.g. {&lt;Resource object&gt;:
                        {&#39;metadata&#39;: {&#39;labels&#39;: {&#39;label1&#39;: &#39;true&#39;}}}

        Allows for temporary edits to cluster resources for tests. During
        __enter__ user-specified patches (see args) are applied and old values
        are backed up, and during __exit__ these backups are used to reverse
        all changes made.

        Flow:
        1) apply patches
        2) automation runs
        3) edits made to resources are reversed

        May also be used without being treated as a context manager by
        calling the methods update() and restore() after instantiation.

        *** the DynamicClient object used to get the resources must not be
         using an unprivileged_user; use default_client or similar instead.***
        &#34;&#34;&#34;

        self._patches = patches
        self.action = action
        self.user_backups = user_backups
        self._backups = {}

    @property
    def backups(self):
        &#34;&#34;&#34;Returns a dict {&lt;Resource object&gt;: &lt;backup_as_dict&gt;}
        The backup dict kept for each resource edited&#34;&#34;&#34;
        return self._backups

    @property
    def patches(self):
        &#34;&#34;&#34;Returns the patches dict provided in the constructor&#34;&#34;&#34;
        return self._patches

    def update(self, backup_resources=False):
        &#34;&#34;&#34;Prepares backup dicts (where necessary) and applies patches&#34;&#34;&#34;
        # prepare update dicts and backups
        resource_to_patch = []
        if backup_resources:
            LOGGER.info(&#34;ResourceEdit: Backing up old data&#34;)
            if self.user_backups:
                resource_to_patch = self._patches
                self._backups = self.user_backups

            else:
                for resource, update in self._patches.items():
                    namespace = None
                    # prepare backup
                    try:
                        original_resource_dict = resource.instance.to_dict()
                    except NotFoundError:
                        # Some resource cannot be found by name.
                        # happens in &#39;ServiceMonitor&#39; resource.
                        original_resource_dict = list(
                            resource.get(
                                dyn_client=resource.client,
                                field_selector=f&#34;metadata.name={resource.name}&#34;,
                            )
                        )[0].to_dict()
                        namespace = update.get(&#34;metadata&#34;, {}).get(&#34;namespace&#34;)

                    backup = self._create_backup(
                        original=original_resource_dict, patch=update
                    )
                    if namespace:
                        # Add namespace to metadata for restore.
                        backup[&#34;metadata&#34;][&#34;namespace&#34;] = namespace

                    # no need to back up if no changes have been made
                    # if action is &#39;replace&#39; we need to update even if no backup (replace update can be empty )
                    if backup or self.action == &#34;replace&#34;:
                        resource_to_patch.append(resource)
                        self._backups[resource] = backup
                    else:
                        LOGGER.warning(
                            f&#34;ResourceEdit: no diff found in patch for &#34;
                            f&#34;{resource.name} -- skipping&#34;
                        )
                if not resource_to_patch:
                    return
        else:
            resource_to_patch = self._patches

        patches_to_apply = {
            resource: self._patches[resource] for resource in resource_to_patch
        }

        # apply changes
        self._apply_patches(
            patches=patches_to_apply, action_text=&#34;Updating&#34;, action=self.action
        )

    def restore(self):
        self._apply_patches(
            patches=self._backups, action_text=&#34;Restoring&#34;, action=self.action
        )

    def __enter__(self):
        self.update(backup_resources=True)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # restore backups
        self.restore()

    @staticmethod
    def _create_backup(original, patch):
        &#34;&#34;&#34;
        Args:
            original (dict*): source of values to back up if necessary
            patch (dict*): &#39;new&#39; values; keys needn&#39;t necessarily all be
                contained in original

        Returns a dict containing the fields in original that are different
        from update. Performs the

        Places None for fields in update that don&#39;t appear in
        original (because that&#39;s how the API knows to remove those fields from
        the yaml).

        * the first call will be with both of these arguments as dicts but
        this will not necessarily be the case during recursion&#34;&#34;&#34;

        # when both are dicts, get the diff (recursively if need be)
        if isinstance(original, dict) and isinstance(patch, dict):
            diff_dict = {}
            for key, value in patch.items():
                if key not in original:
                    diff_dict[key] = None
                    continue

                # recursive call
                key_diff = ResourceEditor._create_backup(
                    original=original[key], patch=value
                )

                if key_diff is not None:
                    diff_dict[key] = key_diff

            return diff_dict

        # for one or more non-dict values, just compare them
        if patch != original:
            return original
        else:
            # this return value will be received by key_diff above
            return None

    @staticmethod
    def _apply_patches(patches, action_text, action):
        &#34;&#34;&#34;
        Updates provided Resource objects with provided yaml patches

        Args:
            patches (dict): {&lt;Resource object&gt;: &lt;yaml patch as dict&gt;}
            action_text (str):
                &#34;ResourceEdit &lt;action_text&gt; for resource &lt;resource name&gt;&#34;
                will be printed for each resource; see below
        &#34;&#34;&#34;
        for resource, patch in patches.items():
            LOGGER.info(
                f&#34;ResourceEdits: {action_text} data for &#34;
                f&#34;resource {resource.kind} {resource.name}&#34;
            )

            # add name to patch
            if &#34;metadata&#34; not in patch:
                patch[&#34;metadata&#34;] = {}

            # the api requires this field to be present in a yaml patch for
            # some resource kinds even if it is not changed
            if &#34;name&#34; not in patch[&#34;metadata&#34;]:
                patch[&#34;metadata&#34;][&#34;name&#34;] = resource.name

            if action == &#34;update&#34;:
                resource.update(resource_dict=patch)  # update the resource

            if action == &#34;replace&#34;:
                if &#34;metadata&#34; not in patch:
                    patch[&#34;metadata&#34;] = {}

                patch[&#34;metadata&#34;][&#34;name&#34;] = resource.name
                patch[&#34;metadata&#34;][&#34;namespace&#34;] = resource.namespace
                patch[&#34;metadata&#34;][
                    &#34;resourceVersion&#34;
                ] = resource.instance.metadata.resourceVersion
                patch[&#34;kind&#34;] = resource.kind
                patch[&#34;apiVersion&#34;] = resource.api_version

                resource.update_replace(
                    resource_dict=patch
                )  # replace the resource metadata</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ocp_resources.resource.sub_resource_level"><code class="name flex">
<span>def <span class="ident">sub_resource_level</span></span>(<span>current_class, owner_class, parent_class)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sub_resource_level(current_class, owner_class, parent_class):
    # return the name of the last class in MRO list that is not one of base
    # classes; otherwise return None
    for class_iterator in reversed(
        list(
            class_iterator
            for class_iterator in current_class.mro()
            if class_iterator not in owner_class.mro()
            and issubclass(class_iterator, parent_class)
        )
    ):
        return class_iterator.__name__</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ocp_resources.resource.KubeAPIVersion"><code class="flex name class">
<span>class <span class="ident">KubeAPIVersion</span></span>
<span>(</span><span>vstring=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the Kubernetes API versioning scheme from
<a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-versioning">https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-versioning</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KubeAPIVersion(Version):
    &#34;&#34;&#34;
    Implement the Kubernetes API versioning scheme from
    https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-versioning
    &#34;&#34;&#34;

    component_re = re.compile(r&#34;(\d+ | [a-z]+)&#34;, re.VERBOSE)

    def __init__(self, vstring=None):
        self.vstring = vstring
        self.version = None
        super().__init__(vstring=vstring)

    def parse(self, vstring):
        components = [x for x in self.component_re.split(vstring) if x]
        for i, obj in enumerate(components):
            try:
                components[i] = int(obj)
            except ValueError:
                pass

        errmsg = f&#34;version &#39;{vstring}&#39; does not conform to kubernetes api versioning guidelines&#34;

        if (
            len(components) not in (2, 4)
            or components[0] != &#34;v&#34;
            or not isinstance(components[1], int)
        ):
            raise ValueError(errmsg)
        if len(components) == 4 and (
            components[2] not in (&#34;alpha&#34;, &#34;beta&#34;) or not isinstance(components[3], int)
        ):
            raise ValueError(errmsg)

        self.version = components

    def __str__(self):
        return self.vstring

    def __repr__(self):
        return &#34;KubeAPIVersion (&#39;{0}&#39;)&#34;.format(str(self))

    def _cmp(self, other):
        if isinstance(other, str):
            other = KubeAPIVersion(vstring=other)

        myver = self.version
        otherver = other.version

        for ver in myver, otherver:
            if len(ver) == 2:
                ver.extend([&#34;zeta&#34;, 9999])

        if myver == otherver:
            return 0
        if myver &lt; otherver:
            return -1
        if myver &gt; otherver:
            return 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>distutils.version.Version</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ocp_resources.resource.KubeAPIVersion.component_re"><code class="name">var <span class="ident">component_re</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocp_resources.resource.KubeAPIVersion.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, vstring)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, vstring):
    components = [x for x in self.component_re.split(vstring) if x]
    for i, obj in enumerate(components):
        try:
            components[i] = int(obj)
        except ValueError:
            pass

    errmsg = f&#34;version &#39;{vstring}&#39; does not conform to kubernetes api versioning guidelines&#34;

    if (
        len(components) not in (2, 4)
        or components[0] != &#34;v&#34;
        or not isinstance(components[1], int)
    ):
        raise ValueError(errmsg)
    if len(components) == 4 and (
        components[2] not in (&#34;alpha&#34;, &#34;beta&#34;) or not isinstance(components[3], int)
    ):
        raise ValueError(errmsg)

    self.version = components</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ocp_resources.resource.NamespacedResource"><code class="flex name class">
<span>class <span class="ident">NamespacedResource</span></span>
<span>(</span><span>name, namespace, client=None, teardown=True, timeout=240, privileged_client=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Namespaced object, inherited from Resource.</p>
<p>Create a API resource</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Resource name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NamespacedResource(Resource):
    &#34;&#34;&#34;
    Namespaced object, inherited from Resource.
    &#34;&#34;&#34;

    def __init__(
        self,
        name,
        namespace,
        client=None,
        teardown=True,
        timeout=TIMEOUT,
        privileged_client=None,
    ):
        super().__init__(
            name=name,
            client=client,
            teardown=teardown,
            timeout=timeout,
            privileged_client=privileged_client,
        )
        self.namespace = namespace

    @classmethod
    def get(cls, dyn_client, singular_name=None, *args, **kwargs):
        &#34;&#34;&#34;
        Get resources

        Args:
            dyn_client (DynamicClient): Open connection to remote cluster
            singular_name (str): Resource kind (in lowercase), in use where we have multiple matches for resource


        Returns:
            generator: Generator of Resources of cls.kind
        &#34;&#34;&#34;
        _resources = cls._prepare_resources(
            dyn_client=dyn_client, singular_name=singular_name, *args, **kwargs
        )
        try:
            for resource_field in _resources.items:
                yield cls(
                    client=dyn_client,
                    name=resource_field.metadata.name,
                    namespace=resource_field.metadata.namespace,
                )
        except TypeError:
            yield cls(
                client=dyn_client,
                name=_resources.metadata.name,
                namespace=_resources.metadata.namespace,
            )

    @property
    def instance(self):
        &#34;&#34;&#34;
        Get resource instance

        Returns:
            openshift.dynamic.client.ResourceInstance
        &#34;&#34;&#34;
        return self.api().get(name=self.name, namespace=self.namespace)

    def _base_body(self):
        return {
            &#34;apiVersion&#34;: self.api_version,
            &#34;kind&#34;: self.kind,
            &#34;metadata&#34;: {&#34;name&#34;: self.name, &#34;namespace&#34;: self.namespace},
        }

    def to_dict(self):
        return self._base_body()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ocp_resources.resource.Resource" href="#ocp_resources.resource.Resource">Resource</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ocp_resources.benchmark.Benchmark" href="benchmark.html#ocp_resources.benchmark.Benchmark">Benchmark</a></li>
<li><a title="ocp_resources.catalog_source.CatalogSource" href="catalog_source.html#ocp_resources.catalog_source.CatalogSource">CatalogSource</a></li>
<li><a title="ocp_resources.catalog_source_config.CatalogSourceConfig" href="catalog_source_config.html#ocp_resources.catalog_source_config.CatalogSourceConfig">CatalogSourceConfig</a></li>
<li><a title="ocp_resources.cdi.CDI" href="cdi.html#ocp_resources.cdi.CDI">CDI</a></li>
<li><a title="ocp_resources.chaos_engine.ChaosEngine" href="chaos_engine.html#ocp_resources.chaos_engine.ChaosEngine">ChaosEngine</a></li>
<li><a title="ocp_resources.cluster_service_version.ClusterServiceVersion" href="cluster_service_version.html#ocp_resources.cluster_service_version.ClusterServiceVersion">ClusterServiceVersion</a></li>
<li><a title="ocp_resources.configmap.ConfigMap" href="configmap.html#ocp_resources.configmap.ConfigMap">ConfigMap</a></li>
<li><a title="ocp_resources.daemonset.DaemonSet" href="daemonset.html#ocp_resources.daemonset.DaemonSet">DaemonSet</a></li>
<li><a title="ocp_resources.datavolume.DataVolume" href="datavolume.html#ocp_resources.datavolume.DataVolume">DataVolume</a></li>
<li><a title="ocp_resources.deployment.Deployment" href="deployment.html#ocp_resources.deployment.Deployment">Deployment</a></li>
<li><a title="ocp_resources.hyperconverged.HyperConverged" href="hyperconverged.html#ocp_resources.hyperconverged.HyperConverged">HyperConverged</a></li>
<li><a title="ocp_resources.imagestreamtag.ImageStreamTag" href="imagestreamtag.html#ocp_resources.imagestreamtag.ImageStreamTag">ImageStreamTag</a></li>
<li><a title="ocp_resources.installplan.InstallPlan" href="installplan.html#ocp_resources.installplan.InstallPlan">InstallPlan</a></li>
<li><a title="ocp_resources.kube_descheduler.KubeDescheduler" href="kube_descheduler.html#ocp_resources.kube_descheduler.KubeDescheduler">KubeDescheduler</a></li>
<li><a title="ocp_resources.kubevirt.KubeVirt" href="kubevirt.html#ocp_resources.kubevirt.KubeVirt">KubeVirt</a></li>
<li><a title="ocp_resources.kubevirt_common_templates_bundle.KubevirtCommonTemplatesBundle" href="kubevirt_common_templates_bundle.html#ocp_resources.kubevirt_common_templates_bundle.KubevirtCommonTemplatesBundle">KubevirtCommonTemplatesBundle</a></li>
<li><a title="ocp_resources.kubevirt_metrics_aggregation.KubevirtMetricsAggregation" href="kubevirt_metrics_aggregation.html#ocp_resources.kubevirt_metrics_aggregation.KubevirtMetricsAggregation">KubevirtMetricsAggregation</a></li>
<li><a title="ocp_resources.kubevirt_node_labeller_bundle.KubevirtNodeLabellerBundle" href="kubevirt_node_labeller_bundle.html#ocp_resources.kubevirt_node_labeller_bundle.KubevirtNodeLabellerBundle">KubevirtNodeLabellerBundle</a></li>
<li><a title="ocp_resources.kubevirt_template_validaotr.KubevirtTemplateValidator" href="kubevirt_template_validaotr.html#ocp_resources.kubevirt_template_validaotr.KubevirtTemplateValidator">KubevirtTemplateValidator</a></li>
<li><a title="ocp_resources.machine.Machine" href="machine.html#ocp_resources.machine.Machine">Machine</a></li>
<li><a title="ocp_resources.machine_health_check.MachineHealthCheck" href="machine_health_check.html#ocp_resources.machine_health_check.MachineHealthCheck">MachineHealthCheck</a></li>
<li><a title="ocp_resources.migration.Migration" href="migration.html#ocp_resources.migration.Migration">Migration</a></li>
<li><a title="ocp_resources.network_attachment_definition.NetworkAttachmentDefinition" href="network_attachment_definition.html#ocp_resources.network_attachment_definition.NetworkAttachmentDefinition">NetworkAttachmentDefinition</a></li>
<li><a title="ocp_resources.network_map.NetworkMap" href="network_map.html#ocp_resources.network_map.NetworkMap">NetworkMap</a></li>
<li><a title="ocp_resources.network_policy.NetworkPolicy" href="network_policy.html#ocp_resources.network_policy.NetworkPolicy">NetworkPolicy</a></li>
<li><a title="ocp_resources.operator_group.OperatorGroup" href="operator_group.html#ocp_resources.operator_group.OperatorGroup">OperatorGroup</a></li>
<li><a title="ocp_resources.operator_source.OperatorSource" href="operator_source.html#ocp_resources.operator_source.OperatorSource">OperatorSource</a></li>
<li><a title="ocp_resources.package_manifest.PackageManifest" href="package_manifest.html#ocp_resources.package_manifest.PackageManifest">PackageManifest</a></li>
<li><a title="ocp_resources.persistent_volume_claim.PersistentVolumeClaim" href="persistent_volume_claim.html#ocp_resources.persistent_volume_claim.PersistentVolumeClaim">PersistentVolumeClaim</a></li>
<li><a title="ocp_resources.plan.Plan" href="plan.html#ocp_resources.plan.Plan">Plan</a></li>
<li><a title="ocp_resources.pod.Pod" href="pod.html#ocp_resources.pod.Pod">Pod</a></li>
<li><a title="ocp_resources.provider.Provider" href="provider.html#ocp_resources.provider.Provider">Provider</a></li>
<li><a title="ocp_resources.replicaset.ReplicaSet" href="replicaset.html#ocp_resources.replicaset.ReplicaSet">ReplicaSet</a></li>
<li><a title="ocp_resources.role.Role" href="role.html#ocp_resources.role.Role">Role</a></li>
<li><a title="ocp_resources.role_binding.RoleBinding" href="role_binding.html#ocp_resources.role_binding.RoleBinding">RoleBinding</a></li>
<li><a title="ocp_resources.route.Route" href="route.html#ocp_resources.route.Route">Route</a></li>
<li><a title="ocp_resources.secret.Secret" href="secret.html#ocp_resources.secret.Secret">Secret</a></li>
<li><a title="ocp_resources.service.Service" href="service.html#ocp_resources.service.Service">Service</a></li>
<li><a title="ocp_resources.service_account.ServiceAccount" href="service_account.html#ocp_resources.service_account.ServiceAccount">ServiceAccount</a></li>
<li><a title="ocp_resources.sriov_network.SriovNetwork" href="sriov_network.html#ocp_resources.sriov_network.SriovNetwork">SriovNetwork</a></li>
<li><a title="ocp_resources.sriov_network_node_policy.SriovNetworkNodePolicy" href="sriov_network_node_policy.html#ocp_resources.sriov_network_node_policy.SriovNetworkNodePolicy">SriovNetworkNodePolicy</a></li>
<li><a title="ocp_resources.sriov_network_node_state.SriovNetworkNodeState" href="sriov_network_node_state.html#ocp_resources.sriov_network_node_state.SriovNetworkNodeState">SriovNetworkNodeState</a></li>
<li><a title="ocp_resources.ssp.SSP" href="ssp.html#ocp_resources.ssp.SSP">SSP</a></li>
<li><a title="ocp_resources.storage_map.StorageMap" href="storage_map.html#ocp_resources.storage_map.StorageMap">StorageMap</a></li>
<li><a title="ocp_resources.subscription.Subscription" href="subscription.html#ocp_resources.subscription.Subscription">Subscription</a></li>
<li><a title="ocp_resources.template.Template" href="template.html#ocp_resources.template.Template">Template</a></li>
<li><a title="ocp_resources.upload_token_request.UploadTokenRequest" href="upload_token_request.html#ocp_resources.upload_token_request.UploadTokenRequest">UploadTokenRequest</a></li>
<li><a title="ocp_resources.virtual_machine.VirtualMachine" href="virtual_machine.html#ocp_resources.virtual_machine.VirtualMachine">VirtualMachine</a></li>
<li><a title="ocp_resources.virtual_machine.VirtualMachineInstance" href="virtual_machine.html#ocp_resources.virtual_machine.VirtualMachineInstance">VirtualMachineInstance</a></li>
<li><a title="ocp_resources.virtual_machine.VirtualMachineInstanceMigration" href="virtual_machine.html#ocp_resources.virtual_machine.VirtualMachineInstanceMigration">VirtualMachineInstanceMigration</a></li>
<li><a title="ocp_resources.virtual_machine.VirtualMachineInstancePreset" href="virtual_machine.html#ocp_resources.virtual_machine.VirtualMachineInstancePreset">VirtualMachineInstancePreset</a></li>
<li><a title="ocp_resources.virtual_machine.VirtualMachineInstanceReplicaSet" href="virtual_machine.html#ocp_resources.virtual_machine.VirtualMachineInstanceReplicaSet">VirtualMachineInstanceReplicaSet</a></li>
<li><a title="ocp_resources.virtual_machine_import.ResourceMapping" href="virtual_machine_import.html#ocp_resources.virtual_machine_import.ResourceMapping">ResourceMapping</a></li>
<li><a title="ocp_resources.virtual_machine_import.VirtualMachineImport" href="virtual_machine_import.html#ocp_resources.virtual_machine_import.VirtualMachineImport">VirtualMachineImport</a></li>
<li><a title="ocp_resources.virtual_machine_restore.VirtualMachineRestore" href="virtual_machine_restore.html#ocp_resources.virtual_machine_restore.VirtualMachineRestore">VirtualMachineRestore</a></li>
<li><a title="ocp_resources.virtual_machine_snapshot.VirtualMachineSnapshot" href="virtual_machine_snapshot.html#ocp_resources.virtual_machine_snapshot.VirtualMachineSnapshot">VirtualMachineSnapshot</a></li>
<li><a title="ocp_resources.volume_snapshot.VolumeSnapshot" href="volume_snapshot.html#ocp_resources.volume_snapshot.VolumeSnapshot">VolumeSnapshot</a></li>
<li><a title="ocp_resources.volume_snapshot.VolumeSnapshotClass" href="volume_snapshot.html#ocp_resources.volume_snapshot.VolumeSnapshotClass">VolumeSnapshotClass</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="ocp_resources.resource.NamespacedResource.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>dyn_client, singular_name=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get resources</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dyn_client</code></strong> :&ensp;<code>DynamicClient</code></dt>
<dd>Open connection to remote cluster</dd>
<dt><strong><code>singular_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Resource kind (in lowercase), in use where we have multiple matches for resource</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>generator</code></dt>
<dd>Generator of Resources of cls.kind</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get(cls, dyn_client, singular_name=None, *args, **kwargs):
    &#34;&#34;&#34;
    Get resources

    Args:
        dyn_client (DynamicClient): Open connection to remote cluster
        singular_name (str): Resource kind (in lowercase), in use where we have multiple matches for resource


    Returns:
        generator: Generator of Resources of cls.kind
    &#34;&#34;&#34;
    _resources = cls._prepare_resources(
        dyn_client=dyn_client, singular_name=singular_name, *args, **kwargs
    )
    try:
        for resource_field in _resources.items:
            yield cls(
                client=dyn_client,
                name=resource_field.metadata.name,
                namespace=resource_field.metadata.namespace,
            )
    except TypeError:
        yield cls(
            client=dyn_client,
            name=_resources.metadata.name,
            namespace=_resources.metadata.namespace,
        )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ocp_resources.resource.Resource" href="#ocp_resources.resource.Resource">Resource</a></b></code>:
<ul class="hlist">
<li><code><a title="ocp_resources.resource.Resource.api" href="#ocp_resources.resource.Resource.api">api</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.api_request" href="#ocp_resources.resource.Resource.api_request">api_request</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.client_wait_deleted" href="#ocp_resources.resource.Resource.client_wait_deleted">client_wait_deleted</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.create" href="#ocp_resources.resource.Resource.create">create</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.exists" href="#ocp_resources.resource.Resource.exists">exists</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.instance" href="#ocp_resources.resource.Resource.instance">instance</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.labels" href="#ocp_resources.resource.Resource.labels">labels</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.status" href="#ocp_resources.resource.Resource.status">status</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.to_dict" href="#ocp_resources.resource.Resource.to_dict">to_dict</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.update" href="#ocp_resources.resource.Resource.update">update</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.update_replace" href="#ocp_resources.resource.Resource.update_replace">update_replace</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait" href="#ocp_resources.resource.Resource.wait">wait</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_deleted" href="#ocp_resources.resource.Resource.wait_deleted">wait_deleted</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_for_condition" href="#ocp_resources.resource.Resource.wait_for_condition">wait_for_condition</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_for_status" href="#ocp_resources.resource.Resource.wait_for_status">wait_for_status</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ocp_resources.resource.Resource"><code class="flex name class">
<span>class <span class="ident">Resource</span></span>
<span>(</span><span>name, client=None, teardown=True, timeout=240, privileged_client=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for API resources</p>
<p>Create a API resource</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Resource name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Resource(object):
    &#34;&#34;&#34;
    Base class for API resources
    &#34;&#34;&#34;

    api_group = None
    api_version = None
    singular_name = None

    class Status:
        SUCCEEDED = &#34;Succeeded&#34;
        FAILED = &#34;Failed&#34;
        DELETING = &#34;Deleting&#34;
        DEPLOYED = &#34;Deployed&#34;
        PENDING = &#34;Pending&#34;
        COMPLETED = &#34;Completed&#34;

    class Condition:
        UPGRADEABLE = &#34;Upgradeable&#34;
        AVAILABLE = &#34;Available&#34;
        DEGRADED = &#34;Degraded&#34;
        PROGRESSING = &#34;Progressing&#34;
        CREATED = &#34;Created&#34;
        RECONCILE_COMPLETE = &#34;ReconcileComplete&#34;
        READY = &#34;Ready&#34;

        class Status:
            TRUE = &#34;True&#34;
            FALSE = &#34;False&#34;
            UNKNOWN = &#34;Unknown&#34;

        class Phase:
            INSTALL_READY = &#34;InstallReady&#34;
            SUCCEEDED = &#34;Succeeded&#34;

        class Reason:
            ALL_REQUIREMENTS_MET = &#34;AllRequirementsMet&#34;
            INSTALL_SUCCEEDED = &#34;InstallSucceeded&#34;

    class Interface:
        class State:
            UP = &#34;up&#34;
            DOWN = &#34;down&#34;
            ABSENT = &#34;absent&#34;

    class ApiGroup:
        ADMISSIONREGISTRATION_K8S_IO = &#34;admissionregistration.k8s.io&#34;
        APIEXTENSIONS_K8S_IO = &#34;apiextensions.k8s.io&#34;
        APIREGISTRATION_K8S_IO = &#34;apiregistration.k8s.io&#34;
        APPS = &#34;apps&#34;
        CDI_KUBEVIRT_IO = &#34;cdi.kubevirt.io&#34;
        CONFIG_OPENSHIFT_IO = &#34;config.openshift.io&#34;
        CONSOLE_OPENSHIFT_IO = &#34;console.openshift.io&#34;
        FORKLIFT_KONVEYOR_IO = &#34;forklift.konveyor.io&#34;
        HCO_KUBEVIRT_IO = &#34;hco.kubevirt.io&#34;
        HOSTPATHPROVISIONER_KUBEVIRT_IO = &#34;hostpathprovisioner.kubevirt.io&#34;
        IMAGE_OPENSHIFT_IO = &#34;image.openshift.io&#34;
        K8S_CNI_CNCF_IO = &#34;k8s.cni.cncf.io&#34;
        K8S_V1_CNI_CNCF_IO = &#34;k8s.v1.cni.cncf.io&#34;
        KUBERNETES_IO = &#34;kubernetes.io&#34;
        KUBEVIRT_IO = &#34;kubevirt.io&#34;
        KUBEVIRT_KUBEVIRT_IO = &#34;kubevirt.kubevirt.io&#34;
        LITMUS_IO = &#34;litmuschaos.io&#34;
        MACHINE_OPENSHIFT_IO = &#34;machine.openshift.io&#34;
        MACHINECONFIGURATION_OPENSHIFT_IO = &#34;machineconfiguration.openshift.io&#34;
        MONITORING_COREOS_COM = &#34;monitoring.coreos.com&#34;
        NETWORKADDONSOPERATOR_NETWORK_KUBEVIRT_IO = (
            &#34;networkaddonsoperator.network.kubevirt.io&#34;
        )
        NETWORKING_K8S_IO = &#34;networking.k8s.io&#34;
        NMSTATE_IO = &#34;nmstate.io&#34;
        NODEMAINTENANCE_KUBEVIRT_IO = &#34;nodemaintenance.kubevirt.io&#34;
        OPERATOR_OPENSHIFT_IO = &#34;operator.openshift.io&#34;
        OPERATORS_COREOS_COM = &#34;operators.coreos.com&#34;
        OS_TEMPLATE_KUBEVIRT_IO = &#34;os.template.kubevirt.io&#34;
        PACKAGES_OPERATORS_COREOS_COM = &#34;packages.operators.coreos.com&#34;
        PROJECT_OPENSHIFT_IO = &#34;project.openshift.io&#34;
        RBAC_AUTHORIZATION_K8S_IO = &#34;rbac.authorization.k8s.io&#34;
        RIPSAW_CLOUDBULLDOZER_IO = &#34;ripsaw.cloudbulldozer.io&#34;
        ROUTE_OPENSHIFT_IO = &#34;route.openshift.io&#34;
        SCHEDULING_K8S_IO = &#34;scheduling.k8s.io&#34;
        SECURITY_OPENSHIFT_IO = &#34;security.openshift.io&#34;
        SNAPSHOT_STORAGE_K8S_IO = &#34;snapshot.storage.k8s.io&#34;
        SNAPSHOT_KUBEVIRT_IO = &#34;snapshot.kubevirt.io&#34;
        SRIOVNETWORK_OPENSHIFT_IO = &#34;sriovnetwork.openshift.io&#34;
        SSP_KUBEVIRT_IO = &#34;ssp.kubevirt.io&#34;
        STORAGE_K8S_IO = &#34;storage.k8s.io&#34;
        STORAGECLASS_KUBERNETES_IO = &#34;storageclass.kubernetes.io&#34;
        TEMPLATE_KUBEVIRT_IO = &#34;template.kubevirt.io&#34;
        TEMPLATE_OPENSHIFT_IO = &#34;template.openshift.io&#34;
        UPLOAD_CDI_KUBEVIRT_IO = &#34;upload.cdi.kubevirt.io&#34;
        V2V_KUBEVIRT_IO = &#34;v2v.kubevirt.io&#34;

    class ApiVersion:
        V1 = &#34;v1&#34;
        V1BETA1 = &#34;v1beta1&#34;
        V1ALPHA1 = &#34;v1alpha1&#34;

    def __init__(
        self, name, client=None, teardown=True, timeout=TIMEOUT, privileged_client=None
    ):
        &#34;&#34;&#34;
        Create a API resource

        Args:
            name (str): Resource name
        &#34;&#34;&#34;
        if not self.api_group and not self.api_version:
            raise NotImplementedError(
                &#34;Subclasses of Resource require self.api_group or self.api_version to be defined&#34;
            )
        self.namespace = None
        self.name = name
        self.client = client
        self.privileged_client = privileged_client
        if not self.client:
            try:
                self.client = DynamicClient(
                    client=kubernetes.config.new_client_from_config()
                )
            except (
                kubernetes.config.ConfigException,
                urllib3.exceptions.MaxRetryError,
            ):
                LOGGER.error(
                    &#34;You need to be logged into a cluster or have $KUBECONFIG env configured&#34;
                )
                raise
        if not self.api_version:
            self.api_version = _get_api_version(
                dyn_client=self.client, api_group=self.api_group, kind=self.kind
            )

        self.teardown = teardown
        self.timeout = timeout

    @classproperty
    def kind(cls):  # noqa: N805
        return sub_resource_level(cls, NamespacedResource, Resource)

    def _base_body(self):
        return {
            &#34;apiVersion&#34;: self.api_version,
            &#34;kind&#34;: self.kind,
            &#34;metadata&#34;: {&#34;name&#34;: self.name},
        }

    def to_dict(self):
        &#34;&#34;&#34;
        Generate intended dict representation of the resource.
        &#34;&#34;&#34;
        return self._base_body()

    def __enter__(self):
        return self.deploy()

    def __exit__(self, exception_type, exception_value, traceback):
        if self.teardown:
            self.clean_up()

    def deploy(self):
        self.create()
        return self

    def clean_up(self):
        if os.environ.get(&#34;CNV_TEST_COLLECT_LOGS&#34;, &#34;0&#34;) == &#34;1&#34;:
            try:
                _collect_data(resource_object=self)
            except Exception as exception_:
                LOGGER.warning(exception_)

        data = self.to_dict()
        LOGGER.info(f&#34;Deleting {data}&#34;)
        self.delete(wait=True, timeout=self.timeout)

    @classmethod
    def _prepare_resources(cls, dyn_client, singular_name, *args, **kwargs):
        if not cls.api_version:
            cls.api_version = _get_api_version(
                dyn_client=dyn_client, api_group=cls.api_group, kind=cls.kind
            )

        get_kwargs = {&#34;singular_name&#34;: singular_name} if singular_name else {}
        return dyn_client.resources.get(
            kind=cls.kind, api_version=cls.api_version, **get_kwargs
        ).get(*args, **kwargs)

    def api(self, **kwargs):
        &#34;&#34;&#34;
        Get resource API

        Keyword Args:
            pretty
            _continue
            include_uninitialized
            field_selector
            label_selector
            limit
            resource_version
            timeout_seconds
            watch
            async_req

        Returns:
            Resource: Resource object.
        &#34;&#34;&#34;
        if self.singular_name:
            kwargs[&#34;singular_name&#34;] = self.singular_name
        return self.client.resources.get(
            api_version=self.api_version, kind=self.kind, **kwargs
        )

    def wait(self, timeout=TIMEOUT, sleep=1):
        &#34;&#34;&#34;
        Wait for resource

        Args:
            timeout (int): Time to wait for the resource.
            sleep (int): Time to wait between retries

        Raises:
            TimeoutExpiredError: If resource not exists.
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Wait until {self.kind} {self.name} is created&#34;)
        samples = TimeoutSampler(
            wait_timeout=timeout,
            sleep=sleep,
            exceptions=(ProtocolError, NotFoundError),
            func=lambda: self.exists,
        )
        for sample in samples:
            if sample:
                return

    def wait_deleted(self, timeout=TIMEOUT):
        &#34;&#34;&#34;
        Wait until resource is deleted

        Args:
            timeout (int): Time to wait for the resource.

        Raises:
            TimeoutExpiredError: If resource still exists.
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Wait until {self.kind} {self.name} is deleted&#34;)
        return self.client_wait_deleted(timeout=timeout)

    @property
    def exists(self):
        &#34;&#34;&#34;
        Whether self exists on the server
        &#34;&#34;&#34;
        try:
            return self.instance
        except NotFoundError:
            return None

    def client_wait_deleted(self, timeout):
        &#34;&#34;&#34;
        client-side Wait until resource is deleted

        Args:
            timeout (int): Time to wait for the resource.

        Raises:
            TimeoutExpiredError: If resource still exists.
        &#34;&#34;&#34;
        samples = TimeoutSampler(
            wait_timeout=timeout, sleep=1, func=lambda: self.exists
        )
        for sample in samples:
            if not sample:
                return

    def wait_for_status(self, status, timeout=TIMEOUT, stop_status=None, sleep=1):
        &#34;&#34;&#34;
        Wait for resource to be in status

        Args:
            status (str): Expected status.
            timeout (int): Time to wait for the resource.
            stop_status (str): Status which should stop the wait and failed.

        Raises:
            TimeoutExpiredError: If resource in not in desire status.
        &#34;&#34;&#34;
        stop_status = stop_status if stop_status else self.Status.FAILED
        LOGGER.info(f&#34;Wait for {self.kind} {self.name} status to be {status}&#34;)
        samples = TimeoutSampler(
            wait_timeout=timeout,
            sleep=sleep,
            exceptions=ProtocolError,
            func=self.api().get,
            field_selector=f&#34;metadata.name=={self.name}&#34;,
            namespace=self.namespace,
        )
        current_status = None
        try:
            for sample in samples:
                if sample.items:
                    sample_status = sample.items[0].status
                    if sample_status:
                        current_status = sample_status.phase
                        if current_status == status:
                            return

                        if current_status == stop_status:
                            raise TimeoutExpiredError(
                                f&#34;Status of {self.kind} {self.name} is {current_status}&#34;
                            )

        except TimeoutExpiredError:
            if current_status:
                LOGGER.error(f&#34;Status of {self.kind} {self.name} is {current_status}&#34;)
            raise

    def create(self, body=None, wait=False):
        &#34;&#34;&#34;
        Create resource.

        Args:
            body (dict): Resource data to create.
            wait (bool) : True to wait for resource status.

        Returns:
            bool: True if create succeeded, False otherwise.

        Raises:
            ValueMismatch: When body value doesn&#39;t match class value
        &#34;&#34;&#34;
        data = self.to_dict()
        if body:
            kind = body[&#34;kind&#34;]
            name = body.get(&#34;name&#34;)
            api_version = body[&#34;apiVersion&#34;]
            if kind != self.kind:
                ValueMismatch(f&#34;{kind} != {self.kind}&#34;)
            if name and name != self.name:
                ValueMismatch(f&#34;{name} != {self.name}&#34;)
            if api_version != self.api_version:
                ValueMismatch(f&#34;{api_version} != {self.api_version}&#34;)

            data.update(body)

        LOGGER.info(f&#34;Posting {data}&#34;)
        LOGGER.info(f&#34;Create {self.kind} {self.name}&#34;)
        res = self.api().create(body=data, namespace=self.namespace)
        if wait and res:
            return self.wait()
        return res

    def delete(self, wait=False, timeout=TIMEOUT):
        resource_list = self.api()
        try:
            res = resource_list.delete(name=self.name, namespace=self.namespace)
        except NotFoundError:
            return False

        LOGGER.info(f&#34;Delete {self.kind} {self.name}&#34;)
        if wait and res:
            return self.wait_deleted(timeout=timeout)
        return res

    @property
    def status(self):
        &#34;&#34;&#34;
        Get resource status

        Status: Running, Scheduling, Pending, Unknown, CrashLoopBackOff

        Returns:
           str: Status
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Get {self.kind} {self.name} status&#34;)
        return self.instance.status.phase

    def update(self, resource_dict):
        &#34;&#34;&#34;
        Update resource with resource dict

        Args:
            resource_dict: Resource dictionary
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Update {self.kind} {self.name}: {resource_dict}&#34;)
        self.api().patch(
            body=resource_dict,
            namespace=self.namespace,
            content_type=&#34;application/merge-patch+json&#34;,
        )

    def update_replace(self, resource_dict):
        &#34;&#34;&#34;
        Replace resource metadata.
        Use this to remove existing field. (update() will only update existing fields)
        &#34;&#34;&#34;
        LOGGER.info(f&#34;Replace {self.kind} {self.name}: {resource_dict}&#34;)
        self.api().replace(body=resource_dict, name=self.name, namespace=self.namespace)

    @staticmethod
    def _retry_etcd_changed(func):
        sampler = TimeoutSampler(
            wait_timeout=10,
            sleep=1,
            func=func,
            exceptions=InternalServerError,
            exceptions_msg=&#34;etcdserver: leader changed&#34;,
            print_log=False,
        )
        for sample in sampler:
            return sample

    @classmethod
    def get(cls, dyn_client, singular_name=None, *args, **kwargs):
        &#34;&#34;&#34;
        Get resources

        Args:
            dyn_client (DynamicClient): Open connection to remote cluster
            singular_name (str): Resource kind (in lowercase), in use where we have multiple matches for resource

        Returns:
            generator: Generator of Resources of cls.kind
        &#34;&#34;&#34;

        def _get():
            _resources = cls._prepare_resources(
                dyn_client=dyn_client, singular_name=singular_name, *args, **kwargs
            )
            try:
                for resource_field in _resources.items:
                    yield cls(client=dyn_client, name=resource_field.metadata.name)
            except TypeError:
                yield cls(client=dyn_client, name=_resources.metadata.name)

        return Resource._retry_etcd_changed(func=_get)

    @property
    def instance(self):
        &#34;&#34;&#34;
        Get resource instance

        Returns:
            openshift.dynamic.client.ResourceInstance
        &#34;&#34;&#34;

        def _instance():
            return self.api().get(name=self.name)

        return self._retry_etcd_changed(func=_instance)

    @property
    def labels(self):
        &#34;&#34;&#34;
        Method to get dict of labels for this resource

        Returns:
           labels(dict): dict labels
        &#34;&#34;&#34;
        return self.instance[&#34;metadata&#34;][&#34;labels&#34;]

    def wait_for_condition(self, condition, status, timeout=300):
        &#34;&#34;&#34;
        Wait for Pod condition to be in desire status.

        Args:
            condition (str): Condition to query.
            status (str): Expected condition status.
            timeout (int): Time to wait for the resource.

        Raises:
            TimeoutExpiredError: If Pod condition in not in desire status.
        &#34;&#34;&#34;
        LOGGER.info(
            f&#34;Wait for {self.kind}/{self.name}&#39;s &#39;{condition}&#39; condition to be &#39;{status}&#39;&#34;
        )
        samples = TimeoutSampler(
            wait_timeout=timeout,
            sleep=1,
            exceptions=ProtocolError,
            func=self.api().get,
            field_selector=f&#34;metadata.name=={self.name}&#34;,
            namespace=self.namespace,
        )
        for sample in samples:
            if (
                sample.items
                and sample.items[0].get(&#34;status&#34;)
                and sample.items[0].status.get(&#34;conditions&#34;)
            ):
                sample_conditions = sample.items[0].status.conditions
                if sample_conditions:
                    for cond in sample_conditions:
                        if cond.type == condition and cond.status == status:
                            return

    def api_request(self, method, action, url, **params):
        &#34;&#34;&#34;
        Handle API requests to resource.

        Args:
            method (str): Request method (GET/PUT etc.).
            action (str): Action to perform (stop/start/guestosinfo etc.).
            url (str): URL of resource.

        Returns:
           data(dict): response data

        &#34;&#34;&#34;
        client = self.privileged_client or self.client
        response = client.client.request(
            method=method,
            url=f&#34;{url}/{action}&#34;,
            headers=self.client.configuration.api_key,
            **params,
        )

        try:
            return json.loads(response.data)
        except json.decoder.JSONDecodeError:
            return response.data

    def wait_for_conditions(self):
        samples = TimeoutSampler(
            wait_timeout=30, sleep=1, func=lambda: self.instance.status.conditions
        )
        for sample in samples:
            if sample:
                return</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ocp_resources.api_service.APIService" href="api_service.html#ocp_resources.api_service.APIService">APIService</a></li>
<li><a title="ocp_resources.cdi_config.CDIConfig" href="cdi_config.html#ocp_resources.cdi_config.CDIConfig">CDIConfig</a></li>
<li><a title="ocp_resources.cluster_operator.ClusterOperator" href="cluster_operator.html#ocp_resources.cluster_operator.ClusterOperator">ClusterOperator</a></li>
<li><a title="ocp_resources.cluster_role.ClusterRole" href="cluster_role.html#ocp_resources.cluster_role.ClusterRole">ClusterRole</a></li>
<li><a title="ocp_resources.cluster_role_binding.ClusterRoleBinding" href="cluster_role_binding.html#ocp_resources.cluster_role_binding.ClusterRoleBinding">ClusterRoleBinding</a></li>
<li><a title="ocp_resources.cluster_version.ClusterVersion" href="cluster_version.html#ocp_resources.cluster_version.ClusterVersion">ClusterVersion</a></li>
<li><a title="ocp_resources.console_cli_download.ConsoleCLIDownload" href="console_cli_download.html#ocp_resources.console_cli_download.ConsoleCLIDownload">ConsoleCLIDownload</a></li>
<li><a title="ocp_resources.console_quick_starts.ConsoleQuickStart" href="console_quick_starts.html#ocp_resources.console_quick_starts.ConsoleQuickStart">ConsoleQuickStart</a></li>
<li><a title="ocp_resources.custom_resource_definition.CustomResourceDefinition" href="custom_resource_definition.html#ocp_resources.custom_resource_definition.CustomResourceDefinition">CustomResourceDefinition</a></li>
<li><a title="ocp_resources.hostpath_provisioner.HostPathProvisioner" href="hostpath_provisioner.html#ocp_resources.hostpath_provisioner.HostPathProvisioner">HostPathProvisioner</a></li>
<li><a title="ocp_resources.image_content_source_policy.ImageContentSourcePolicy" href="image_content_source_policy.html#ocp_resources.image_content_source_policy.ImageContentSourcePolicy">ImageContentSourcePolicy</a></li>
<li><a title="ocp_resources.machine_config_pool.MachineConfigPool" href="machine_config_pool.html#ocp_resources.machine_config_pool.MachineConfigPool">MachineConfigPool</a></li>
<li><a title="ocp_resources.mutating_webhook_config.MutatingWebhookConfiguration" href="mutating_webhook_config.html#ocp_resources.mutating_webhook_config.MutatingWebhookConfiguration">MutatingWebhookConfiguration</a></li>
<li><a title="ocp_resources.namespace.Namespace" href="namespace.html#ocp_resources.namespace.Namespace">Namespace</a></li>
<li><a title="ocp_resources.network.Network" href="network.html#ocp_resources.network.Network">Network</a></li>
<li><a title="ocp_resources.network_addons_config.NetworkAddonsConfig" href="network_addons_config.html#ocp_resources.network_addons_config.NetworkAddonsConfig">NetworkAddonsConfig</a></li>
<li><a title="ocp_resources.node.Node" href="node.html#ocp_resources.node.Node">Node</a></li>
<li><a title="ocp_resources.node_maintenance.NodeMaintenance" href="node_maintenance.html#ocp_resources.node_maintenance.NodeMaintenance">NodeMaintenance</a></li>
<li><a title="ocp_resources.node_network_configuration_enactment.NodeNetworkConfigurationEnactment" href="node_network_configuration_enactment.html#ocp_resources.node_network_configuration_enactment.NodeNetworkConfigurationEnactment">NodeNetworkConfigurationEnactment</a></li>
<li><a title="ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy" href="node_network_configuration_policy.html#ocp_resources.node_network_configuration_policy.NodeNetworkConfigurationPolicy">NodeNetworkConfigurationPolicy</a></li>
<li><a title="ocp_resources.node_network_state.NodeNetworkState" href="node_network_state.html#ocp_resources.node_network_state.NodeNetworkState">NodeNetworkState</a></li>
<li><a title="ocp_resources.oauth.OAuth" href="oauth.html#ocp_resources.oauth.OAuth">OAuth</a></li>
<li><a title="ocp_resources.operator_hub.OperatorHub" href="operator_hub.html#ocp_resources.operator_hub.OperatorHub">OperatorHub</a></li>
<li><a title="ocp_resources.persistent_volume.PersistentVolume" href="persistent_volume.html#ocp_resources.persistent_volume.PersistentVolume">PersistentVolume</a></li>
<li><a title="ocp_resources.priority_class.PriorityClass" href="priority_class.html#ocp_resources.priority_class.PriorityClass">PriorityClass</a></li>
<li><a title="ocp_resources.project.Project" href="project.html#ocp_resources.project.Project">Project</a></li>
<li><a title="ocp_resources.project.ProjectRequest" href="project.html#ocp_resources.project.ProjectRequest">ProjectRequest</a></li>
<li><a title="ocp_resources.prometheus_rule.PrometheusRule" href="prometheus_rule.html#ocp_resources.prometheus_rule.PrometheusRule">PrometheusRule</a></li>
<li><a title="ocp_resources.resource.NamespacedResource" href="#ocp_resources.resource.NamespacedResource">NamespacedResource</a></li>
<li><a title="ocp_resources.security_context_constraints.SecurityContextConstraints" href="security_context_constraints.html#ocp_resources.security_context_constraints.SecurityContextConstraints">SecurityContextConstraints</a></li>
<li><a title="ocp_resources.service_monitor.ServiceMonitor" href="service_monitor.html#ocp_resources.service_monitor.ServiceMonitor">ServiceMonitor</a></li>
<li><a title="ocp_resources.storage_class.StorageClass" href="storage_class.html#ocp_resources.storage_class.StorageClass">StorageClass</a></li>
<li><a title="ocp_resources.validating_webhook_config.ValidatingWebhookConfiguration" href="validating_webhook_config.html#ocp_resources.validating_webhook_config.ValidatingWebhookConfiguration">ValidatingWebhookConfiguration</a></li>
<li><a title="ocp_resources.virtual_machine_import_configs.VMImportConfig" href="virtual_machine_import_configs.html#ocp_resources.virtual_machine_import_configs.VMImportConfig">VMImportConfig</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ocp_resources.resource.Resource.ApiGroup"><code class="name">var <span class="ident">ApiGroup</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.resource.Resource.ApiVersion"><code class="name">var <span class="ident">ApiVersion</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.resource.Resource.Condition"><code class="name">var <span class="ident">Condition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.resource.Resource.Interface"><code class="name">var <span class="ident">Interface</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.resource.Resource.Status"><code class="name">var <span class="ident">Status</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.resource.Resource.api_group"><code class="name">var <span class="ident">api_group</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.resource.Resource.api_version"><code class="name">var <span class="ident">api_version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.resource.Resource.kind"><code class="name">var <span class="ident">kind</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocp_resources.resource.Resource.singular_name"><code class="name">var <span class="ident">singular_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="ocp_resources.resource.Resource.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>dyn_client, singular_name=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get resources</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dyn_client</code></strong> :&ensp;<code>DynamicClient</code></dt>
<dd>Open connection to remote cluster</dd>
<dt><strong><code>singular_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Resource kind (in lowercase), in use where we have multiple matches for resource</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>generator</code></dt>
<dd>Generator of Resources of cls.kind</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get(cls, dyn_client, singular_name=None, *args, **kwargs):
    &#34;&#34;&#34;
    Get resources

    Args:
        dyn_client (DynamicClient): Open connection to remote cluster
        singular_name (str): Resource kind (in lowercase), in use where we have multiple matches for resource

    Returns:
        generator: Generator of Resources of cls.kind
    &#34;&#34;&#34;

    def _get():
        _resources = cls._prepare_resources(
            dyn_client=dyn_client, singular_name=singular_name, *args, **kwargs
        )
        try:
            for resource_field in _resources.items:
                yield cls(client=dyn_client, name=resource_field.metadata.name)
        except TypeError:
            yield cls(client=dyn_client, name=_resources.metadata.name)

    return Resource._retry_etcd_changed(func=_get)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ocp_resources.resource.Resource.exists"><code class="name">var <span class="ident">exists</span></code></dt>
<dd>
<div class="desc"><p>Whether self exists on the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exists(self):
    &#34;&#34;&#34;
    Whether self exists on the server
    &#34;&#34;&#34;
    try:
        return self.instance
    except NotFoundError:
        return None</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.instance"><code class="name">var <span class="ident">instance</span></code></dt>
<dd>
<div class="desc"><p>Get resource instance</p>
<h2 id="returns">Returns</h2>
<p>openshift.dynamic.client.ResourceInstance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def instance(self):
    &#34;&#34;&#34;
    Get resource instance

    Returns:
        openshift.dynamic.client.ResourceInstance
    &#34;&#34;&#34;

    def _instance():
        return self.api().get(name=self.name)

    return self._retry_etcd_changed(func=_instance)</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.labels"><code class="name">var <span class="ident">labels</span></code></dt>
<dd>
<div class="desc"><p>Method to get dict of labels for this resource</p>
<h2 id="returns">Returns</h2>
<p>labels(dict): dict labels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def labels(self):
    &#34;&#34;&#34;
    Method to get dict of labels for this resource

    Returns:
       labels(dict): dict labels
    &#34;&#34;&#34;
    return self.instance[&#34;metadata&#34;][&#34;labels&#34;]</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"><p>Get resource status</p>
<p>Status: Running, Scheduling, Pending, Unknown, CrashLoopBackOff</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Status</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self):
    &#34;&#34;&#34;
    Get resource status

    Status: Running, Scheduling, Pending, Unknown, CrashLoopBackOff

    Returns:
       str: Status
    &#34;&#34;&#34;
    LOGGER.info(f&#34;Get {self.kind} {self.name} status&#34;)
    return self.instance.status.phase</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocp_resources.resource.Resource.api"><code class="name flex">
<span>def <span class="ident">api</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get resource API</p>
<p>Keyword Args:
pretty
_continue
include_uninitialized
field_selector
label_selector
limit
resource_version
timeout_seconds
watch
async_req</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ocp_resources.resource.Resource" href="#ocp_resources.resource.Resource">Resource</a></code></dt>
<dd>Resource object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def api(self, **kwargs):
    &#34;&#34;&#34;
    Get resource API

    Keyword Args:
        pretty
        _continue
        include_uninitialized
        field_selector
        label_selector
        limit
        resource_version
        timeout_seconds
        watch
        async_req

    Returns:
        Resource: Resource object.
    &#34;&#34;&#34;
    if self.singular_name:
        kwargs[&#34;singular_name&#34;] = self.singular_name
    return self.client.resources.get(
        api_version=self.api_version, kind=self.kind, **kwargs
    )</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.api_request"><code class="name flex">
<span>def <span class="ident">api_request</span></span>(<span>self, method, action, url, **params)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle API requests to resource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>Request method (GET/PUT etc.).</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Action to perform (stop/start/guestosinfo etc.).</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL of resource.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>data(dict): response data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def api_request(self, method, action, url, **params):
    &#34;&#34;&#34;
    Handle API requests to resource.

    Args:
        method (str): Request method (GET/PUT etc.).
        action (str): Action to perform (stop/start/guestosinfo etc.).
        url (str): URL of resource.

    Returns:
       data(dict): response data

    &#34;&#34;&#34;
    client = self.privileged_client or self.client
    response = client.client.request(
        method=method,
        url=f&#34;{url}/{action}&#34;,
        headers=self.client.configuration.api_key,
        **params,
    )

    try:
        return json.loads(response.data)
    except json.decoder.JSONDecodeError:
        return response.data</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.clean_up"><code class="name flex">
<span>def <span class="ident">clean_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up(self):
    if os.environ.get(&#34;CNV_TEST_COLLECT_LOGS&#34;, &#34;0&#34;) == &#34;1&#34;:
        try:
            _collect_data(resource_object=self)
        except Exception as exception_:
            LOGGER.warning(exception_)

    data = self.to_dict()
    LOGGER.info(f&#34;Deleting {data}&#34;)
    self.delete(wait=True, timeout=self.timeout)</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.client_wait_deleted"><code class="name flex">
<span>def <span class="ident">client_wait_deleted</span></span>(<span>self, timeout)</span>
</code></dt>
<dd>
<div class="desc"><p>client-side Wait until resource is deleted</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Time to wait for the resource.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TimeoutExpiredError</code></dt>
<dd>If resource still exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def client_wait_deleted(self, timeout):
    &#34;&#34;&#34;
    client-side Wait until resource is deleted

    Args:
        timeout (int): Time to wait for the resource.

    Raises:
        TimeoutExpiredError: If resource still exists.
    &#34;&#34;&#34;
    samples = TimeoutSampler(
        wait_timeout=timeout, sleep=1, func=lambda: self.exists
    )
    for sample in samples:
        if not sample:
            return</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, body=None, wait=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create resource.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>body</code></strong> :&ensp;<code>dict</code></dt>
<dd>Resource data to create.</dd>
</dl>
<p>wait (bool) : True to wait for resource status.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if create succeeded, False otherwise.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="ocp_resources.resource.ValueMismatch" href="#ocp_resources.resource.ValueMismatch">ValueMismatch</a></code></dt>
<dd>When body value doesn't match class value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, body=None, wait=False):
    &#34;&#34;&#34;
    Create resource.

    Args:
        body (dict): Resource data to create.
        wait (bool) : True to wait for resource status.

    Returns:
        bool: True if create succeeded, False otherwise.

    Raises:
        ValueMismatch: When body value doesn&#39;t match class value
    &#34;&#34;&#34;
    data = self.to_dict()
    if body:
        kind = body[&#34;kind&#34;]
        name = body.get(&#34;name&#34;)
        api_version = body[&#34;apiVersion&#34;]
        if kind != self.kind:
            ValueMismatch(f&#34;{kind} != {self.kind}&#34;)
        if name and name != self.name:
            ValueMismatch(f&#34;{name} != {self.name}&#34;)
        if api_version != self.api_version:
            ValueMismatch(f&#34;{api_version} != {self.api_version}&#34;)

        data.update(body)

    LOGGER.info(f&#34;Posting {data}&#34;)
    LOGGER.info(f&#34;Create {self.kind} {self.name}&#34;)
    res = self.api().create(body=data, namespace=self.namespace)
    if wait and res:
        return self.wait()
    return res</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, wait=False, timeout=240)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, wait=False, timeout=TIMEOUT):
    resource_list = self.api()
    try:
        res = resource_list.delete(name=self.name, namespace=self.namespace)
    except NotFoundError:
        return False

    LOGGER.info(f&#34;Delete {self.kind} {self.name}&#34;)
    if wait and res:
        return self.wait_deleted(timeout=timeout)
    return res</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.deploy"><code class="name flex">
<span>def <span class="ident">deploy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deploy(self):
    self.create()
    return self</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate intended dict representation of the resource.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#34;&#34;&#34;
    Generate intended dict representation of the resource.
    &#34;&#34;&#34;
    return self._base_body()</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, resource_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Update resource with resource dict</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource_dict</code></strong></dt>
<dd>Resource dictionary</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, resource_dict):
    &#34;&#34;&#34;
    Update resource with resource dict

    Args:
        resource_dict: Resource dictionary
    &#34;&#34;&#34;
    LOGGER.info(f&#34;Update {self.kind} {self.name}: {resource_dict}&#34;)
    self.api().patch(
        body=resource_dict,
        namespace=self.namespace,
        content_type=&#34;application/merge-patch+json&#34;,
    )</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.update_replace"><code class="name flex">
<span>def <span class="ident">update_replace</span></span>(<span>self, resource_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace resource metadata.
Use this to remove existing field. (update() will only update existing fields)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_replace(self, resource_dict):
    &#34;&#34;&#34;
    Replace resource metadata.
    Use this to remove existing field. (update() will only update existing fields)
    &#34;&#34;&#34;
    LOGGER.info(f&#34;Replace {self.kind} {self.name}: {resource_dict}&#34;)
    self.api().replace(body=resource_dict, name=self.name, namespace=self.namespace)</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, timeout=240, sleep=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for resource</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Time to wait for the resource.</dd>
<dt><strong><code>sleep</code></strong> :&ensp;<code>int</code></dt>
<dd>Time to wait between retries</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TimeoutExpiredError</code></dt>
<dd>If resource not exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self, timeout=TIMEOUT, sleep=1):
    &#34;&#34;&#34;
    Wait for resource

    Args:
        timeout (int): Time to wait for the resource.
        sleep (int): Time to wait between retries

    Raises:
        TimeoutExpiredError: If resource not exists.
    &#34;&#34;&#34;
    LOGGER.info(f&#34;Wait until {self.kind} {self.name} is created&#34;)
    samples = TimeoutSampler(
        wait_timeout=timeout,
        sleep=sleep,
        exceptions=(ProtocolError, NotFoundError),
        func=lambda: self.exists,
    )
    for sample in samples:
        if sample:
            return</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.wait_deleted"><code class="name flex">
<span>def <span class="ident">wait_deleted</span></span>(<span>self, timeout=240)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait until resource is deleted</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Time to wait for the resource.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TimeoutExpiredError</code></dt>
<dd>If resource still exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_deleted(self, timeout=TIMEOUT):
    &#34;&#34;&#34;
    Wait until resource is deleted

    Args:
        timeout (int): Time to wait for the resource.

    Raises:
        TimeoutExpiredError: If resource still exists.
    &#34;&#34;&#34;
    LOGGER.info(f&#34;Wait until {self.kind} {self.name} is deleted&#34;)
    return self.client_wait_deleted(timeout=timeout)</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.wait_for_condition"><code class="name flex">
<span>def <span class="ident">wait_for_condition</span></span>(<span>self, condition, status, timeout=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for Pod condition to be in desire status.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong> :&ensp;<code>str</code></dt>
<dd>Condition to query.</dd>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code></dt>
<dd>Expected condition status.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Time to wait for the resource.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TimeoutExpiredError</code></dt>
<dd>If Pod condition in not in desire status.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_condition(self, condition, status, timeout=300):
    &#34;&#34;&#34;
    Wait for Pod condition to be in desire status.

    Args:
        condition (str): Condition to query.
        status (str): Expected condition status.
        timeout (int): Time to wait for the resource.

    Raises:
        TimeoutExpiredError: If Pod condition in not in desire status.
    &#34;&#34;&#34;
    LOGGER.info(
        f&#34;Wait for {self.kind}/{self.name}&#39;s &#39;{condition}&#39; condition to be &#39;{status}&#39;&#34;
    )
    samples = TimeoutSampler(
        wait_timeout=timeout,
        sleep=1,
        exceptions=ProtocolError,
        func=self.api().get,
        field_selector=f&#34;metadata.name=={self.name}&#34;,
        namespace=self.namespace,
    )
    for sample in samples:
        if (
            sample.items
            and sample.items[0].get(&#34;status&#34;)
            and sample.items[0].status.get(&#34;conditions&#34;)
        ):
            sample_conditions = sample.items[0].status.conditions
            if sample_conditions:
                for cond in sample_conditions:
                    if cond.type == condition and cond.status == status:
                        return</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.wait_for_conditions"><code class="name flex">
<span>def <span class="ident">wait_for_conditions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_conditions(self):
    samples = TimeoutSampler(
        wait_timeout=30, sleep=1, func=lambda: self.instance.status.conditions
    )
    for sample in samples:
        if sample:
            return</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.Resource.wait_for_status"><code class="name flex">
<span>def <span class="ident">wait_for_status</span></span>(<span>self, status, timeout=240, stop_status=None, sleep=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for resource to be in status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>str</code></dt>
<dd>Expected status.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>Time to wait for the resource.</dd>
<dt><strong><code>stop_status</code></strong> :&ensp;<code>str</code></dt>
<dd>Status which should stop the wait and failed.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TimeoutExpiredError</code></dt>
<dd>If resource in not in desire status.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_status(self, status, timeout=TIMEOUT, stop_status=None, sleep=1):
    &#34;&#34;&#34;
    Wait for resource to be in status

    Args:
        status (str): Expected status.
        timeout (int): Time to wait for the resource.
        stop_status (str): Status which should stop the wait and failed.

    Raises:
        TimeoutExpiredError: If resource in not in desire status.
    &#34;&#34;&#34;
    stop_status = stop_status if stop_status else self.Status.FAILED
    LOGGER.info(f&#34;Wait for {self.kind} {self.name} status to be {status}&#34;)
    samples = TimeoutSampler(
        wait_timeout=timeout,
        sleep=sleep,
        exceptions=ProtocolError,
        func=self.api().get,
        field_selector=f&#34;metadata.name=={self.name}&#34;,
        namespace=self.namespace,
    )
    current_status = None
    try:
        for sample in samples:
            if sample.items:
                sample_status = sample.items[0].status
                if sample_status:
                    current_status = sample_status.phase
                    if current_status == status:
                        return

                    if current_status == stop_status:
                        raise TimeoutExpiredError(
                            f&#34;Status of {self.kind} {self.name} is {current_status}&#34;
                        )

    except TimeoutExpiredError:
        if current_status:
            LOGGER.error(f&#34;Status of {self.kind} {self.name} is {current_status}&#34;)
        raise</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ocp_resources.resource.ResourceEditor"><code class="flex name class">
<span>class <span class="ident">ResourceEditor</span></span>
<span>(</span><span>patches, action='update', user_backups=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>patches</code></strong> :&ensp;<code>dict</code></dt>
<dd>{<Resource object>: <yaml patch as dict>}
e.g. {<Resource object>:
{'metadata': {'labels': {'label1': 'true'}}}</dd>
</dl>
<p>Allows for temporary edits to cluster resources for tests. During
<strong>enter</strong> user-specified patches (see args) are applied and old values
are backed up, and during <strong>exit</strong> these backups are used to reverse
all changes made.</p>
<p>Flow:
1) apply patches
2) automation runs
3) edits made to resources are reversed</p>
<p>May also be used without being treated as a context manager by
calling the methods update() and restore() after instantiation.</p>
<p><strong><em> the DynamicClient object used to get the resources must not be
using an unprivileged_user; use default_client or similar instead.</em></strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResourceEditor(object):
    def __init__(self, patches, action=&#34;update&#34;, user_backups=None):
        &#34;&#34;&#34;
        Args:
            patches (dict): {&lt;Resource object&gt;: &lt;yaml patch as dict&gt;}
                e.g. {&lt;Resource object&gt;:
                        {&#39;metadata&#39;: {&#39;labels&#39;: {&#39;label1&#39;: &#39;true&#39;}}}

        Allows for temporary edits to cluster resources for tests. During
        __enter__ user-specified patches (see args) are applied and old values
        are backed up, and during __exit__ these backups are used to reverse
        all changes made.

        Flow:
        1) apply patches
        2) automation runs
        3) edits made to resources are reversed

        May also be used without being treated as a context manager by
        calling the methods update() and restore() after instantiation.

        *** the DynamicClient object used to get the resources must not be
         using an unprivileged_user; use default_client or similar instead.***
        &#34;&#34;&#34;

        self._patches = patches
        self.action = action
        self.user_backups = user_backups
        self._backups = {}

    @property
    def backups(self):
        &#34;&#34;&#34;Returns a dict {&lt;Resource object&gt;: &lt;backup_as_dict&gt;}
        The backup dict kept for each resource edited&#34;&#34;&#34;
        return self._backups

    @property
    def patches(self):
        &#34;&#34;&#34;Returns the patches dict provided in the constructor&#34;&#34;&#34;
        return self._patches

    def update(self, backup_resources=False):
        &#34;&#34;&#34;Prepares backup dicts (where necessary) and applies patches&#34;&#34;&#34;
        # prepare update dicts and backups
        resource_to_patch = []
        if backup_resources:
            LOGGER.info(&#34;ResourceEdit: Backing up old data&#34;)
            if self.user_backups:
                resource_to_patch = self._patches
                self._backups = self.user_backups

            else:
                for resource, update in self._patches.items():
                    namespace = None
                    # prepare backup
                    try:
                        original_resource_dict = resource.instance.to_dict()
                    except NotFoundError:
                        # Some resource cannot be found by name.
                        # happens in &#39;ServiceMonitor&#39; resource.
                        original_resource_dict = list(
                            resource.get(
                                dyn_client=resource.client,
                                field_selector=f&#34;metadata.name={resource.name}&#34;,
                            )
                        )[0].to_dict()
                        namespace = update.get(&#34;metadata&#34;, {}).get(&#34;namespace&#34;)

                    backup = self._create_backup(
                        original=original_resource_dict, patch=update
                    )
                    if namespace:
                        # Add namespace to metadata for restore.
                        backup[&#34;metadata&#34;][&#34;namespace&#34;] = namespace

                    # no need to back up if no changes have been made
                    # if action is &#39;replace&#39; we need to update even if no backup (replace update can be empty )
                    if backup or self.action == &#34;replace&#34;:
                        resource_to_patch.append(resource)
                        self._backups[resource] = backup
                    else:
                        LOGGER.warning(
                            f&#34;ResourceEdit: no diff found in patch for &#34;
                            f&#34;{resource.name} -- skipping&#34;
                        )
                if not resource_to_patch:
                    return
        else:
            resource_to_patch = self._patches

        patches_to_apply = {
            resource: self._patches[resource] for resource in resource_to_patch
        }

        # apply changes
        self._apply_patches(
            patches=patches_to_apply, action_text=&#34;Updating&#34;, action=self.action
        )

    def restore(self):
        self._apply_patches(
            patches=self._backups, action_text=&#34;Restoring&#34;, action=self.action
        )

    def __enter__(self):
        self.update(backup_resources=True)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # restore backups
        self.restore()

    @staticmethod
    def _create_backup(original, patch):
        &#34;&#34;&#34;
        Args:
            original (dict*): source of values to back up if necessary
            patch (dict*): &#39;new&#39; values; keys needn&#39;t necessarily all be
                contained in original

        Returns a dict containing the fields in original that are different
        from update. Performs the

        Places None for fields in update that don&#39;t appear in
        original (because that&#39;s how the API knows to remove those fields from
        the yaml).

        * the first call will be with both of these arguments as dicts but
        this will not necessarily be the case during recursion&#34;&#34;&#34;

        # when both are dicts, get the diff (recursively if need be)
        if isinstance(original, dict) and isinstance(patch, dict):
            diff_dict = {}
            for key, value in patch.items():
                if key not in original:
                    diff_dict[key] = None
                    continue

                # recursive call
                key_diff = ResourceEditor._create_backup(
                    original=original[key], patch=value
                )

                if key_diff is not None:
                    diff_dict[key] = key_diff

            return diff_dict

        # for one or more non-dict values, just compare them
        if patch != original:
            return original
        else:
            # this return value will be received by key_diff above
            return None

    @staticmethod
    def _apply_patches(patches, action_text, action):
        &#34;&#34;&#34;
        Updates provided Resource objects with provided yaml patches

        Args:
            patches (dict): {&lt;Resource object&gt;: &lt;yaml patch as dict&gt;}
            action_text (str):
                &#34;ResourceEdit &lt;action_text&gt; for resource &lt;resource name&gt;&#34;
                will be printed for each resource; see below
        &#34;&#34;&#34;
        for resource, patch in patches.items():
            LOGGER.info(
                f&#34;ResourceEdits: {action_text} data for &#34;
                f&#34;resource {resource.kind} {resource.name}&#34;
            )

            # add name to patch
            if &#34;metadata&#34; not in patch:
                patch[&#34;metadata&#34;] = {}

            # the api requires this field to be present in a yaml patch for
            # some resource kinds even if it is not changed
            if &#34;name&#34; not in patch[&#34;metadata&#34;]:
                patch[&#34;metadata&#34;][&#34;name&#34;] = resource.name

            if action == &#34;update&#34;:
                resource.update(resource_dict=patch)  # update the resource

            if action == &#34;replace&#34;:
                if &#34;metadata&#34; not in patch:
                    patch[&#34;metadata&#34;] = {}

                patch[&#34;metadata&#34;][&#34;name&#34;] = resource.name
                patch[&#34;metadata&#34;][&#34;namespace&#34;] = resource.namespace
                patch[&#34;metadata&#34;][
                    &#34;resourceVersion&#34;
                ] = resource.instance.metadata.resourceVersion
                patch[&#34;kind&#34;] = resource.kind
                patch[&#34;apiVersion&#34;] = resource.api_version

                resource.update_replace(
                    resource_dict=patch
                )  # replace the resource metadata</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ocp_resources.resource.ResourceEditor.backups"><code class="name">var <span class="ident">backups</span></code></dt>
<dd>
<div class="desc"><p>Returns a dict {<Resource object>: <backup_as_dict>}
The backup dict kept for each resource edited</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def backups(self):
    &#34;&#34;&#34;Returns a dict {&lt;Resource object&gt;: &lt;backup_as_dict&gt;}
    The backup dict kept for each resource edited&#34;&#34;&#34;
    return self._backups</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.ResourceEditor.patches"><code class="name">var <span class="ident">patches</span></code></dt>
<dd>
<div class="desc"><p>Returns the patches dict provided in the constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def patches(self):
    &#34;&#34;&#34;Returns the patches dict provided in the constructor&#34;&#34;&#34;
    return self._patches</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocp_resources.resource.ResourceEditor.restore"><code class="name flex">
<span>def <span class="ident">restore</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore(self):
    self._apply_patches(
        patches=self._backups, action_text=&#34;Restoring&#34;, action=self.action
    )</code></pre>
</details>
</dd>
<dt id="ocp_resources.resource.ResourceEditor.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, backup_resources=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares backup dicts (where necessary) and applies patches</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, backup_resources=False):
    &#34;&#34;&#34;Prepares backup dicts (where necessary) and applies patches&#34;&#34;&#34;
    # prepare update dicts and backups
    resource_to_patch = []
    if backup_resources:
        LOGGER.info(&#34;ResourceEdit: Backing up old data&#34;)
        if self.user_backups:
            resource_to_patch = self._patches
            self._backups = self.user_backups

        else:
            for resource, update in self._patches.items():
                namespace = None
                # prepare backup
                try:
                    original_resource_dict = resource.instance.to_dict()
                except NotFoundError:
                    # Some resource cannot be found by name.
                    # happens in &#39;ServiceMonitor&#39; resource.
                    original_resource_dict = list(
                        resource.get(
                            dyn_client=resource.client,
                            field_selector=f&#34;metadata.name={resource.name}&#34;,
                        )
                    )[0].to_dict()
                    namespace = update.get(&#34;metadata&#34;, {}).get(&#34;namespace&#34;)

                backup = self._create_backup(
                    original=original_resource_dict, patch=update
                )
                if namespace:
                    # Add namespace to metadata for restore.
                    backup[&#34;metadata&#34;][&#34;namespace&#34;] = namespace

                # no need to back up if no changes have been made
                # if action is &#39;replace&#39; we need to update even if no backup (replace update can be empty )
                if backup or self.action == &#34;replace&#34;:
                    resource_to_patch.append(resource)
                    self._backups[resource] = backup
                else:
                    LOGGER.warning(
                        f&#34;ResourceEdit: no diff found in patch for &#34;
                        f&#34;{resource.name} -- skipping&#34;
                    )
            if not resource_to_patch:
                return
    else:
        resource_to_patch = self._patches

    patches_to_apply = {
        resource: self._patches[resource] for resource in resource_to_patch
    }

    # apply changes
    self._apply_patches(
        patches=patches_to_apply, action_text=&#34;Updating&#34;, action=self.action
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ocp_resources.resource.ValueMismatch"><code class="flex name class">
<span>class <span class="ident">ValueMismatch</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raises when value doesn't match the class value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValueMismatch(Exception):
    &#34;&#34;&#34;
    Raises when value doesn&#39;t match the class value
    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ocp_resources.resource.classproperty"><code class="flex name class">
<span>class <span class="ident">classproperty</span></span>
<span>(</span><span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class classproperty(object):  # noqa: N801
    def __init__(self, func):
        self.func = func

    def __get__(self, obj, owner):
        return self.func(owner)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocp_resources" href="index.html">ocp_resources</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ocp_resources.resource.sub_resource_level" href="#ocp_resources.resource.sub_resource_level">sub_resource_level</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ocp_resources.resource.KubeAPIVersion" href="#ocp_resources.resource.KubeAPIVersion">KubeAPIVersion</a></code></h4>
<ul class="">
<li><code><a title="ocp_resources.resource.KubeAPIVersion.component_re" href="#ocp_resources.resource.KubeAPIVersion.component_re">component_re</a></code></li>
<li><code><a title="ocp_resources.resource.KubeAPIVersion.parse" href="#ocp_resources.resource.KubeAPIVersion.parse">parse</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocp_resources.resource.NamespacedResource" href="#ocp_resources.resource.NamespacedResource">NamespacedResource</a></code></h4>
<ul class="">
<li><code><a title="ocp_resources.resource.NamespacedResource.get" href="#ocp_resources.resource.NamespacedResource.get">get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocp_resources.resource.Resource" href="#ocp_resources.resource.Resource">Resource</a></code></h4>
<ul class="two-column">
<li><code><a title="ocp_resources.resource.Resource.ApiGroup" href="#ocp_resources.resource.Resource.ApiGroup">ApiGroup</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.ApiVersion" href="#ocp_resources.resource.Resource.ApiVersion">ApiVersion</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.Condition" href="#ocp_resources.resource.Resource.Condition">Condition</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.Interface" href="#ocp_resources.resource.Resource.Interface">Interface</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.Status" href="#ocp_resources.resource.Resource.Status">Status</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.api" href="#ocp_resources.resource.Resource.api">api</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.api_group" href="#ocp_resources.resource.Resource.api_group">api_group</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.api_request" href="#ocp_resources.resource.Resource.api_request">api_request</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.api_version" href="#ocp_resources.resource.Resource.api_version">api_version</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.clean_up" href="#ocp_resources.resource.Resource.clean_up">clean_up</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.client_wait_deleted" href="#ocp_resources.resource.Resource.client_wait_deleted">client_wait_deleted</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.create" href="#ocp_resources.resource.Resource.create">create</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.delete" href="#ocp_resources.resource.Resource.delete">delete</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.deploy" href="#ocp_resources.resource.Resource.deploy">deploy</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.exists" href="#ocp_resources.resource.Resource.exists">exists</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.get" href="#ocp_resources.resource.Resource.get">get</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.instance" href="#ocp_resources.resource.Resource.instance">instance</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.kind" href="#ocp_resources.resource.Resource.kind">kind</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.labels" href="#ocp_resources.resource.Resource.labels">labels</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.singular_name" href="#ocp_resources.resource.Resource.singular_name">singular_name</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.status" href="#ocp_resources.resource.Resource.status">status</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.to_dict" href="#ocp_resources.resource.Resource.to_dict">to_dict</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.update" href="#ocp_resources.resource.Resource.update">update</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.update_replace" href="#ocp_resources.resource.Resource.update_replace">update_replace</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait" href="#ocp_resources.resource.Resource.wait">wait</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_deleted" href="#ocp_resources.resource.Resource.wait_deleted">wait_deleted</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_for_condition" href="#ocp_resources.resource.Resource.wait_for_condition">wait_for_condition</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_for_conditions" href="#ocp_resources.resource.Resource.wait_for_conditions">wait_for_conditions</a></code></li>
<li><code><a title="ocp_resources.resource.Resource.wait_for_status" href="#ocp_resources.resource.Resource.wait_for_status">wait_for_status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocp_resources.resource.ResourceEditor" href="#ocp_resources.resource.ResourceEditor">ResourceEditor</a></code></h4>
<ul class="">
<li><code><a title="ocp_resources.resource.ResourceEditor.backups" href="#ocp_resources.resource.ResourceEditor.backups">backups</a></code></li>
<li><code><a title="ocp_resources.resource.ResourceEditor.patches" href="#ocp_resources.resource.ResourceEditor.patches">patches</a></code></li>
<li><code><a title="ocp_resources.resource.ResourceEditor.restore" href="#ocp_resources.resource.ResourceEditor.restore">restore</a></code></li>
<li><code><a title="ocp_resources.resource.ResourceEditor.update" href="#ocp_resources.resource.ResourceEditor.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocp_resources.resource.ValueMismatch" href="#ocp_resources.resource.ValueMismatch">ValueMismatch</a></code></h4>
</li>
<li>
<h4><code><a title="ocp_resources.resource.classproperty" href="#ocp_resources.resource.classproperty">classproperty</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>

{
  "description": "IstioRevision represents a single revision of an Istio Service Mesh deployment.\nUsers shouldn't create IstioRevision objects directly. Instead, they should\ncreate an Istio object and allow the operator to create the underlying\nIstioRevision object(s).",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      "$ref": "_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    },
    "spec": {
      "description": "IstioRevisionSpec defines the desired state of IstioRevision",
      "type": "object",
      "required": [
        "namespace",
        "version"
      ],
      "properties": {
        "namespace": {
          "description": "Namespace to which the Istio components should be installed.",
          "type": "string",
          "x-kubernetes-validations": [
            {
              "message": "Value is immutable",
              "rule": "self == oldSelf"
            }
          ]
        },
        "values": {
          "description": "Defines the values to be passed to the Helm charts when installing Istio.",
          "type": "object",
          "properties": {
            "base": {
              "description": "Configuration for the base component.",
              "type": "object",
              "properties": {
                "excludedCRDs": {
                  "description": "CRDs to exclude. Requires `enableCRDTemplates`",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "validationCABundle": {
                  "description": "validation webhook CA bundle",
                  "type": "string"
                },
                "validationURL": {
                  "description": "URL to use for validating webhook.",
                  "type": "string"
                }
              }
            },
            "compatibilityVersion": {
              "description": "Specifies the compatibility version to use. When this is set, the control plane will\nbe configured with the same defaults as the specified version.",
              "type": "string"
            },
            "defaultRevision": {
              "description": "The name of the default revision in the cluster.",
              "type": "string"
            },
            "experimental": {
              "description": "Specifies experimental helm fields that could be removed or changed in the future",
              "x-kubernetes-preserve-unknown-fields": true
            },
            "global": {
              "description": "Global configuration for Istio components.",
              "type": "object",
              "properties": {
                "arch": {
                  "description": "Specifies pod scheduling arch(amd64, ppc64le, s390x, arm64) and weight as follows:\n\n\t0 - Never scheduled\n\t1 - Least preferred\n\t2 - No preference\n\t3 - Most preferred\n\nDeprecated: replaced by the affinity k8s settings which allows architecture nodeAffinity configuration of this behavior.\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "object",
                  "properties": {
                    "amd64": {
                      "description": "Sets pod scheduling weight for amd64 arch",
                      "type": "integer",
                      "format": "int32"
                    },
                    "arm64": {
                      "description": "Sets pod scheduling weight for arm64 arch.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "ppc64le": {
                      "description": "Sets pod scheduling weight for ppc64le arch.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "s390x": {
                      "description": "Sets pod scheduling weight for s390x arch.",
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                },
                "caAddress": {
                  "description": "The address of the CA for CSR.",
                  "type": "string"
                },
                "caName": {
                  "description": "The name of the CA for workloads.\nFor example, when caName=GkeWorkloadCertificate, GKE workload certificates\nwill be used as the certificates for workloads.\nThe default value is \"\" and when caName=\"\", the CA will be configured by other\nmechanisms (e.g., environmental variable CA_PROVIDER).",
                  "type": "string"
                },
                "certSigners": {
                  "description": "List of certSigners to allow \"approve\" action in the ClusterRole",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "configCluster": {
                  "description": "Controls whether a remote cluster is the config cluster for an external istiod",
                  "type": "boolean"
                },
                "configValidation": {
                  "description": "Controls whether the server-side validation is enabled.",
                  "type": "boolean"
                },
                "defaultNodeSelector": {
                  "description": "Default k8s node selector for all the Istio control plane components\n\nSee https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "defaultPodDisruptionBudget": {
                  "description": "Specifies the default pod disruption budget configuration.",
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "description": "Controls whether a PodDisruptionBudget with a default minAvailable value of 1 is created for each deployment.",
                      "type": "boolean"
                    }
                  }
                },
                "defaultResources": {
                  "description": "Default k8s resources settings for all Istio control plane components.\n\nSee https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "object",
                  "properties": {
                    "claims": {
                      "description": "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.",
                      "type": "array",
                      "items": {
                        "description": "ResourceClaim references one entry in PodSpec.ResourceClaims.",
                        "type": "object",
                        "required": [
                          "name"
                        ],
                        "properties": {
                          "name": {
                            "description": "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.",
                            "type": "string"
                          },
                          "request": {
                            "description": "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.",
                            "type": "string"
                          }
                        }
                      },
                      "x-kubernetes-list-map-keys": [
                        "name"
                      ],
                      "x-kubernetes-list-type": "map"
                    },
                    "limits": {
                      "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                      "type": "object",
                      "additionalProperties": {
                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                        "x-kubernetes-int-or-string": true
                      }
                    },
                    "requests": {
                      "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                      "type": "object",
                      "additionalProperties": {
                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                        "x-kubernetes-int-or-string": true
                      }
                    }
                  }
                },
                "defaultTolerations": {
                  "description": "Default node tolerations to be applied to all deployments so that all pods can be\nscheduled to nodes with matching taints. Each component can overwrite\nthese default values by adding its tolerations block in the relevant section below\nand setting the desired values.\nConfigure this field in case that all pods of Istio control plane are expected to\nbe scheduled to particular nodes with specified taints.\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "array",
                  "items": {
                    "description": "The pod this Toleration is attached to tolerates any taint that matches\nthe triple <key,value,effect> using the matching operator <operator>.",
                    "type": "object",
                    "properties": {
                      "effect": {
                        "description": "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                        "type": "string"
                      },
                      "key": {
                        "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.",
                        "type": "string"
                      },
                      "tolerationSeconds": {
                        "description": "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "value": {
                        "description": "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.",
                        "type": "string"
                      }
                    }
                  }
                },
                "externalIstiod": {
                  "description": "Controls whether one external istiod is enabled.",
                  "type": "boolean"
                },
                "hub": {
                  "description": "Specifies the docker hub for Istio images.",
                  "type": "string"
                },
                "imagePullPolicy": {
                  "description": "Specifies the image pull policy for the Istio images. one of Always, Never, IfNotPresent.\nDefaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated.\n\nMore info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
                  "type": "string",
                  "enum": [
                    "Always",
                    "Never",
                    "IfNotPresent"
                  ]
                },
                "imagePullSecrets": {
                  "description": "ImagePullSecrets for the control plane ServiceAccount, list of secrets in the same namespace\nto use for pulling any images in pods that reference this ServiceAccount.\nMust be set for any cluster configured with private docker registry.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ipFamilies": {
                  "description": "Defines which IP family to use for single stack or the order of IP families for dual-stack.\nValid list items are \"IPv4\", \"IPv6\".\nMore info: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ipFamilyPolicy": {
                  "description": "Controls whether Services are configured to use IPv4, IPv6, or both. Valid options\nare PreferDualStack, RequireDualStack, and SingleStack.\nMore info: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services",
                  "type": "string"
                },
                "istioNamespace": {
                  "description": "Specifies the default namespace for the Istio control plane components.",
                  "type": "string"
                },
                "istiod": {
                  "description": "Specifies the configution of istiod",
                  "type": "object",
                  "properties": {
                    "enableAnalysis": {
                      "description": "If enabled, istiod will perform config analysis",
                      "type": "boolean"
                    }
                  }
                },
                "jwtPolicy": {
                  "description": "Configure the policy for validating JWT.\nThis is deprecated and has no effect.\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "string"
                },
                "logAsJson": {
                  "description": "Specifies whether istio components should output logs in json format by adding --log_as_json argument to each container.",
                  "type": "boolean"
                },
                "logging": {
                  "description": "Specifies the global logging level settings for the Istio control plane components.",
                  "type": "object",
                  "properties": {
                    "level": {
                      "description": "Comma-separated minimum per-scope logging level of messages to output, in the form of <scope>:<level>,<scope>:<level>\nThe control plane has different scopes depending on component, but can configure default log level across all components\nIf empty, default scope and level will be used as configured in code",
                      "type": "string"
                    }
                  }
                },
                "meshID": {
                  "description": "The Mesh Identifier. It should be unique within the scope where\nmeshes will interact with each other, but it is not required to be\nglobally/universally unique. For example, if any of the following are true,\nthen two meshes must have different Mesh IDs:\n- Meshes will have their telemetry aggregated in one place\n- Meshes will be federated together\n- Policy will be written referencing one mesh from the other\n\nIf an administrator expects that any of these conditions may become true in\nthe future, they should ensure their meshes have different Mesh IDs\nassigned.\n\nWithin a multicluster mesh, each cluster must be (manually or auto)\nconfigured to have the same Mesh ID value. If an existing cluster 'joins' a\nmulticluster mesh, it will need to be migrated to the new mesh ID. Details\nof migration TBD, and it may be a disruptive operation to change the Mesh\nID post-install.\n\nIf the mesh admin does not specify a value, Istio will use the value of the\nmesh's Trust Domain. The best practice is to select a proper Trust Domain\nvalue.",
                  "type": "string"
                },
                "meshNetworks": {
                  "description": "Configure the mesh networks to be used by the Split Horizon EDS.\n\nThe following example defines two networks with different endpoints association methods.\nFor `network1` all endpoints that their IP belongs to the provided CIDR range will be\nmapped to network1. The gateway for this network example is specified by its public IP\naddress and port.\nThe second network, `network2`, in this example is defined differently with all endpoints\nretrieved through the specified Multi-Cluster registry being mapped to network2. The\ngateway is also defined differently with the name of the gateway service on the remote\ncluster. The public IP for the gateway will be determined from that remote service (only\nLoadBalancer gateway service type is currently supported, for a NodePort type gateway service,\nit still need to be configured manually).\n\nmeshNetworks:\n\n\tnetwork1:\n\t  endpoints:\n\t  - fromCidr: \"192.168.0.1/24\"\n\t  gateways:\n\t  - address: 1.1.1.1\n\t    port: 80\n\tnetwork2:\n\t  endpoints:\n\t  - fromRegistry: reg1\n\t  gateways:\n\t  - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local\n\t    port: 443",
                  "type": "object",
                  "additionalProperties": {
                    "description": "Network provides information about the endpoints in a routable L3\nnetwork. A single routable L3 network can have one or more service\nregistries. Note that the network has no relation to the locality of the\nendpoint. The endpoint locality will be obtained from the service\nregistry.",
                    "type": "object",
                    "properties": {
                      "endpoints": {
                        "description": "The list of endpoints in the network (obtained through the\nconstituent service registries or from CIDR ranges). All endpoints in\nthe network are directly accessible to one another.",
                        "type": "array",
                        "items": {
                          "description": "NetworkEndpoints describes how the network associated with an endpoint\nshould be inferred. An endpoint will be assigned to a network based on\nthe following rules:\n\n1. Implicitly: If the registry explicitly provides information about\nthe network to which the endpoint belongs to. In some cases, its\npossible to indicate the network associated with the endpoint by\nadding the `ISTIO_META_NETWORK` environment variable to the sidecar.\n\n2. Explicitly:\n\n\ta. By matching the registry name with one of the \"fromRegistry\"\n\tin the mesh config. A \"fromRegistry\" can only be assigned to a\n\tsingle network.\n\n\tb. By matching the IP against one of the CIDR ranges in a mesh\n\tconfig network. The CIDR ranges must not overlap and be assigned to\n\ta single network.\n\n(2) will override (1) if both are present.",
                          "type": "object",
                          "properties": {
                            "fromCidr": {
                              "description": "A CIDR range for the set of endpoints in this network. The CIDR\nranges for endpoints from different networks must not overlap.",
                              "type": "string"
                            },
                            "fromRegistry": {
                              "description": "Add all endpoints from the specified registry into this network.\nThe names of the registries should correspond to the kubeconfig file name\ninside the secret that was used to configure the registry (Kubernetes\nmulticluster) or supplied by MCP server.",
                              "type": "string"
                            }
                          },
                          "x-kubernetes-validations": [
                            {
                              "message": "At most one of [fromCidr fromRegistry] should be set",
                              "rule": "(has(self.fromCidr)?1:0) + (has(self.fromRegistry)?1:0) <= 1"
                            }
                          ]
                        }
                      },
                      "gateways": {
                        "description": "Set of gateways associated with the network.",
                        "type": "array",
                        "items": {
                          "description": "The gateway associated with this network. Traffic from remote networks\nwill arrive at the specified gateway:port. All incoming traffic must\nuse mTLS.",
                          "type": "object",
                          "properties": {
                            "address": {
                              "description": "IP address or externally resolvable DNS address associated with the gateway.",
                              "type": "string"
                            },
                            "locality": {
                              "description": "The locality associated with an explicitly specified gateway (i.e. ip)",
                              "type": "string"
                            },
                            "port": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "registryServiceName": {
                              "description": "A fully qualified domain name of the gateway service.  istiod will\nlookup the service from the service registries in the network and\nobtain the endpoint IPs of the gateway from the service\nregistry. Note that while the service name is a fully qualified\ndomain name, it need not be resolvable outside the orchestration\nplatform for the registry. e.g., this could be\nistio-ingressgateway.istio-system.svc.cluster.local.",
                              "type": "string"
                            }
                          },
                          "x-kubernetes-validations": [
                            {
                              "message": "At most one of [registryServiceName address] should be set",
                              "rule": "(has(self.registryServiceName)?1:0) + (has(self.address)?1:0) <= 1"
                            }
                          ]
                        }
                      }
                    }
                  }
                },
                "mountMtlsCerts": {
                  "description": "Controls whether the in-cluster MTLS key and certs are loaded from the secret volume mounts.",
                  "type": "boolean"
                },
                "multiCluster": {
                  "description": "Specifies the Configuration for Istio mesh across multiple clusters through Istio gateways.",
                  "type": "object",
                  "properties": {
                    "clusterName": {
                      "description": "The name of the cluster this installation will run in. This is required for sidecar injection\nto properly label proxies",
                      "type": "string"
                    },
                    "enabled": {
                      "description": "Enables the connection between two kubernetes clusters via their respective ingressgateway services.\nUse if the pods in each cluster cannot directly talk to one another.",
                      "type": "boolean"
                    },
                    "globalDomainSuffix": {
                      "description": "The suffix for global service names.",
                      "type": "string"
                    },
                    "includeEnvoyFilter": {
                      "description": "Enable envoy filter to translate `globalDomainSuffix` to cluster local suffix for cross cluster communication.",
                      "type": "boolean"
                    }
                  }
                },
                "network": {
                  "description": "Network defines the network this cluster belong to. This name\ncorresponds to the networks in the map of mesh networks.",
                  "type": "string"
                },
                "omitSidecarInjectorConfigMap": {
                  "description": "Controls whether the creation of the sidecar injector ConfigMap should be skipped.\nDefaults to false. When set to true, the sidecar injector ConfigMap will not be created.",
                  "type": "boolean"
                },
                "operatorManageWebhooks": {
                  "description": "Controls whether the WebhookConfiguration resource(s) should be created. The current behavior\nof Istiod is to manage its own webhook configurations.\nWhen this option is set to true, Istio Operator, instead of webhooks, manages the\nwebhook configurations. When this option is set as false, webhooks manage their\nown webhook configurations.",
                  "type": "boolean"
                },
                "pilotCertProvider": {
                  "description": "Configure the Pilot certificate provider.\nCurrently, four providers are supported: \"kubernetes\", \"istiod\", \"custom\" and \"none\".",
                  "type": "string"
                },
                "platform": {
                  "description": "Platform in which Istio is deployed. Possible values are: \"openshift\" and \"gcp\"\nAn empty value means it is a vanilla Kubernetes distribution, therefore no special\ntreatment will be considered.",
                  "type": "string"
                },
                "podDNSSearchNamespaces": {
                  "description": "Custom DNS config for the pod to resolve names of services in other\nclusters. Use this to add additional search domains, and other settings.\nsee https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#dns-config\nThis does not apply to gateway pods as they typically need a different\nset of DNS settings than the normal application pods (e.g. in multicluster scenarios).",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "priorityClassName": {
                  "description": "Specifies the k8s priorityClassName for the istio control plane components.\n\nSee https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "string"
                },
                "proxy": {
                  "description": "Specifies how proxies are configured within Istio.",
                  "type": "object",
                  "properties": {
                    "autoInject": {
                      "description": "Controls the 'policy' in the sidecar injector.",
                      "type": "string"
                    },
                    "clusterDomain": {
                      "description": "Domain for the cluster, default: \"cluster.local\".\n\nK8s allows this to be customized, see https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/",
                      "type": "string"
                    },
                    "componentLogLevel": {
                      "description": "Per Component log level for proxy, applies to gateways and sidecars.\n\nIf a component level is not set, then the global \"logLevel\" will be used. If left empty, \"misc:error\" is used.",
                      "type": "string"
                    },
                    "enableCoreDump": {
                      "description": "Enables core dumps for newly injected sidecars.\n\nIf set, newly injected sidecars will have core dumps enabled.\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                      "type": "boolean"
                    },
                    "excludeIPRanges": {
                      "description": "Lists the excluded IP ranges of Istio egress traffic that the sidecar captures.",
                      "type": "string"
                    },
                    "excludeInboundPorts": {
                      "description": "Specifies the Istio ingress ports not to capture.",
                      "type": "string"
                    },
                    "excludeOutboundPorts": {
                      "description": "A comma separated list of outbound ports to be excluded from redirection to Envoy.",
                      "type": "string"
                    },
                    "holdApplicationUntilProxyStarts": {
                      "description": "Controls if sidecar is injected at the front of the container list and blocks the start of the other containers until the proxy is ready\n\nDeprecated: replaced by ProxyConfig setting which allows per-pod configuration of this behavior.\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                      "type": "boolean"
                    },
                    "image": {
                      "description": "Image name or path for the proxy, default: \"proxyv2\".\n\nIf registry or tag are not specified, global.hub and global.tag are used.\n\nExamples: my-proxy (uses global.hub/tag), docker.io/myrepo/my-proxy:v1.0.0",
                      "type": "string"
                    },
                    "includeIPRanges": {
                      "description": "Lists the IP ranges of Istio egress traffic that the sidecar captures.\n\nExample: \"172.30.0.0/16,172.20.0.0/16\"\nThis would only capture egress traffic on those two IP Ranges, all other outbound traffic would # be allowed by the sidecar.\"",
                      "type": "string"
                    },
                    "includeInboundPorts": {
                      "description": "A comma separated list of inbound ports for which traffic is to be redirected to Envoy.\nThe wildcard character '*' can be used to configure redirection for all ports.",
                      "type": "string"
                    },
                    "includeOutboundPorts": {
                      "description": "A comma separated list of outbound ports for which traffic is to be redirected to Envoy, regardless of the destination IP.",
                      "type": "string"
                    },
                    "lifecycle": {
                      "description": "The k8s lifecycle hooks definition (pod.spec.containers.lifecycle) for the proxy container.\nMore info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                      "type": "object",
                      "properties": {
                        "postStart": {
                          "description": "PostStart is called immediately after a container is created. If the handler fails,\nthe container is terminated and restarted according to its restart policy.\nOther management of the container blocks until the hook completes.\nMore info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                          "type": "object",
                          "properties": {
                            "exec": {
                              "description": "Exec specifies a command to execute in the container.",
                              "type": "object",
                              "properties": {
                                "command": {
                                  "description": "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "x-kubernetes-list-type": "atomic"
                                }
                              }
                            },
                            "httpGet": {
                              "description": "HTTPGet specifies an HTTP GET request to perform.",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "host": {
                                  "description": "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.",
                                  "type": "string"
                                },
                                "httpHeaders": {
                                  "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                  "type": "array",
                                  "items": {
                                    "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                    "type": "object",
                                    "required": [
                                      "name",
                                      "value"
                                    ],
                                    "properties": {
                                      "name": {
                                        "description": "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header.",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The header field value",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "x-kubernetes-list-type": "atomic"
                                },
                                "path": {
                                  "description": "Path to access on the HTTP server.",
                                  "type": "string"
                                },
                                "port": {
                                  "description": "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.",
                                  "x-kubernetes-int-or-string": true
                                },
                                "scheme": {
                                  "description": "Scheme to use for connecting to the host.\nDefaults to HTTP.",
                                  "type": "string"
                                }
                              }
                            },
                            "sleep": {
                              "description": "Sleep represents a duration that the container should sleep.",
                              "type": "object",
                              "required": [
                                "seconds"
                              ],
                              "properties": {
                                "seconds": {
                                  "description": "Seconds is the number of seconds to sleep.",
                                  "type": "integer",
                                  "format": "int64"
                                }
                              }
                            },
                            "tcpSocket": {
                              "description": "Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept\nfor backward compatibility. There is no validation of this field and\nlifecycle hooks will fail at runtime when it is specified.",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "host": {
                                  "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                  "type": "string"
                                },
                                "port": {
                                  "description": "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.",
                                  "x-kubernetes-int-or-string": true
                                }
                              }
                            }
                          }
                        },
                        "preStop": {
                          "description": "PreStop is called immediately before a container is terminated due to an\nAPI request or management event such as liveness/startup probe failure,\npreemption, resource contention, etc. The handler is not called if the\ncontainer crashes or exits. The Pod's termination grace period countdown begins before the\nPreStop hook is executed. Regardless of the outcome of the handler, the\ncontainer will eventually terminate within the Pod's termination grace\nperiod (unless delayed by finalizers). Other management of the container blocks until the hook completes\nor until the termination grace period is reached.\nMore info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks",
                          "type": "object",
                          "properties": {
                            "exec": {
                              "description": "Exec specifies a command to execute in the container.",
                              "type": "object",
                              "properties": {
                                "command": {
                                  "description": "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "x-kubernetes-list-type": "atomic"
                                }
                              }
                            },
                            "httpGet": {
                              "description": "HTTPGet specifies an HTTP GET request to perform.",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "host": {
                                  "description": "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.",
                                  "type": "string"
                                },
                                "httpHeaders": {
                                  "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                  "type": "array",
                                  "items": {
                                    "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                    "type": "object",
                                    "required": [
                                      "name",
                                      "value"
                                    ],
                                    "properties": {
                                      "name": {
                                        "description": "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header.",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The header field value",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "x-kubernetes-list-type": "atomic"
                                },
                                "path": {
                                  "description": "Path to access on the HTTP server.",
                                  "type": "string"
                                },
                                "port": {
                                  "description": "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.",
                                  "x-kubernetes-int-or-string": true
                                },
                                "scheme": {
                                  "description": "Scheme to use for connecting to the host.\nDefaults to HTTP.",
                                  "type": "string"
                                }
                              }
                            },
                            "sleep": {
                              "description": "Sleep represents a duration that the container should sleep.",
                              "type": "object",
                              "required": [
                                "seconds"
                              ],
                              "properties": {
                                "seconds": {
                                  "description": "Seconds is the number of seconds to sleep.",
                                  "type": "integer",
                                  "format": "int64"
                                }
                              }
                            },
                            "tcpSocket": {
                              "description": "Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept\nfor backward compatibility. There is no validation of this field and\nlifecycle hooks will fail at runtime when it is specified.",
                              "type": "object",
                              "required": [
                                "port"
                              ],
                              "properties": {
                                "host": {
                                  "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                  "type": "string"
                                },
                                "port": {
                                  "description": "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.",
                                  "x-kubernetes-int-or-string": true
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "logLevel": {
                      "description": "Log level for proxy, applies to gateways and sidecars. If left empty, \"warning\" is used. Expected values are: trace\\|debug\\|info\\|warning\\|error\\|critical\\|off",
                      "type": "string"
                    },
                    "outlierLogPath": {
                      "description": "Path to the file to which the proxy will write outlier detection logs.\n\nExample: \"/dev/stdout\"\nThis would write the logs to standard output.",
                      "type": "string"
                    },
                    "privileged": {
                      "description": "Enables privileged securityContext for the istio-proxy container.\n\nSee https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
                      "type": "boolean"
                    },
                    "readinessFailureThreshold": {
                      "description": "Sets the number of successive failed probes before indicating readiness failure.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "readinessInitialDelaySeconds": {
                      "description": "Sets the initial delay for readiness probes in seconds.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "readinessPeriodSeconds": {
                      "description": "Sets the interval between readiness probes in seconds.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "resources": {
                      "description": "K8s resources settings.\n\nSee https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                      "type": "object",
                      "properties": {
                        "claims": {
                          "description": "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.",
                          "type": "array",
                          "items": {
                            "description": "ResourceClaim references one entry in PodSpec.ResourceClaims.",
                            "type": "object",
                            "required": [
                              "name"
                            ],
                            "properties": {
                              "name": {
                                "description": "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.",
                                "type": "string"
                              },
                              "request": {
                                "description": "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.",
                                "type": "string"
                              }
                            }
                          },
                          "x-kubernetes-list-map-keys": [
                            "name"
                          ],
                          "x-kubernetes-list-type": "map"
                        },
                        "limits": {
                          "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                          "type": "object",
                          "additionalProperties": {
                            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                            "x-kubernetes-int-or-string": true
                          }
                        },
                        "requests": {
                          "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                          "type": "object",
                          "additionalProperties": {
                            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                            "x-kubernetes-int-or-string": true
                          }
                        }
                      }
                    },
                    "startupProbe": {
                      "description": "Configures the startup probe for the istio-proxy container.",
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "description": "Enables or disables a startup probe.\nFor optimal startup times, changing this should be tied to the readiness probe values.\n\nIf the probe is enabled, it is recommended to have delay=0s,period=15s,failureThreshold=4.\nThis ensures the pod is marked ready immediately after the startup probe passes (which has a 1s poll interval),\nand doesn't spam the readiness endpoint too much\n\nIf the probe is disabled, it is recommended to have delay=1s,period=2s,failureThreshold=30.\nThis ensures the startup is reasonable fast (polling every 2s). 1s delay is used since the startup is not often ready instantly.",
                          "type": "boolean"
                        },
                        "failureThreshold": {
                          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded.",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    },
                    "statusPort": {
                      "description": "Default port used for the Pilot agent's health checks.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "tracer": {
                      "description": "Specify which tracer to use. One of: zipkin, lightstep, datadog, stackdriver.\nIf using stackdriver tracer outside GCP, set env GOOGLE_APPLICATION_CREDENTIALS to the GCP credential file.",
                      "type": "string",
                      "enum": [
                        "zipkin",
                        "lightstep",
                        "datadog",
                        "stackdriver",
                        "openCensusAgent",
                        "none"
                      ]
                    }
                  }
                },
                "proxy_init": {
                  "description": "Specifies the Configuration for proxy_init container which sets the pods' networking to intercept the inbound/outbound traffic.",
                  "type": "object",
                  "properties": {
                    "image": {
                      "description": "Specifies the image for the proxy_init container.",
                      "type": "string"
                    },
                    "resources": {
                      "description": "K8s resources settings.\n\nSee https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                      "type": "object",
                      "properties": {
                        "claims": {
                          "description": "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.",
                          "type": "array",
                          "items": {
                            "description": "ResourceClaim references one entry in PodSpec.ResourceClaims.",
                            "type": "object",
                            "required": [
                              "name"
                            ],
                            "properties": {
                              "name": {
                                "description": "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.",
                                "type": "string"
                              },
                              "request": {
                                "description": "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.",
                                "type": "string"
                              }
                            }
                          },
                          "x-kubernetes-list-map-keys": [
                            "name"
                          ],
                          "x-kubernetes-list-type": "map"
                        },
                        "limits": {
                          "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                          "type": "object",
                          "additionalProperties": {
                            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                            "x-kubernetes-int-or-string": true
                          }
                        },
                        "requests": {
                          "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                          "type": "object",
                          "additionalProperties": {
                            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                            "x-kubernetes-int-or-string": true
                          }
                        }
                      }
                    }
                  }
                },
                "remotePilotAddress": {
                  "description": "Specifies the Istio control plane\u2019s pilot Pod IP address or remote cluster DNS resolvable hostname.",
                  "type": "string"
                },
                "revision": {
                  "description": "Configures the revision this control plane is a part of",
                  "type": "string"
                },
                "sds": {
                  "description": "Specifies the Configuration for the SecretDiscoveryService instead of using K8S secrets to mount the certificates.",
                  "type": "object",
                  "properties": {
                    "token": {
                      "description": "Deprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                      "type": "object",
                      "properties": {
                        "aud": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "sts": {
                  "description": "Specifies the configuration for Security Token Service.",
                  "type": "object",
                  "properties": {
                    "servicePort": {
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                },
                "tag": {
                  "description": "Specifies the tag for the Istio docker images.",
                  "type": "string"
                },
                "tracer": {
                  "description": "Specifies the Configuration for each of the supported tracers.",
                  "type": "object",
                  "properties": {
                    "datadog": {
                      "description": "Configuration for the datadog tracing service.",
                      "type": "object",
                      "properties": {
                        "address": {
                          "description": "Address in host:port format for reporting trace data to the Datadog agent.",
                          "type": "string"
                        }
                      }
                    },
                    "lightstep": {
                      "description": "Configuration for the lightstep tracing service.",
                      "type": "object",
                      "properties": {
                        "accessToken": {
                          "description": "Sets the lightstep access token.",
                          "type": "string"
                        },
                        "address": {
                          "description": "Sets the lightstep satellite pool address in host:port format for reporting trace data.",
                          "type": "string"
                        }
                      }
                    },
                    "stackdriver": {
                      "description": "Configuration for the stackdriver tracing service.",
                      "type": "object",
                      "properties": {
                        "debug": {
                          "description": "enables trace output to stdout.",
                          "type": "boolean"
                        },
                        "maxNumberOfAnnotations": {
                          "description": "The global default max number of annotation events per span.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "maxNumberOfAttributes": {
                          "description": "The global default max number of attributes per span.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "maxNumberOfMessageEvents": {
                          "description": "The global default max number of message events per span.",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    },
                    "zipkin": {
                      "description": "Configuration for the zipkin tracing service.",
                      "type": "object",
                      "properties": {
                        "address": {
                          "description": "Address of zipkin instance in host:port format for reporting trace data.\n\nExample: <zipkin-collector-service>.<zipkin-collector-namespace>:941",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "variant": {
                  "description": "The variant of the Istio container images to use. Options are \"debug\" or \"distroless\". Unset will use the default for the given version.",
                  "type": "string"
                },
                "waypoint": {
                  "description": "Specifies how waypoints are configured within Istio.",
                  "type": "object",
                  "properties": {
                    "affinity": {
                      "description": "K8s affinity settings for waypoint pods.\n\nSee https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity",
                      "type": "object",
                      "properties": {
                        "nodeAffinity": {
                          "description": "Describes node affinity scheduling rules for the pod.",
                          "type": "object",
                          "properties": {
                            "preferredDuringSchedulingIgnoredDuringExecution": {
                              "description": "The scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node matches the corresponding matchExpressions; the\nnode(s) with the highest sum are the most preferred.",
                              "type": "array",
                              "items": {
                                "description": "An empty preferred scheduling term matches all objects with implicit weight 0\n(i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
                                "type": "object",
                                "required": [
                                  "preference",
                                  "weight"
                                ],
                                "properties": {
                                  "preference": {
                                    "description": "A node selector term, associated with the corresponding weight.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "A list of node selector requirements by node's labels.",
                                        "type": "array",
                                        "items": {
                                          "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "The label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchFields": {
                                        "description": "A list of node selector requirements by node's fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "The label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "weight": {
                                    "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                }
                              },
                              "x-kubernetes-list-type": "atomic"
                            },
                            "requiredDuringSchedulingIgnoredDuringExecution": {
                              "description": "If the affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to an update), the system\nmay or may not try to eventually evict the pod from its node.",
                              "type": "object",
                              "required": [
                                "nodeSelectorTerms"
                              ],
                              "properties": {
                                "nodeSelectorTerms": {
                                  "description": "Required. A list of node selector terms. The terms are ORed.",
                                  "type": "array",
                                  "items": {
                                    "description": "A null or empty node selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "A list of node selector requirements by node's labels.",
                                        "type": "array",
                                        "items": {
                                          "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "The label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchFields": {
                                        "description": "A list of node selector requirements by node's fields.",
                                        "type": "array",
                                        "items": {
                                          "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "The label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "x-kubernetes-list-type": "atomic"
                                }
                              },
                              "x-kubernetes-map-type": "atomic"
                            }
                          }
                        },
                        "podAffinity": {
                          "description": "Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).",
                          "type": "object",
                          "properties": {
                            "preferredDuringSchedulingIgnoredDuringExecution": {
                              "description": "The scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the\nnode(s) with the highest sum are the most preferred.",
                              "type": "array",
                              "items": {
                                "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                                "type": "object",
                                "required": [
                                  "podAffinityTerm",
                                  "weight"
                                ],
                                "properties": {
                                  "podAffinityTerm": {
                                    "description": "Required. A pod affinity term, associated with the corresponding weight.",
                                    "type": "object",
                                    "required": [
                                      "topologyKey"
                                    ],
                                    "properties": {
                                      "labelSelector": {
                                        "description": "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.",
                                        "type": "object",
                                        "properties": {
                                          "matchExpressions": {
                                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                            "type": "array",
                                            "items": {
                                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                              "type": "object",
                                              "required": [
                                                "key",
                                                "operator"
                                              ],
                                              "properties": {
                                                "key": {
                                                  "description": "key is the label key that the selector applies to.",
                                                  "type": "string"
                                                },
                                                "operator": {
                                                  "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                                  "type": "string"
                                                },
                                                "values": {
                                                  "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  },
                                                  "x-kubernetes-list-type": "atomic"
                                                }
                                              }
                                            },
                                            "x-kubernetes-list-type": "atomic"
                                          },
                                          "matchLabels": {
                                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "x-kubernetes-map-type": "atomic"
                                      },
                                      "matchLabelKeys": {
                                        "description": "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "mismatchLabelKeys": {
                                        "description": "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "namespaceSelector": {
                                        "description": "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.",
                                        "type": "object",
                                        "properties": {
                                          "matchExpressions": {
                                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                            "type": "array",
                                            "items": {
                                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                              "type": "object",
                                              "required": [
                                                "key",
                                                "operator"
                                              ],
                                              "properties": {
                                                "key": {
                                                  "description": "key is the label key that the selector applies to.",
                                                  "type": "string"
                                                },
                                                "operator": {
                                                  "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                                  "type": "string"
                                                },
                                                "values": {
                                                  "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  },
                                                  "x-kubernetes-list-type": "atomic"
                                                }
                                              }
                                            },
                                            "x-kubernetes-list-type": "atomic"
                                          },
                                          "matchLabels": {
                                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "x-kubernetes-map-type": "atomic"
                                      },
                                      "namespaces": {
                                        "description": "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "topologyKey": {
                                        "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "weight": {
                                    "description": "weight associated with matching the corresponding podAffinityTerm,\nin the range 1-100.",
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                }
                              },
                              "x-kubernetes-list-type": "atomic"
                            },
                            "requiredDuringSchedulingIgnoredDuringExecution": {
                              "description": "If the affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to a pod label update), the\nsystem may or may not try to eventually evict the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.",
                              "type": "array",
                              "items": {
                                "description": "Defines a set of pods (namely those matching the labelSelector\nrelative to the given namespace(s)) that this pod should be\nco-located (affinity) or not co-located (anti-affinity) with,\nwhere co-located is defined as running on a node whose value of\nthe label with key <topologyKey> matches that of any node on which\na pod of the set of pods is running",
                                "type": "object",
                                "required": [
                                  "topologyKey"
                                ],
                                "properties": {
                                  "labelSelector": {
                                    "description": "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "matchLabelKeys": {
                                    "description": "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "mismatchLabelKeys": {
                                    "description": "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "namespaceSelector": {
                                    "description": "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "namespaces": {
                                    "description": "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "topologyKey": {
                                    "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.",
                                    "type": "string"
                                  }
                                }
                              },
                              "x-kubernetes-list-type": "atomic"
                            }
                          }
                        },
                        "podAntiAffinity": {
                          "description": "Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).",
                          "type": "object",
                          "properties": {
                            "preferredDuringSchedulingIgnoredDuringExecution": {
                              "description": "The scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the\nnode(s) with the highest sum are the most preferred.",
                              "type": "array",
                              "items": {
                                "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                                "type": "object",
                                "required": [
                                  "podAffinityTerm",
                                  "weight"
                                ],
                                "properties": {
                                  "podAffinityTerm": {
                                    "description": "Required. A pod affinity term, associated with the corresponding weight.",
                                    "type": "object",
                                    "required": [
                                      "topologyKey"
                                    ],
                                    "properties": {
                                      "labelSelector": {
                                        "description": "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.",
                                        "type": "object",
                                        "properties": {
                                          "matchExpressions": {
                                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                            "type": "array",
                                            "items": {
                                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                              "type": "object",
                                              "required": [
                                                "key",
                                                "operator"
                                              ],
                                              "properties": {
                                                "key": {
                                                  "description": "key is the label key that the selector applies to.",
                                                  "type": "string"
                                                },
                                                "operator": {
                                                  "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                                  "type": "string"
                                                },
                                                "values": {
                                                  "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  },
                                                  "x-kubernetes-list-type": "atomic"
                                                }
                                              }
                                            },
                                            "x-kubernetes-list-type": "atomic"
                                          },
                                          "matchLabels": {
                                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "x-kubernetes-map-type": "atomic"
                                      },
                                      "matchLabelKeys": {
                                        "description": "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "mismatchLabelKeys": {
                                        "description": "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "namespaceSelector": {
                                        "description": "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.",
                                        "type": "object",
                                        "properties": {
                                          "matchExpressions": {
                                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                            "type": "array",
                                            "items": {
                                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                              "type": "object",
                                              "required": [
                                                "key",
                                                "operator"
                                              ],
                                              "properties": {
                                                "key": {
                                                  "description": "key is the label key that the selector applies to.",
                                                  "type": "string"
                                                },
                                                "operator": {
                                                  "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                                  "type": "string"
                                                },
                                                "values": {
                                                  "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                                  "type": "array",
                                                  "items": {
                                                    "type": "string"
                                                  },
                                                  "x-kubernetes-list-type": "atomic"
                                                }
                                              }
                                            },
                                            "x-kubernetes-list-type": "atomic"
                                          },
                                          "matchLabels": {
                                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                            "type": "object",
                                            "additionalProperties": {
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "x-kubernetes-map-type": "atomic"
                                      },
                                      "namespaces": {
                                        "description": "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".",
                                        "type": "array",
                                        "items": {
                                          "type": "string"
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "topologyKey": {
                                        "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "weight": {
                                    "description": "weight associated with matching the corresponding podAffinityTerm,\nin the range 1-100.",
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                }
                              },
                              "x-kubernetes-list-type": "atomic"
                            },
                            "requiredDuringSchedulingIgnoredDuringExecution": {
                              "description": "If the anti-affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to a pod label update), the\nsystem may or may not try to eventually evict the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.",
                              "type": "array",
                              "items": {
                                "description": "Defines a set of pods (namely those matching the labelSelector\nrelative to the given namespace(s)) that this pod should be\nco-located (affinity) or not co-located (anti-affinity) with,\nwhere co-located is defined as running on a node whose value of\nthe label with key <topologyKey> matches that of any node on which\na pod of the set of pods is running",
                                "type": "object",
                                "required": [
                                  "topologyKey"
                                ],
                                "properties": {
                                  "labelSelector": {
                                    "description": "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "matchLabelKeys": {
                                    "description": "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "mismatchLabelKeys": {
                                    "description": "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "namespaceSelector": {
                                    "description": "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "namespaces": {
                                    "description": "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "topologyKey": {
                                    "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.",
                                    "type": "string"
                                  }
                                }
                              },
                              "x-kubernetes-list-type": "atomic"
                            }
                          }
                        }
                      }
                    },
                    "nodeSelector": {
                      "description": "K8s node labels settings.\n\nSee https://kubernetes.io/docs/user-guide/node-selection/",
                      "type": "object",
                      "required": [
                        "nodeSelectorTerms"
                      ],
                      "properties": {
                        "nodeSelectorTerms": {
                          "description": "Required. A list of node selector terms. The terms are ORed.",
                          "type": "array",
                          "items": {
                            "description": "A null or empty node selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "A list of node selector requirements by node's labels.",
                                "type": "array",
                                "items": {
                                  "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "The label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                      "type": "string"
                                    },
                                    "values": {
                                      "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      },
                                      "x-kubernetes-list-type": "atomic"
                                    }
                                  }
                                },
                                "x-kubernetes-list-type": "atomic"
                              },
                              "matchFields": {
                                "description": "A list of node selector requirements by node's fields.",
                                "type": "array",
                                "items": {
                                  "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "The label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                      "type": "string"
                                    },
                                    "values": {
                                      "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      },
                                      "x-kubernetes-list-type": "atomic"
                                    }
                                  }
                                },
                                "x-kubernetes-list-type": "atomic"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "x-kubernetes-list-type": "atomic"
                        }
                      },
                      "x-kubernetes-map-type": "atomic"
                    },
                    "resources": {
                      "description": "K8s resource settings.\n\nSee https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container",
                      "type": "object",
                      "properties": {
                        "claims": {
                          "description": "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.",
                          "type": "array",
                          "items": {
                            "description": "ResourceClaim references one entry in PodSpec.ResourceClaims.",
                            "type": "object",
                            "required": [
                              "name"
                            ],
                            "properties": {
                              "name": {
                                "description": "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.",
                                "type": "string"
                              },
                              "request": {
                                "description": "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.",
                                "type": "string"
                              }
                            }
                          },
                          "x-kubernetes-list-map-keys": [
                            "name"
                          ],
                          "x-kubernetes-list-type": "map"
                        },
                        "limits": {
                          "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                          "type": "object",
                          "additionalProperties": {
                            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                            "x-kubernetes-int-or-string": true
                          }
                        },
                        "requests": {
                          "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                          "type": "object",
                          "additionalProperties": {
                            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                            "x-kubernetes-int-or-string": true
                          }
                        }
                      }
                    },
                    "toleration": {
                      "description": "K8s tolerations settings.\n\nSee https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/",
                      "type": "array",
                      "items": {
                        "description": "The pod this Toleration is attached to tolerates any taint that matches\nthe triple <key,value,effect> using the matching operator <operator>.",
                        "type": "object",
                        "properties": {
                          "effect": {
                            "description": "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                            "type": "string"
                          },
                          "key": {
                            "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.",
                            "type": "string"
                          },
                          "tolerationSeconds": {
                            "description": "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "value": {
                            "description": "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "topologySpreadConstraints": {
                      "description": "K8s topology spread constraints settings.\n\nSee https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/",
                      "type": "array",
                      "items": {
                        "description": "TopologySpreadConstraint specifies how to spread matching pods among the given topology.",
                        "type": "object",
                        "required": [
                          "maxSkew",
                          "topologyKey",
                          "whenUnsatisfiable"
                        ],
                        "properties": {
                          "labelSelector": {
                            "description": "LabelSelector is used to find matching pods.\nPods that match this label selector are counted to determine the number of pods\nin their corresponding topology domain.",
                            "type": "object",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "type": "array",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                  "type": "object",
                                  "required": [
                                    "key",
                                    "operator"
                                  ],
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string"
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                      "type": "array",
                                      "items": {
                                        "type": "string"
                                      },
                                      "x-kubernetes-list-type": "atomic"
                                    }
                                  }
                                },
                                "x-kubernetes-list-type": "atomic"
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "matchLabelKeys": {
                            "description": "MatchLabelKeys is a set of pod label keys to select the pods over which\nspreading will be calculated. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are ANDed with labelSelector\nto select the group of existing pods over which spreading will be calculated\nfor the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.\nMatchLabelKeys cannot be set when LabelSelector isn't set.\nKeys that don't exist in the incoming pod labels will\nbe ignored. A null or empty list means only match against labelSelector.\n\nThis is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "maxSkew": {
                            "description": "MaxSkew describes the degree to which pods may be unevenly distributed.\nWhen `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference\nbetween the number of matching pods in the target topology and the global minimum.\nThe global minimum is the minimum number of matching pods in an eligible domain\nor zero if the number of eligible domains is less than MinDomains.\nFor example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector spread as 2/2/1:\nIn this case, the global minimum is 1.\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |   P   |\n- if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;\nscheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)\nviolate MaxSkew(1).\n- if MaxSkew is 2, incoming pod can be scheduled onto any zone.\nWhen `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence\nto topologies that satisfy it.\nIt's a required field. Default value is 1 and 0 is not allowed.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "minDomains": {
                            "description": "MinDomains indicates a minimum number of eligible domains.\nWhen the number of eligible domains with matching topology keys is less than minDomains,\nPod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed.\nAnd when the number of eligible domains with matching topology keys equals or greater than minDomains,\nthis value has no effect on scheduling.\nAs a result, when the number of eligible domains is less than minDomains,\nscheduler won't schedule more than maxSkew Pods to those domains.\nIf value is nil, the constraint behaves as if MinDomains is equal to 1.\nValid values are integers greater than 0.\nWhen value is not nil, WhenUnsatisfiable must be DoNotSchedule.\n\nFor example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same\nlabelSelector spread as 2/2/2:\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |  P P  |\nThe number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0.\nIn this situation, new pod with the same labelSelector cannot be scheduled,\nbecause computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,\nit will violate MaxSkew.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "nodeAffinityPolicy": {
                            "description": "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector\nwhen calculating pod topology spread skew. Options are:\n- Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.\n- Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy.\nThis is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.",
                            "type": "string"
                          },
                          "nodeTaintsPolicy": {
                            "description": "NodeTaintsPolicy indicates how we will treat node taints when calculating\npod topology spread skew. Options are:\n- Honor: nodes without taints, along with tainted nodes for which the incoming pod\nhas a toleration, are included.\n- Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy.\nThis is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.",
                            "type": "string"
                          },
                          "topologyKey": {
                            "description": "TopologyKey is the key of node labels. Nodes that have a label with this key\nand identical values are considered to be in the same topology.\nWe consider each <key, value> as a \"bucket\", and try to put balanced number\nof pods into each bucket.\nWe define a domain as a particular instance of a topology.\nAlso, we define an eligible domain as a domain whose nodes meet the requirements of\nnodeAffinityPolicy and nodeTaintsPolicy.\ne.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology.\nAnd, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology.\nIt's a required field.",
                            "type": "string"
                          },
                          "whenUnsatisfiable": {
                            "description": "WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy\nthe spread constraint.\n- DoNotSchedule (default) tells the scheduler not to schedule it.\n- ScheduleAnyway tells the scheduler to schedule the pod in any location,\n  but giving higher precedence to topologies that would help reduce the\n  skew.\nA constraint is considered \"Unsatisfiable\" for an incoming pod\nif and only if every possible node assignment for that pod would violate\n\"MaxSkew\" on some topology.\nFor example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector spread as 3/1/1:\n| zone1 | zone2 | zone3 |\n| P P P |   P   |   P   |\nIf WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled\nto zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies\nMaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler\nwon't make it *more* imbalanced.\nIt's a required field.",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "istiodRemote": {
              "description": "Configuration for istiod-remote.\nDEPRECATED - istiod-remote chart is removed and replaced with\n`istio-discovery --set values.istiodRemote.enabled=true`\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
              "type": "object",
              "properties": {
                "enabled": {
                  "description": "Indicates if this cluster/install should consume a \"remote\" istiod instance,",
                  "type": "boolean"
                },
                "injectionCABundle": {
                  "description": "injector ca bundle",
                  "type": "string"
                },
                "injectionPath": {
                  "description": "Path to use for the sidecar injector webhook service.",
                  "type": "string"
                },
                "injectionURL": {
                  "description": "URL to use for sidecar injector webhook.",
                  "type": "string"
                }
              }
            },
            "meshConfig": {
              "description": "Defines runtime configuration of components, including Istiod and istio-agent behavior.\nSee https://istio.io/docs/reference/config/istio.mesh.v1alpha1/ for all available options.",
              "type": "object",
              "properties": {
                "accessLogEncoding": {
                  "description": "Encoding for the proxy access log (`TEXT` or `JSON`).\nDefault value is `TEXT`.",
                  "type": "string",
                  "enum": [
                    "TEXT",
                    "JSON"
                  ]
                },
                "accessLogFile": {
                  "description": "File address for the proxy access log (e.g. /dev/stdout).\nEmpty value disables access logging.",
                  "type": "string"
                },
                "accessLogFormat": {
                  "description": "Format for the proxy access log\nEmpty value results in proxy's default access log format",
                  "type": "string"
                },
                "ca": {
                  "description": "If specified, Istiod will authorize and forward the CSRs from the workloads to the specified external CA\nusing the Istio CA gRPC API.",
                  "type": "object",
                  "required": [
                    "address"
                  ],
                  "properties": {
                    "address": {
                      "description": "REQUIRED. Address of the CA server implementing the Istio CA gRPC API.\nCan be IP address or a fully qualified DNS name with port\nEg: custom-ca.default.svc.cluster.local:8932, 192.168.23.2:9000",
                      "type": "string"
                    },
                    "istiodSide": {
                      "description": "Use istiodSide to specify CA Server integrate to Istiod side or Agent side\nDefault: true",
                      "type": "boolean"
                    },
                    "requestTimeout": {
                      "description": "timeout for forward CSR requests from Istiod to External CA\nDefault: 10s",
                      "type": "string"
                    },
                    "tlsSettings": {
                      "description": "Use the tlsSettings to specify the tls mode to use.\nRegarding tlsSettings:\n- DISABLE MODE is legitimate for the case Istiod is making the request via an Envoy sidecar.\nDISABLE MODE can also be used for testing\n- TLS MUTUAL MODE be on by default. If the CA certificates\n(cert bundle to verify the CA server's certificate) is omitted, Istiod will\nuse the system root certs to verify the CA server's certificate.",
                      "type": "object",
                      "properties": {
                        "caCertificates": {
                          "description": "OPTIONAL: The path to the file containing certificate authority\ncertificates to use in verifying a presented server certificate. If\nomitted, the proxy will verify the server's certificate using\nthe OS CA certificates.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                          "type": "string"
                        },
                        "caCrl": {
                          "description": "OPTIONAL: The path to the file containing the certificate revocation list (CRL)\nto use in verifying a presented server certificate. `CRL` is a list of certificates\nthat have been revoked by the CA (Certificate Authority) before their scheduled expiration date.\nIf specified, the proxy will verify if the presented certificate is part of the revoked list of certificates.\nIf omitted, the proxy will not verify the certificate against the `crl`. Note that if `credentialName` is set,\n`CRL` cannot be specified using `caCrl`, rather it has to be specified inside the credential.",
                          "type": "string"
                        },
                        "clientCertificate": {
                          "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient-side TLS certificate to use.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                          "type": "string"
                        },
                        "credentialName": {
                          "description": "The name of the secret that holds the TLS certs for the\nclient including the CA certificates. This secret must exist in\nthe namespace of the proxy using the certificates.\nAn Opaque secret should contain the following keys and values:\n`key: <privateKey>`, `cert: <clientCert>`, `cacert: <CACertificate>`,\n`crl: <certificateRevocationList>`\nHere CACertificate is used to verify the server certificate.\nFor mutual TLS, `cacert: <CACertificate>` can be provided in the\nsame secret or a separate secret named `<secret>-cacert`.\nA TLS secret for client certificates with an additional\n`ca.crt` key for CA certificates and `ca.crl` key for\ncertificate revocation list(CRL) is also supported.\nOnly one of client certificates and CA certificate\nor credentialName can be specified.\n\n**NOTE:** This field is applicable at sidecars only if\n`DestinationRule` has a `workloadSelector` specified.\nOtherwise the field will be applicable only at gateways, and\nsidecars will continue to use the certificate paths.",
                          "type": "string"
                        },
                        "insecureSkipVerify": {
                          "description": "`insecureSkipVerify` specifies whether the proxy should skip verifying the\nCA signature and SAN for the server certificate corresponding to the host.\nThe default value of this field is false.",
                          "type": "boolean"
                        },
                        "mode": {
                          "description": "Indicates whether connections to this port should be secured\nusing TLS. The value of this field determines how TLS is enforced.",
                          "type": "string",
                          "enum": [
                            "DISABLE",
                            "SIMPLE",
                            "MUTUAL",
                            "ISTIO_MUTUAL"
                          ]
                        },
                        "privateKey": {
                          "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient's private key.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                          "type": "string"
                        },
                        "sni": {
                          "description": "SNI string to present to the server during TLS handshake.\nIf unspecified, SNI will be automatically set based on downstream HTTP\nhost/authority header for SIMPLE and MUTUAL TLS modes.",
                          "type": "string"
                        },
                        "subjectAltNames": {
                          "description": "A list of alternate names to verify the subject identity in the\ncertificate. If specified, the proxy will verify that the server\ncertificate's subject alt name matches one of the specified values.\nIf specified, this list overrides the value of `subjectAltNames`\nfrom the `ServiceEntry`. If unspecified, automatic validation of upstream\npresented certificate for new upstream connections will be done based on the\ndownstream HTTP host/authority header.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "caCertificates": {
                  "description": "The extra root certificates for workload-to-workload communication.\nThe plugin certificates (the 'cacerts' secret) or self-signed certificates (the 'istio-ca-secret' secret)\nare automatically added by Istiod.\nThe CA certificate that signs the workload certificates is automatically added by Istio Agent.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "certSigners": {
                        "description": "when Istiod is acting as RA(registration authority)\nIf set, they are used for these signers. Otherwise, this trustAnchor is used for all signers.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "pem": {
                        "description": "The PEM data of the certificate.",
                        "type": "string"
                      },
                      "spiffeBundleUrl": {
                        "description": "The SPIFFE bundle endpoint URL that complies to:\nhttps://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#the-spiffe-trust-domain-and-bundle\nThe endpoint should support authentication based on Web PKI:\nhttps://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#521-web-pki\nThe certificate is retrieved from the endpoint.",
                        "type": "string"
                      },
                      "trustDomains": {
                        "description": "Optional. Specify the list of trust domains to which this trustAnchor data belongs.\nIf set, they are used for these trust domains. Otherwise, this trustAnchor is used for default trust domain\nand its aliases.\nNote that we can have multiple trustAnchor data for a same trustDomain.\nIn that case, trustAnchors with a same trust domain will be merged and used together to verify peer certificates.\nIf neither certSigners nor trustDomains is set, this trustAnchor is used for all trust domains and all signers.\nIf only trustDomains is set, this trustAnchor is used for these trustDomains and all signers.\nIf only certSigners is set, this trustAnchor is used for these certSigners and all trust domains.\nIf both certSigners and trustDomains is set, this trustAnchor is only used for these signers and trust domains.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    },
                    "x-kubernetes-validations": [
                      {
                        "message": "At most one of [pem spiffeBundleUrl] should be set",
                        "rule": "(has(self.pem)?1:0) + (has(self.spiffeBundleUrl)?1:0) <= 1"
                      }
                    ]
                  }
                },
                "certificates": {
                  "description": "Configure the provision of certificates.\n\nNote: Deprecated, please refer to Cert-Manager or other cert provisioning solutions to sign DNS certificates.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                  "type": "array",
                  "items": {
                    "description": "Certificate configures the provision of a certificate and its key.\nExample 1: key and cert stored in a secret\n```\n{ secretName: galley-cert\n\n\t  secretNamespace: istio-system\n\t  dnsNames:\n\t    - galley.istio-system.svc\n\t    - galley.mydomain.com\n\t}\n\n```\nExample 2: key and cert stored in a directory\n```\n{ dnsNames:\n  - pilot.istio-system\n  - pilot.istio-system.svc\n  - pilot.mydomain.com\n    }\n\n```",
                    "type": "object",
                    "properties": {
                      "dnsNames": {
                        "description": "The DNS names for the certificate. A certificate may contain\nmultiple DNS names.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "secretName": {
                        "description": "Name of the secret the certificate and its key will be stored into.\nIf it is empty, it will not be stored into a secret.\nInstead, the certificate and its key will be stored into a hard-coded directory.",
                        "type": "string"
                      }
                    }
                  }
                },
                "configSources": {
                  "description": "ConfigSource describes a source of configuration data for networking\nrules, and other Istio configuration artifacts. Multiple data sources\ncan be configured for a single control plane.",
                  "type": "array",
                  "items": {
                    "description": "ConfigSource describes information about a configuration store inside a\nmesh. A single control plane instance can interact with one or more data\nsources.",
                    "type": "object",
                    "properties": {
                      "address": {
                        "description": "Address of the server implementing the Istio Mesh Configuration\nprotocol (MCP). Can be IP address or a fully qualified DNS name.\nUse xds:// to specify a grpc-based xds backend, k8s:// to specify a k8s controller or\nfs:/// to specify a file-based backend with absolute path to the directory.",
                        "type": "string"
                      },
                      "subscribedResources": {
                        "description": "Describes the source of configuration, if nothing is specified default is MCP",
                        "type": "array",
                        "items": {
                          "description": "Resource describes the source of configuration",
                          "type": "string",
                          "enum": [
                            "SERVICE_REGISTRY"
                          ]
                        }
                      },
                      "tlsSettings": {
                        "description": "Use the tlsSettings to specify the tls mode to use. If the MCP server\nuses Istio mutual TLS and shares the root CA with istiod, specify the TLS\nmode as `ISTIO_MUTUAL`.",
                        "type": "object",
                        "properties": {
                          "caCertificates": {
                            "description": "OPTIONAL: The path to the file containing certificate authority\ncertificates to use in verifying a presented server certificate. If\nomitted, the proxy will verify the server's certificate using\nthe OS CA certificates.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                            "type": "string"
                          },
                          "caCrl": {
                            "description": "OPTIONAL: The path to the file containing the certificate revocation list (CRL)\nto use in verifying a presented server certificate. `CRL` is a list of certificates\nthat have been revoked by the CA (Certificate Authority) before their scheduled expiration date.\nIf specified, the proxy will verify if the presented certificate is part of the revoked list of certificates.\nIf omitted, the proxy will not verify the certificate against the `crl`. Note that if `credentialName` is set,\n`CRL` cannot be specified using `caCrl`, rather it has to be specified inside the credential.",
                            "type": "string"
                          },
                          "clientCertificate": {
                            "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient-side TLS certificate to use.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                            "type": "string"
                          },
                          "credentialName": {
                            "description": "The name of the secret that holds the TLS certs for the\nclient including the CA certificates. This secret must exist in\nthe namespace of the proxy using the certificates.\nAn Opaque secret should contain the following keys and values:\n`key: <privateKey>`, `cert: <clientCert>`, `cacert: <CACertificate>`,\n`crl: <certificateRevocationList>`\nHere CACertificate is used to verify the server certificate.\nFor mutual TLS, `cacert: <CACertificate>` can be provided in the\nsame secret or a separate secret named `<secret>-cacert`.\nA TLS secret for client certificates with an additional\n`ca.crt` key for CA certificates and `ca.crl` key for\ncertificate revocation list(CRL) is also supported.\nOnly one of client certificates and CA certificate\nor credentialName can be specified.\n\n**NOTE:** This field is applicable at sidecars only if\n`DestinationRule` has a `workloadSelector` specified.\nOtherwise the field will be applicable only at gateways, and\nsidecars will continue to use the certificate paths.",
                            "type": "string"
                          },
                          "insecureSkipVerify": {
                            "description": "`insecureSkipVerify` specifies whether the proxy should skip verifying the\nCA signature and SAN for the server certificate corresponding to the host.\nThe default value of this field is false.",
                            "type": "boolean"
                          },
                          "mode": {
                            "description": "Indicates whether connections to this port should be secured\nusing TLS. The value of this field determines how TLS is enforced.",
                            "type": "string",
                            "enum": [
                              "DISABLE",
                              "SIMPLE",
                              "MUTUAL",
                              "ISTIO_MUTUAL"
                            ]
                          },
                          "privateKey": {
                            "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient's private key.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                            "type": "string"
                          },
                          "sni": {
                            "description": "SNI string to present to the server during TLS handshake.\nIf unspecified, SNI will be automatically set based on downstream HTTP\nhost/authority header for SIMPLE and MUTUAL TLS modes.",
                            "type": "string"
                          },
                          "subjectAltNames": {
                            "description": "A list of alternate names to verify the subject identity in the\ncertificate. If specified, the proxy will verify that the server\ncertificate's subject alt name matches one of the specified values.\nIf specified, this list overrides the value of `subjectAltNames`\nfrom the `ServiceEntry`. If unspecified, automatic validation of upstream\npresented certificate for new upstream connections will be done based on the\ndownstream HTTP host/authority header.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "connectTimeout": {
                  "description": "Connection timeout used by Envoy. (MUST be >=1ms)\nDefault timeout is 10s.",
                  "type": "string"
                },
                "defaultConfig": {
                  "description": "Default proxy config used by gateway and sidecars.\nIn case of Kubernetes, the proxy config is applied once during the injection process,\nand remain constant for the duration of the pod. The rest of the mesh config can be changed\nat runtime and config gets distributed dynamically.\nOn Kubernetes, this can be overridden on individual pods with the `proxy.istio.io/config` annotation.",
                  "type": "object",
                  "properties": {
                    "availabilityZone": {
                      "description": "Deprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.",
                      "type": "string"
                    },
                    "binaryPath": {
                      "description": "Path to the proxy binary",
                      "type": "string"
                    },
                    "caCertificatesPem": {
                      "description": "The PEM data of the extra root certificates for workload-to-workload communication.\nThis includes the certificates defined in MeshConfig and any other certificates that Istiod uses as CA.\nThe plugin certificates (the 'cacerts' secret), self-signed certificates (the 'istio-ca-secret' secret)\nare added automatically by Istiod.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "concurrency": {
                      "description": "The number of worker threads to run.\nIf unset, which is recommended, this will be automatically determined based on CPU requests/limits.\nIf set to 0, all cores on the machine will be used, ignoring CPU requests or limits. This can lead to major performance\nissues if CPU limits are also set.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "configPath": {
                      "description": "Path to the generated configuration file directory.\nProxy agent generates the actual configuration and stores it in this directory.",
                      "type": "string"
                    },
                    "controlPlaneAuthPolicy": {
                      "description": "AuthenticationPolicy defines how the proxy is authenticated when it connects to the control plane.\nDefault is set to `MUTUAL_TLS`.",
                      "type": "string",
                      "enum": [
                        "NONE",
                        "MUTUAL_TLS",
                        "INHERIT"
                      ]
                    },
                    "customConfigFile": {
                      "description": "File path of custom proxy configuration, currently used by proxies\nin front of istiod.",
                      "type": "string"
                    },
                    "discoveryAddress": {
                      "description": "Address of the discovery service exposing xDS with mTLS connection.\nThe inject configuration may override this value.",
                      "type": "string"
                    },
                    "discoveryRefreshDelay": {
                      "description": "Deprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.",
                      "type": "string"
                    },
                    "drainDuration": {
                      "description": "restart. MUST be >=1s (e.g., _1s/1m/1h_)\nDefault drain duration is `45s`.",
                      "type": "string"
                    },
                    "envoyAccessLogService": {
                      "description": "Address of the service to which access logs from Envoys should be\nsent. (e.g. `accesslog-service:15000`). See [Access Log\nService](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/accesslog/v2/als.proto)\nfor details about Envoy's gRPC Access Log Service API.",
                      "type": "object",
                      "properties": {
                        "address": {
                          "description": "Address of a remove service used for various purposes (access log\nreceiver, metrics receiver, etc.). Can be IP address or a fully\nqualified DNS name.",
                          "type": "string"
                        },
                        "tcpKeepalive": {
                          "description": "If set then set `SO_KEEPALIVE` on the socket to enable TCP Keepalives.",
                          "type": "object",
                          "properties": {
                            "interval": {
                              "description": "The time duration between keep-alive probes.\nDefault is to use the OS level configuration\n(unless overridden, Linux defaults to 75s.)",
                              "type": "string"
                            },
                            "probes": {
                              "description": "Maximum number of keepalive probes to send without response before\ndeciding the connection is dead. Default is to use the OS level configuration\n(unless overridden, Linux defaults to 9.)",
                              "type": "integer",
                              "format": "int32"
                            },
                            "time": {
                              "description": "The time duration a connection needs to be idle before keep-alive\nprobes start being sent. Default is to use the OS level configuration\n(unless overridden, Linux defaults to 7200s (ie 2 hours.)",
                              "type": "string"
                            }
                          }
                        },
                        "tlsSettings": {
                          "description": "Use the `tlsSettings` to specify the tls mode to use. If the remote service\nuses Istio mutual TLS and shares the root CA with istiod, specify the TLS\nmode as `ISTIO_MUTUAL`.",
                          "type": "object",
                          "properties": {
                            "caCertificates": {
                              "description": "OPTIONAL: The path to the file containing certificate authority\ncertificates to use in verifying a presented server certificate. If\nomitted, the proxy will verify the server's certificate using\nthe OS CA certificates.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "caCrl": {
                              "description": "OPTIONAL: The path to the file containing the certificate revocation list (CRL)\nto use in verifying a presented server certificate. `CRL` is a list of certificates\nthat have been revoked by the CA (Certificate Authority) before their scheduled expiration date.\nIf specified, the proxy will verify if the presented certificate is part of the revoked list of certificates.\nIf omitted, the proxy will not verify the certificate against the `crl`. Note that if `credentialName` is set,\n`CRL` cannot be specified using `caCrl`, rather it has to be specified inside the credential.",
                              "type": "string"
                            },
                            "clientCertificate": {
                              "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient-side TLS certificate to use.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "credentialName": {
                              "description": "The name of the secret that holds the TLS certs for the\nclient including the CA certificates. This secret must exist in\nthe namespace of the proxy using the certificates.\nAn Opaque secret should contain the following keys and values:\n`key: <privateKey>`, `cert: <clientCert>`, `cacert: <CACertificate>`,\n`crl: <certificateRevocationList>`\nHere CACertificate is used to verify the server certificate.\nFor mutual TLS, `cacert: <CACertificate>` can be provided in the\nsame secret or a separate secret named `<secret>-cacert`.\nA TLS secret for client certificates with an additional\n`ca.crt` key for CA certificates and `ca.crl` key for\ncertificate revocation list(CRL) is also supported.\nOnly one of client certificates and CA certificate\nor credentialName can be specified.\n\n**NOTE:** This field is applicable at sidecars only if\n`DestinationRule` has a `workloadSelector` specified.\nOtherwise the field will be applicable only at gateways, and\nsidecars will continue to use the certificate paths.",
                              "type": "string"
                            },
                            "insecureSkipVerify": {
                              "description": "`insecureSkipVerify` specifies whether the proxy should skip verifying the\nCA signature and SAN for the server certificate corresponding to the host.\nThe default value of this field is false.",
                              "type": "boolean"
                            },
                            "mode": {
                              "description": "Indicates whether connections to this port should be secured\nusing TLS. The value of this field determines how TLS is enforced.",
                              "type": "string",
                              "enum": [
                                "DISABLE",
                                "SIMPLE",
                                "MUTUAL",
                                "ISTIO_MUTUAL"
                              ]
                            },
                            "privateKey": {
                              "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient's private key.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "sni": {
                              "description": "SNI string to present to the server during TLS handshake.\nIf unspecified, SNI will be automatically set based on downstream HTTP\nhost/authority header for SIMPLE and MUTUAL TLS modes.",
                              "type": "string"
                            },
                            "subjectAltNames": {
                              "description": "A list of alternate names to verify the subject identity in the\ncertificate. If specified, the proxy will verify that the server\ncertificate's subject alt name matches one of the specified values.\nIf specified, this list overrides the value of `subjectAltNames`\nfrom the `ServiceEntry`. If unspecified, automatic validation of upstream\npresented certificate for new upstream connections will be done based on the\ndownstream HTTP host/authority header.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "envoyMetricsService": {
                      "description": "Address of the Envoy Metrics Service implementation (e.g. `metrics-service:15000`).\nSee [Metric Service](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/metrics_service.proto)\nfor details about Envoy's Metrics Service API.",
                      "type": "object",
                      "properties": {
                        "address": {
                          "description": "Address of a remove service used for various purposes (access log\nreceiver, metrics receiver, etc.). Can be IP address or a fully\nqualified DNS name.",
                          "type": "string"
                        },
                        "tcpKeepalive": {
                          "description": "If set then set `SO_KEEPALIVE` on the socket to enable TCP Keepalives.",
                          "type": "object",
                          "properties": {
                            "interval": {
                              "description": "The time duration between keep-alive probes.\nDefault is to use the OS level configuration\n(unless overridden, Linux defaults to 75s.)",
                              "type": "string"
                            },
                            "probes": {
                              "description": "Maximum number of keepalive probes to send without response before\ndeciding the connection is dead. Default is to use the OS level configuration\n(unless overridden, Linux defaults to 9.)",
                              "type": "integer",
                              "format": "int32"
                            },
                            "time": {
                              "description": "The time duration a connection needs to be idle before keep-alive\nprobes start being sent. Default is to use the OS level configuration\n(unless overridden, Linux defaults to 7200s (ie 2 hours.)",
                              "type": "string"
                            }
                          }
                        },
                        "tlsSettings": {
                          "description": "Use the `tlsSettings` to specify the tls mode to use. If the remote service\nuses Istio mutual TLS and shares the root CA with istiod, specify the TLS\nmode as `ISTIO_MUTUAL`.",
                          "type": "object",
                          "properties": {
                            "caCertificates": {
                              "description": "OPTIONAL: The path to the file containing certificate authority\ncertificates to use in verifying a presented server certificate. If\nomitted, the proxy will verify the server's certificate using\nthe OS CA certificates.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "caCrl": {
                              "description": "OPTIONAL: The path to the file containing the certificate revocation list (CRL)\nto use in verifying a presented server certificate. `CRL` is a list of certificates\nthat have been revoked by the CA (Certificate Authority) before their scheduled expiration date.\nIf specified, the proxy will verify if the presented certificate is part of the revoked list of certificates.\nIf omitted, the proxy will not verify the certificate against the `crl`. Note that if `credentialName` is set,\n`CRL` cannot be specified using `caCrl`, rather it has to be specified inside the credential.",
                              "type": "string"
                            },
                            "clientCertificate": {
                              "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient-side TLS certificate to use.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "credentialName": {
                              "description": "The name of the secret that holds the TLS certs for the\nclient including the CA certificates. This secret must exist in\nthe namespace of the proxy using the certificates.\nAn Opaque secret should contain the following keys and values:\n`key: <privateKey>`, `cert: <clientCert>`, `cacert: <CACertificate>`,\n`crl: <certificateRevocationList>`\nHere CACertificate is used to verify the server certificate.\nFor mutual TLS, `cacert: <CACertificate>` can be provided in the\nsame secret or a separate secret named `<secret>-cacert`.\nA TLS secret for client certificates with an additional\n`ca.crt` key for CA certificates and `ca.crl` key for\ncertificate revocation list(CRL) is also supported.\nOnly one of client certificates and CA certificate\nor credentialName can be specified.\n\n**NOTE:** This field is applicable at sidecars only if\n`DestinationRule` has a `workloadSelector` specified.\nOtherwise the field will be applicable only at gateways, and\nsidecars will continue to use the certificate paths.",
                              "type": "string"
                            },
                            "insecureSkipVerify": {
                              "description": "`insecureSkipVerify` specifies whether the proxy should skip verifying the\nCA signature and SAN for the server certificate corresponding to the host.\nThe default value of this field is false.",
                              "type": "boolean"
                            },
                            "mode": {
                              "description": "Indicates whether connections to this port should be secured\nusing TLS. The value of this field determines how TLS is enforced.",
                              "type": "string",
                              "enum": [
                                "DISABLE",
                                "SIMPLE",
                                "MUTUAL",
                                "ISTIO_MUTUAL"
                              ]
                            },
                            "privateKey": {
                              "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient's private key.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "sni": {
                              "description": "SNI string to present to the server during TLS handshake.\nIf unspecified, SNI will be automatically set based on downstream HTTP\nhost/authority header for SIMPLE and MUTUAL TLS modes.",
                              "type": "string"
                            },
                            "subjectAltNames": {
                              "description": "A list of alternate names to verify the subject identity in the\ncertificate. If specified, the proxy will verify that the server\ncertificate's subject alt name matches one of the specified values.\nIf specified, this list overrides the value of `subjectAltNames`\nfrom the `ServiceEntry`. If unspecified, automatic validation of upstream\npresented certificate for new upstream connections will be done based on the\ndownstream HTTP host/authority header.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "envoyMetricsServiceAddress": {
                      "description": "Deprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.",
                      "type": "string"
                    },
                    "extraStatTags": {
                      "description": "An additional list of tags to extract from the in-proxy Istio telemetry. These extra tags can be\nadded by configuring the telemetry extension. Each additional tag needs to be present in this list.\nExtra tags emitted by the telemetry extensions must be listed here so that they can be processed\nand exposed as Prometheus metrics.\nDeprecated: `istio.stats` is a native filter now, this field is no longer needed.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "gatewayTopology": {
                      "description": "Topology encapsulates the configuration which describes where the proxy is\nlocated i.e. behind a (or N) trusted proxy (proxies) or directly exposed\nto the internet. This configuration only effects gateways and is applied\nto all the gateways in the cluster unless overridden via annotations of the\ngateway workloads.",
                      "type": "object",
                      "properties": {
                        "forwardClientCertDetails": {
                          "description": "Configures how the gateway proxy handles x-forwarded-client-cert (XFCC)\nheader in the incoming request.",
                          "type": "string",
                          "enum": [
                            "UNDEFINED",
                            "SANITIZE",
                            "FORWARD_ONLY",
                            "APPEND_FORWARD",
                            "SANITIZE_SET",
                            "ALWAYS_FORWARD_ONLY"
                          ]
                        },
                        "numTrustedProxies": {
                          "description": "Number of trusted proxies deployed in front of the Istio gateway proxy.\nWhen this option is set to value N greater than zero, the trusted client\naddress is assumed to be the Nth address from the right end of the\nX-Forwarded-For (XFF) header from the incoming request. If the\nX-Forwarded-For (XFF) header is missing or has fewer than N addresses, the\ngateway proxy falls back to using the immediate downstream connection's\nsource address as the trusted client address.\nNote that the gateway proxy will append the downstream connection's source\naddress to the X-Forwarded-For (XFF) address and set the\nX-Envoy-External-Address header to the trusted client address before\nforwarding it to the upstream services in the cluster.\nThe default value of numTrustedProxies is 0.\nSee [Envoy XFF](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#config-http-conn-man-headers-x-forwarded-for)\nheader handling for more details.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "proxyProtocol": {
                          "description": "Enables [PROXY protocol](http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt) for\ndownstream connections on a gateway.",
                          "type": "object"
                        }
                      }
                    },
                    "holdApplicationUntilProxyStarts": {
                      "description": "Boolean flag for enabling/disabling the holdApplicationUntilProxyStarts behavior.\nThis feature adds hooks to delay application startup until the pod proxy\nis ready to accept traffic, mitigating some startup race conditions.\nDefault value is 'false'.",
                      "type": "boolean"
                    },
                    "image": {
                      "description": "Specifies the details of the proxy image.",
                      "type": "object",
                      "properties": {
                        "imageType": {
                          "description": "The image type of the image.\nIstio publishes default, debug, and distroless images.\nOther values are allowed if those image types (example: centos) are published to the specified hub.\nsupported values: default, debug, distroless.",
                          "type": "string"
                        }
                      }
                    },
                    "interceptionMode": {
                      "description": "The mode used to redirect inbound traffic to Envoy.",
                      "type": "string",
                      "enum": [
                        "REDIRECT",
                        "TPROXY",
                        "NONE"
                      ]
                    },
                    "meshId": {
                      "description": "The unique identifier for the [service mesh](https://istio.io/docs/reference/glossary/#service-mesh)\nAll control planes running in the same service mesh should specify the same mesh ID.\nMesh ID is used to label telemetry reports for cases where telemetry from multiple meshes is mixed together.",
                      "type": "string"
                    },
                    "privateKeyProvider": {
                      "description": "Specifies the details of the Private Key Provider configuration for gateway and sidecar proxies.",
                      "type": "object",
                      "properties": {
                        "cryptomb": {
                          "description": "Use CryptoMb private key provider",
                          "type": "object",
                          "properties": {
                            "fallback": {
                              "description": "If the private key provider isn\u2019t available (eg. the required hardware capability doesn\u2019t existed)\nEnvoy will fallback to the BoringSSL default implementation when the fallback is true.\nThe default value is false.",
                              "type": "boolean"
                            },
                            "pollDelay": {
                              "description": "How long to wait until the per-thread processing queue should be processed. If the processing queue\ngets full (eight sign or decrypt requests are received) it is processed immediately.\nHowever, if the queue is not filled before the delay has expired, the requests already in the queue\nare processed, even if the queue is not full.\nIn effect, this value controls the balance between latency and throughput.\nThe duration needs to be set to a value greater than or equal to 1 millisecond.",
                              "type": "string"
                            }
                          }
                        },
                        "qat": {
                          "description": "Use QAT private key provider",
                          "type": "object",
                          "properties": {
                            "fallback": {
                              "description": "If the private key provider isn\u2019t available (eg. the required hardware capability doesn\u2019t existed)\nEnvoy will fallback to the BoringSSL default implementation when the fallback is true.\nThe default value is false.",
                              "type": "boolean"
                            },
                            "pollDelay": {
                              "description": "How long to wait before polling the hardware accelerator after a request has been submitted there.\nHaving a small value leads to quicker answers from the hardware but causes more polling loop spins,\nleading to potentially larger CPU usage.\nThe duration needs to be set to a value greater than or equal to 1 millisecond.",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "x-kubernetes-validations": [
                        {
                          "message": "At most one of [cryptomb qat] should be set",
                          "rule": "(has(self.cryptomb)?1:0) + (has(self.qat)?1:0) <= 1"
                        }
                      ]
                    },
                    "proxyAdminPort": {
                      "description": "Port on which Envoy should listen for administrative commands.\nDefault port is `15000`.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "proxyBootstrapTemplatePath": {
                      "description": "Path to the proxy bootstrap template file",
                      "type": "string"
                    },
                    "proxyHeaders": {
                      "description": "Define the set of headers to add/modify for HTTP request/responses.\n\nTo enable an optional header, simply set the field. If no specific configuration is required, an empty object (`{}`) will enable it.\nNote: currently all headers are enabled by default.\n\nBelow shows an example of customizing the `server` header and disabling the `X-Envoy-Attempt-Count` header:\n\n```yaml\nproxyHeaders:\n\n\tserver:\n\t  value: \"my-custom-server\"\n\t# Explicitly enable Request IDs.\n\t# As this is the default, this has no effect.\n\trequestId: {}\n\tattemptCount:\n\t  disabled: true\n\n```\n\nSome headers are enabled by default, and require explicitly disabling. See below for an example of disabling all default-enabled headers:\n\n```yaml\nproxyHeaders:\n\n\tforwardedClientCert: SANITIZE\n\tserver:\n\t  disabled: true\n\trequestId:\n\t  disabled: true\n\tattemptCount:\n\t  disabled: true\n\tenvoyDebugHeaders:\n\t  disabled: true\n\tmetadataExchangeHeaders:\n\t  mode: IN_MESH\n\n```",
                      "type": "object",
                      "properties": {
                        "attemptCount": {
                          "description": "Controls the `X-Envoy-Attempt-Count` header.\nIf enabled, this header will be added on outbound request headers (including gateways) that have retries configured.\nIf disabled, this header will not be set. If it is already present, it will be preserved.\nThis header is enabled by default if not configured.",
                          "type": "object",
                          "properties": {
                            "disabled": {
                              "type": "boolean"
                            }
                          }
                        },
                        "envoyDebugHeaders": {
                          "description": "Controls various `X-Envoy-*` headers, such as `X-Envoy-Overloaded` and `X-Envoy-Upstream-Service-Time`. If enabled,\nthese headers will be included.\nIf disabled, these headers will not be set. If they are already present, they will be preserved.\nSee the [Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/router/v3/router.proto#envoy-v3-api-field-extensions-filters-http-router-v3-router-suppress-envoy-headers) for more details.\nThese headers are enabled by default if not configured.",
                          "type": "object",
                          "properties": {
                            "disabled": {
                              "type": "boolean"
                            }
                          }
                        },
                        "forwardedClientCert": {
                          "description": "Controls the `X-Forwarded-Client-Cert` header for inbound sidecar requests. To set this on gateways, use the `Topology` setting.\nTo disable the header, configure either `SANITIZE` (to always remove the header, if present) or `FORWARD_ONLY` (to leave the header as-is).\nBy default, `APPEND_FORWARD` will be used.",
                          "type": "string",
                          "enum": [
                            "UNDEFINED",
                            "SANITIZE",
                            "FORWARD_ONLY",
                            "APPEND_FORWARD",
                            "SANITIZE_SET",
                            "ALWAYS_FORWARD_ONLY"
                          ]
                        },
                        "metadataExchangeHeaders": {
                          "description": "Controls Istio metadata exchange headers `X-Envoy-Peer-Metadata` and `X-Envoy-Peer-Metadata-Id`.\nBy default, the behavior is unspecified.\nIf IN_MESH, these headers will not be appended to outbound requests from sidecars to services not in-mesh.",
                          "type": "object",
                          "properties": {
                            "mode": {
                              "type": "string",
                              "enum": [
                                "UNDEFINED",
                                "IN_MESH"
                              ]
                            }
                          }
                        },
                        "requestId": {
                          "description": "Controls the `X-Request-Id` header. If enabled, a request ID is generated for each request if one is not already set.\nThis applies to all types of traffic (inbound, outbound, and gateways).\nIf disabled, no request ID will be generate for the request. If it is already present, it will be preserved.\nWarning: request IDs are a critical component to mesh tracing and logging, so disabling this is not recommended.\nThis header is enabled by default if not configured.",
                          "type": "object",
                          "properties": {
                            "disabled": {
                              "type": "boolean"
                            }
                          }
                        },
                        "server": {
                          "description": "Controls the `server` header. If enabled, the `Server: istio-envoy` header is set in response headers for inbound traffic (including gateways).\nIf disabled, the `Server` header is not modified. If it is already present, it will be preserved.",
                          "type": "object",
                          "properties": {
                            "disabled": {
                              "type": "boolean"
                            },
                            "value": {
                              "description": "If set, and the server header is enabled, this value will be set as the server header. By default, `istio-envoy` will be used.",
                              "type": "string"
                            }
                          }
                        },
                        "setCurrentClientCertDetails": {
                          "description": "This field is valid only when forward_client_cert_details is APPEND_FORWARD or SANITIZE_SET\nand the client connection is mTLS. It specifies the fields in\nthe client certificate to be forwarded. Note that `Hash` is always set, and\n`By` is always set when the client certificate presents the URI type Subject Alternative Name value.",
                          "type": "object",
                          "properties": {
                            "cert": {
                              "description": "Whether to forward the entire client cert in URL encoded PEM format. This will appear in the\nXFCC header comma separated from other values with the value Cert=\"PEM\".\nDefaults to false.",
                              "type": "boolean"
                            },
                            "chain": {
                              "description": "Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM\nformat. This will appear in the XFCC header comma separated from other values with the value\nChain=\"PEM\".\nDefaults to false.",
                              "type": "boolean"
                            },
                            "dns": {
                              "description": "Whether to forward the DNS type Subject Alternative Names of the client cert.\nDefaults to true.",
                              "type": "boolean"
                            },
                            "subject": {
                              "description": "Whether to forward the subject of the client cert. Defaults to true.",
                              "type": "boolean"
                            },
                            "uri": {
                              "description": "Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to\ntrue.",
                              "type": "boolean"
                            }
                          }
                        }
                      }
                    },
                    "proxyMetadata": {
                      "description": "Additional environment variables for the proxy.\nNames starting with `ISTIO_META_` will be included in the generated bootstrap and sent to the XDS server.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "proxyStatsMatcher": {
                      "description": "Proxy stats matcher defines configuration for reporting custom Envoy stats.\nTo reduce memory and CPU overhead from Envoy stats system, Istio proxies by\ndefault create and expose only a subset of Envoy stats. This option is to\ncontrol creation of additional Envoy stats with prefix, suffix, and regex\nexpressions match on the name of the stats. This replaces the stats\ninclusion annotations\n(`sidecar.istio.io/statsInclusionPrefixes`,\n`sidecar.istio.io/statsInclusionRegexps`, and\n`sidecar.istio.io/statsInclusionSuffixes`). For example, to enable stats\nfor circuit breakers, request retries, upstream connections, and request timeouts,\nyou can specify stats matcher as follows:\n```yaml\nproxyStatsMatcher:\n\n\tinclusionRegexps:\n\t  - .*outlier_detection.*\n\t  - .*upstream_rq_retry.*\n\t  - .*upstream_cx_.*\n\tinclusionSuffixes:\n\t  - upstream_rq_timeout\n\n```\nNote including more Envoy stats might increase number of time series\ncollected by prometheus significantly. Care needs to be taken on Prometheus\nresource provision and configuration to reduce cardinality.",
                      "type": "object",
                      "properties": {
                        "inclusionPrefixes": {
                          "description": "Proxy stats name prefix matcher for inclusion.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "inclusionRegexps": {
                          "description": "Proxy stats name regexps matcher for inclusion.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "inclusionSuffixes": {
                          "description": "Proxy stats name suffix matcher for inclusion.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    },
                    "readinessProbe": {
                      "description": "VM Health Checking readiness probe. This health check config exactly mirrors the\nkubernetes readiness probe configuration both in schema and logic.\nOnly one health check method of 3 can be set at a time.",
                      "type": "object",
                      "properties": {
                        "exec": {
                          "description": "Exec specifies a command to execute in the container.",
                          "type": "object",
                          "properties": {
                            "command": {
                              "description": "Command is the command line to execute inside the container, the working directory for the\ncommand  is root ('/') in the container's filesystem. The command is simply exec'd, it is\nnot run inside a shell, so traditional shell instructions ('|', etc) won't work. To use\na shell, you need to explicitly call out to that shell.\nExit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "x-kubernetes-list-type": "atomic"
                            }
                          }
                        },
                        "failureThreshold": {
                          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded.\nDefaults to 3. Minimum value is 1.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "grpc": {
                          "description": "GRPC specifies a GRPC HealthCheckRequest.",
                          "type": "object",
                          "required": [
                            "port"
                          ],
                          "properties": {
                            "port": {
                              "description": "Port number of the gRPC service. Number must be in the range 1 to 65535.",
                              "type": "integer",
                              "format": "int32"
                            },
                            "service": {
                              "description": "Service is the name of the service to place in the gRPC HealthCheckRequest\n(see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).\n\nIf this is not specified, the default behavior is defined by gRPC.",
                              "type": "string"
                            }
                          }
                        },
                        "httpGet": {
                          "description": "HTTPGet specifies an HTTP GET request to perform.",
                          "type": "object",
                          "required": [
                            "port"
                          ],
                          "properties": {
                            "host": {
                              "description": "Host name to connect to, defaults to the pod IP. You probably want to set\n\"Host\" in httpHeaders instead.",
                              "type": "string"
                            },
                            "httpHeaders": {
                              "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                              "type": "array",
                              "items": {
                                "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                "type": "object",
                                "required": [
                                  "name",
                                  "value"
                                ],
                                "properties": {
                                  "name": {
                                    "description": "The header field name.\nThis will be canonicalized upon output, so case-variant names will be understood as the same header.",
                                    "type": "string"
                                  },
                                  "value": {
                                    "description": "The header field value",
                                    "type": "string"
                                  }
                                }
                              },
                              "x-kubernetes-list-type": "atomic"
                            },
                            "path": {
                              "description": "Path to access on the HTTP server.",
                              "type": "string"
                            },
                            "port": {
                              "description": "Name or number of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.",
                              "x-kubernetes-int-or-string": true
                            },
                            "scheme": {
                              "description": "Scheme to use for connecting to the host.\nDefaults to HTTP.",
                              "type": "string"
                            }
                          }
                        },
                        "initialDelaySeconds": {
                          "description": "Number of seconds after the container has started before liveness probes are initiated.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "type": "integer",
                          "format": "int32"
                        },
                        "periodSeconds": {
                          "description": "How often (in seconds) to perform the probe.\nDefault to 10 seconds. Minimum value is 1.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "successThreshold": {
                          "description": "Minimum consecutive successes for the probe to be considered successful after having failed.\nDefaults to 1. Must be 1 for liveness and startup. Minimum value is 1.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "tcpSocket": {
                          "description": "TCPSocket specifies a connection to a TCP port.",
                          "type": "object",
                          "required": [
                            "port"
                          ],
                          "properties": {
                            "host": {
                              "description": "Optional: Host name to connect to, defaults to the pod IP.",
                              "type": "string"
                            },
                            "port": {
                              "description": "Number or name of the port to access on the container.\nNumber must be in the range 1 to 65535.\nName must be an IANA_SVC_NAME.",
                              "x-kubernetes-int-or-string": true
                            }
                          }
                        },
                        "terminationGracePeriodSeconds": {
                          "description": "Optional duration in seconds the pod needs to terminate gracefully upon probe failure.\nThe grace period is the duration in seconds after the processes running in the pod are sent\na termination signal and the time when the processes are forcibly halted with a kill signal.\nSet this value longer than the expected cleanup time for your process.\nIf this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this\nvalue overrides the value provided by the pod spec.\nValue must be non-negative integer. The value zero indicates stop immediately via\nthe kill signal (no opportunity to shut down).\nThis is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.\nMinimum value is 1. spec.terminationGracePeriodSeconds is used if unset.",
                          "type": "integer",
                          "format": "int64"
                        },
                        "timeoutSeconds": {
                          "description": "Number of seconds after which the probe times out.\nDefaults to 1 second. Minimum value is 1.\nMore info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    },
                    "runtimeValues": {
                      "description": "Envoy [runtime configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/runtime) to set during bootstrapping.\nThis enables setting experimental, unsafe, unsupported, and deprecated features that should be used with extreme caution.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "sds": {
                      "description": "Secret Discovery Service(SDS) configuration to be used by the proxy.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.",
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "description": "True if SDS is enabled.",
                          "type": "boolean"
                        },
                        "k8sSaJwtPath": {
                          "description": "Path of k8s service account JWT path.",
                          "type": "string"
                        }
                      }
                    },
                    "serviceCluster": {
                      "description": "Service cluster defines the name for the `service_cluster` that is\nshared by all Envoy instances. This setting corresponds to\n`--service-cluster` flag in Envoy.  In a typical Envoy deployment, the\n`service-cluster` flag is used to identify the caller, for\nsource-based routing scenarios.\n\nSince Istio does not assign a local `service/service` version to each\nEnvoy instance, the name is same for all of them.  However, the\nsource/caller's identity (e.g., IP address) is encoded in the\n`--service-node` flag when launching Envoy.  When the RDS service\nreceives API calls from Envoy, it uses the value of the `service-node`\nflag to compute routes that are relative to the service instances\nlocated at that IP address.",
                      "type": "string"
                    },
                    "statNameLength": {
                      "description": "Maximum length of name field in Envoy's metrics. The length of the name field\nis determined by the length of a name field in a service and the set of labels that\ncomprise a particular version of the service. The default value is set to 189 characters.\nEnvoy's internal metrics take up 67 characters, for a total of 256 character name per metric.\nIncrease the value of this field if you find that the metrics from Envoys are truncated.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "statsdUdpAddress": {
                      "description": "IP Address and Port of a statsd UDP listener (e.g. `10.75.241.127:9125`).",
                      "type": "string"
                    },
                    "statusPort": {
                      "description": "Port on which the agent should listen for administrative commands such as readiness probe.\nDefault is set to port `15020`.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "terminationDrainDuration": {
                      "description": "The amount of time allowed for connections to complete on proxy shutdown.\nOn receiving `SIGTERM` or `SIGINT`, `istio-agent` tells the active Envoy to start gracefully draining,\ndiscouraging any new connections and allowing existing connections to complete. It then\nsleeps for the `terminationDrainDuration` and then kills any remaining active Envoy processes.\nIf not set, a default of `5s` will be applied.",
                      "type": "string"
                    },
                    "tracing": {
                      "description": "Tracing configuration to be used by the proxy.",
                      "type": "object",
                      "properties": {
                        "customTags": {
                          "description": "and gateways).\nThe key represents the name of the tag.\nEx:\n```yaml\ncustom_tags:\n\n\tnew_tag_name:\n\t  header:\n\t    name: custom-http-header-name\n\t    default_value: defaulted-value-from-custom-header\n\n```",
                          "type": "object",
                          "additionalProperties": {
                            "description": "Configure custom tags that will be added to any active span.\nTags can be generated via literals, environment variables or an incoming request header.",
                            "type": "object",
                            "properties": {
                              "environment": {
                                "description": "The custom tag's value should be populated from an environmental\nvariable",
                                "type": "object",
                                "properties": {
                                  "defaultValue": {
                                    "description": "When the environment variable is not found,\nthe tag's value will be populated with this default value if specified,\notherwise the tag will not be populated.",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "Name of the environment variable used to populate the tag's value",
                                    "type": "string"
                                  }
                                }
                              },
                              "header": {
                                "description": "The custom tag's value is populated by an http header from\nan incoming request.",
                                "type": "object",
                                "properties": {
                                  "defaultValue": {
                                    "description": "Default value to be used for the tag when the named HTTP header does not exist.\nThe tag will be skipped if no default value is provided.",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "HTTP header name used to obtain the value from to populate the tag value.",
                                    "type": "string"
                                  }
                                }
                              },
                              "literal": {
                                "description": "The custom tag's value is the specified literal.",
                                "type": "object",
                                "properties": {
                                  "value": {
                                    "description": "Static literal value used to populate the tag value.",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "x-kubernetes-validations": [
                              {
                                "message": "At most one of [literal environment header] should be set",
                                "rule": "(has(self.literal)?1:0) + (has(self.environment)?1:0) + (has(self.header)?1:0) <= 1"
                              }
                            ]
                          }
                        },
                        "datadog": {
                          "description": "Use a Datadog tracer.",
                          "type": "object",
                          "properties": {
                            "address": {
                              "description": "Address of the Datadog Agent.",
                              "type": "string"
                            }
                          }
                        },
                        "lightstep": {
                          "description": "Use a Lightstep tracer.\nNOTE: For Istio 1.15+, this configuration option will result\nin using OpenTelemetry-based Lightstep integration.",
                          "type": "object",
                          "properties": {
                            "accessToken": {
                              "description": "The Lightstep access token.",
                              "type": "string"
                            },
                            "address": {
                              "description": "Address of the Lightstep Satellite pool.",
                              "type": "string"
                            }
                          }
                        },
                        "maxPathTagLength": {
                          "description": "Configures the maximum length of the request path to extract and include in the\nHttpUrl tag. Used to truncate length request paths to meet the needs of tracing\nbackend. If not set, then a length of 256 will be used.",
                          "type": "integer",
                          "format": "int32"
                        },
                        "openCensusAgent": {
                          "description": "Use an OpenCensus tracer exporting to an OpenCensus agent.",
                          "type": "object",
                          "properties": {
                            "address": {
                              "description": "gRPC address for the OpenCensus agent (e.g. dns://authority/host:port or\nunix:path). See [gRPC naming\ndocs](https://github.com/grpc/grpc/blob/master/doc/naming.md) for\ndetails.",
                              "type": "string"
                            },
                            "context": {
                              "description": "Specifies the set of context propagation headers used for distributed\ntracing. Default is `[\"W3C_TRACE_CONTEXT\"]`. If multiple values are specified,\nthe proxy will attempt to read each header for each request and will\nwrite all headers.",
                              "type": "array",
                              "items": {
                                "description": "TraceContext selects the context propagation headers used for\ndistributed tracing.",
                                "type": "string",
                                "enum": [
                                  "UNSPECIFIED",
                                  "W3C_TRACE_CONTEXT",
                                  "GRPC_BIN",
                                  "CLOUD_TRACE_CONTEXT",
                                  "B3"
                                ]
                              }
                            }
                          }
                        },
                        "sampling": {
                          "description": "The percentage of requests (0.0 - 100.0) that will be randomly selected for trace generation,\nif not requested by the client or not forced. Default is 1.0.",
                          "type": "number"
                        },
                        "stackdriver": {
                          "description": "Use a Stackdriver tracer.",
                          "type": "object",
                          "properties": {
                            "debug": {
                              "description": "debug enables trace output to stdout.",
                              "type": "boolean"
                            },
                            "maxNumberOfAnnotations": {
                              "description": "The global default max number of annotation events per span.\ndefault is 200.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "maxNumberOfAttributes": {
                              "description": "The global default max number of attributes per span.\ndefault is 200.",
                              "type": "integer",
                              "format": "int64"
                            },
                            "maxNumberOfMessageEvents": {
                              "description": "The global default max number of message events per span.\ndefault is 200.",
                              "type": "integer",
                              "format": "int64"
                            }
                          }
                        },
                        "tlsSettings": {
                          "description": "Use the tlsSettings to specify the tls mode to use. If the remote tracing service\nuses Istio mutual TLS and shares the root CA with istiod, specify the TLS\nmode as `ISTIO_MUTUAL`.",
                          "type": "object",
                          "properties": {
                            "caCertificates": {
                              "description": "OPTIONAL: The path to the file containing certificate authority\ncertificates to use in verifying a presented server certificate. If\nomitted, the proxy will verify the server's certificate using\nthe OS CA certificates.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "caCrl": {
                              "description": "OPTIONAL: The path to the file containing the certificate revocation list (CRL)\nto use in verifying a presented server certificate. `CRL` is a list of certificates\nthat have been revoked by the CA (Certificate Authority) before their scheduled expiration date.\nIf specified, the proxy will verify if the presented certificate is part of the revoked list of certificates.\nIf omitted, the proxy will not verify the certificate against the `crl`. Note that if `credentialName` is set,\n`CRL` cannot be specified using `caCrl`, rather it has to be specified inside the credential.",
                              "type": "string"
                            },
                            "clientCertificate": {
                              "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient-side TLS certificate to use.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "credentialName": {
                              "description": "The name of the secret that holds the TLS certs for the\nclient including the CA certificates. This secret must exist in\nthe namespace of the proxy using the certificates.\nAn Opaque secret should contain the following keys and values:\n`key: <privateKey>`, `cert: <clientCert>`, `cacert: <CACertificate>`,\n`crl: <certificateRevocationList>`\nHere CACertificate is used to verify the server certificate.\nFor mutual TLS, `cacert: <CACertificate>` can be provided in the\nsame secret or a separate secret named `<secret>-cacert`.\nA TLS secret for client certificates with an additional\n`ca.crt` key for CA certificates and `ca.crl` key for\ncertificate revocation list(CRL) is also supported.\nOnly one of client certificates and CA certificate\nor credentialName can be specified.\n\n**NOTE:** This field is applicable at sidecars only if\n`DestinationRule` has a `workloadSelector` specified.\nOtherwise the field will be applicable only at gateways, and\nsidecars will continue to use the certificate paths.",
                              "type": "string"
                            },
                            "insecureSkipVerify": {
                              "description": "`insecureSkipVerify` specifies whether the proxy should skip verifying the\nCA signature and SAN for the server certificate corresponding to the host.\nThe default value of this field is false.",
                              "type": "boolean"
                            },
                            "mode": {
                              "description": "Indicates whether connections to this port should be secured\nusing TLS. The value of this field determines how TLS is enforced.",
                              "type": "string",
                              "enum": [
                                "DISABLE",
                                "SIMPLE",
                                "MUTUAL",
                                "ISTIO_MUTUAL"
                              ]
                            },
                            "privateKey": {
                              "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the\nclient's private key.\nShould be empty if mode is `ISTIO_MUTUAL`.",
                              "type": "string"
                            },
                            "sni": {
                              "description": "SNI string to present to the server during TLS handshake.\nIf unspecified, SNI will be automatically set based on downstream HTTP\nhost/authority header for SIMPLE and MUTUAL TLS modes.",
                              "type": "string"
                            },
                            "subjectAltNames": {
                              "description": "A list of alternate names to verify the subject identity in the\ncertificate. If specified, the proxy will verify that the server\ncertificate's subject alt name matches one of the specified values.\nIf specified, this list overrides the value of `subjectAltNames`\nfrom the `ServiceEntry`. If unspecified, automatic validation of upstream\npresented certificate for new upstream connections will be done based on the\ndownstream HTTP host/authority header.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        },
                        "zipkin": {
                          "description": "Use a Zipkin tracer.",
                          "type": "object",
                          "properties": {
                            "address": {
                              "description": "Address of the Zipkin service (e.g. _zipkin:9411_).",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "x-kubernetes-validations": [
                        {
                          "message": "At most one of [zipkin lightstep datadog stackdriver openCensusAgent] should be set",
                          "rule": "(has(self.zipkin)?1:0) + (has(self.lightstep)?1:0) + (has(self.datadog)?1:0) + (has(self.stackdriver)?1:0) + (has(self.openCensusAgent)?1:0) <= 1"
                        }
                      ]
                    },
                    "tracingServiceName": {
                      "description": "Used by Envoy proxies to assign the values for the service names in trace\nspans.",
                      "type": "string",
                      "enum": [
                        "APP_LABEL_AND_NAMESPACE",
                        "CANONICAL_NAME_ONLY",
                        "CANONICAL_NAME_AND_NAMESPACE"
                      ]
                    },
                    "zipkinAddress": {
                      "description": "Address of the Zipkin service (e.g. _zipkin:9411_).\nDEPRECATED: Use [tracing][istio.mesh.v1alpha1.ProxyConfig.tracing] instead.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.",
                      "type": "string"
                    }
                  },
                  "x-kubernetes-validations": [
                    {
                      "message": "At most one of [serviceCluster tracingServiceName] should be set",
                      "rule": "(has(self.serviceCluster)?1:0) + (has(self.tracingServiceName)?1:0) <= 1"
                    }
                  ]
                },
                "defaultDestinationRuleExportTo": {
                  "description": "The default value for the `DestinationRule.exportTo` field. Has the same\nsyntax as `defaultServiceExportTo`.\n\nIf not set the system will use \"*\" as the default value which implies that\ndestination rules are exported to all namespaces",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "defaultHttpRetryPolicy": {
                  "description": "Configure the default HTTP retry policy.\nThe default number of retry attempts is set at 2 for these errors:\n\n\t\"connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes\".\n\nSetting the number of attempts to 0 disables retry policy globally.\nThis setting can be overridden on a per-host basis using the Virtual Service\nAPI.\nAll settings in the retry policy except `perTryTimeout` can currently be\nconfigured globally via this field.",
                  "type": "object",
                  "properties": {
                    "attempts": {
                      "description": "Number of retries to be allowed for a given request. The interval\nbetween retries will be determined automatically (25ms+). When request\n`timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute)\nor `per_try_timeout` is configured, the actual number of retries attempted also depends on\nthe specified request `timeout` and `per_try_timeout` values. MUST be >= 0. If `0`, retries will be disabled.\nThe maximum possible number of requests made will be 1 + `attempts`.",
                      "type": "integer",
                      "format": "int32"
                    },
                    "perTryTimeout": {
                      "description": "Timeout per attempt for a given request, including the initial call and any retries. Format: 1h/1m/1s/1ms. MUST be >=1ms.\nDefault is same value as request\n`timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute),\nwhich means no timeout.",
                      "type": "string"
                    },
                    "retryOn": {
                      "description": "Specifies the conditions under which retry takes place.\nOne or more policies can be specified using a \u2018,\u2019 delimited list.\nSee the [retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on)\nand [gRPC retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on) for more details.\n\nIn addition to the policies specified above, a list of HTTP status codes can be passed, such as `retryOn: \"503,reset\"`.\nNote these status codes refer to the actual responses received from the destination.\nFor example, if a connection is reset, Istio will translate this to 503 for it's response.\nHowever, the destination did not return a 503 error, so this would not match `\"503\"` (it would, however, match `\"reset\"`).\n\nIf not specified, this defaults to `connect-failure,refused-stream,unavailable,cancelled,503`.",
                      "type": "string"
                    },
                    "retryRemoteLocalities": {
                      "description": "Flag to specify whether the retries should retry to other localities.\nSee the [retry plugin configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_connection_management#retry-plugin-configuration) for more details.",
                      "type": "boolean"
                    }
                  }
                },
                "defaultProviders": {
                  "description": "Specifies extension providers to use by default in Istio configuration resources.",
                  "type": "object",
                  "properties": {
                    "accessLogging": {
                      "description": "Name of the default provider(s) for access logging.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "metrics": {
                      "description": "Name of the default provider(s) for metrics.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "tracing": {
                      "description": "Name of the default provider(s) for tracing.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "defaultServiceExportTo": {
                  "description": "The default value for the ServiceEntry.exportTo field and services\nimported through container registry integrations, e.g. this applies to\nKubernetes Service resources. The value is a list of namespace names and\nreserved namespace aliases. The allowed namespace aliases are:\n```\n* - All Namespaces\n. - Current Namespace\n~ - No Namespace\n```\nIf not set the system will use \"*\" as the default value which implies that\nservices are exported to all namespaces.\n\n`All namespaces` is a reasonable default for implementations that don't\nneed to restrict access or visibility of services across namespace\nboundaries. If that requirement is present it is generally good practice to\nmake the default `Current namespace` so that services are only visible\nwithin their own namespaces by default. Operators can then expand the\nvisibility of services to other namespaces as needed. Use of `No Namespace`\nis expected to be rare but can have utility for deployments where\ndependency management needs to be precise even within the scope of a single\nnamespace.\n\nFor further discussion see the reference documentation for `ServiceEntry`,\n`Sidecar`, and `Gateway`.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "defaultVirtualServiceExportTo": {
                  "description": "The default value for the VirtualService.exportTo field. Has the same\nsyntax as `defaultServiceExportTo`.\n\nIf not set the system will use \"*\" as the default value which implies that\nvirtual services are exported to all namespaces",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "disableEnvoyListenerLog": {
                  "description": "This flag disables Envoy Listener logs.\nSee [Listener Access Log](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#envoy-v3-api-field-config-listener-v3-listener-access-log)\nIstio Enables Envoy's listener access logs on \"NoRoute\" response flag.\nDefault value is `false`.",
                  "type": "boolean"
                },
                "discoverySelectors": {
                  "description": "A list of Kubernetes selectors that specify the set of namespaces that Istio considers when\ncomputing configuration updates for sidecars. This can be used to reduce Istio's computational load\nby limiting the number of entities (including services, pods, and endpoints) that are watched and processed.\nIf omitted, Istio will use the default behavior of processing all namespaces in the cluster.\nElements in the list are disjunctive (OR semantics), i.e. a namespace will be included if it matches any selector.\nThe following example selects any namespace that matches either below:\n1. The namespace has both of these labels: `env: prod` and `region: us-east1`\n2. The namespace has label `app` equal to `cassandra` or `spark`.\n```yaml\ndiscoverySelectors:\n  - matchLabels:\n    env: prod\n    region: us-east1\n  - matchExpressions:\n  - key: app\n    operator: In\n    values:\n  - cassandra\n  - spark\n\n```\nRefer to the [Kubernetes selector docs](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors)\nfor additional detail on selector semantics.",
                  "type": "array",
                  "items": {
                    "description": "A label selector is a label query over a set of resources. The result of matchLabels and\nmatchExpressions are ANDed. An empty label selector matches all objects. A null\nlabel selector matches no objects.",
                    "type": "object",
                    "properties": {
                      "matchExpressions": {
                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                        "type": "array",
                        "items": {
                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                          "type": "object",
                          "required": [
                            "key",
                            "operator"
                          ],
                          "properties": {
                            "key": {
                              "description": "key is the label key that the selector applies to.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                              "type": "string"
                            },
                            "values": {
                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "x-kubernetes-list-type": "atomic"
                            }
                          }
                        },
                        "x-kubernetes-list-type": "atomic"
                      },
                      "matchLabels": {
                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    },
                    "x-kubernetes-map-type": "atomic"
                  }
                },
                "dnsRefreshRate": {
                  "description": "Configures DNS refresh rate for Envoy clusters of type `STRICT_DNS`\nDefault refresh rate is `60s`.",
                  "type": "string"
                },
                "enableAutoMtls": {
                  "description": "This flag is used to enable mutual `TLS` automatically for service to service communication\nwithin the mesh, default true.\nIf set to true, and a given service does not have a corresponding `DestinationRule` configured,\nor its `DestinationRule` does not have ClientTLSSettings specified, Istio configures client side\nTLS configuration appropriately. More specifically,\nIf the upstream authentication policy is in `STRICT` mode, use Istio provisioned certificate\nfor mutual `TLS` to connect to upstream.\nIf upstream service is in plain text mode, use plain text.\nIf the upstream authentication policy is in PERMISSIVE mode, Istio configures clients to use\nmutual `TLS` when server sides are capable of accepting mutual `TLS` traffic.\nIf service `DestinationRule` exists and has `ClientTLSSettings` specified, that is always used instead.",
                  "type": "boolean"
                },
                "enableEnvoyAccessLogService": {
                  "description": "This flag enables Envoy's gRPC Access Log Service.\nSee [Access Log Service](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/grpc/v3/als.proto)\nfor details about Envoy's gRPC Access Log Service API.\nDefault value is `false`.",
                  "type": "boolean"
                },
                "enablePrometheusMerge": {
                  "description": "If enabled, Istio agent will merge metrics exposed by the application with metrics from Envoy\nand Istio agent. The sidecar injection will replace `prometheus.io` annotations present on the pod\nand redirect them towards Istio agent, which will then merge metrics of from the application with Istio metrics.\nThis relies on the annotations `prometheus.io/scrape`, `prometheus.io/port`, and\n`prometheus.io/path` annotations.\nIf you are running a separately managed Envoy with an Istio sidecar, this may cause issues, as the metrics will collide.\nIn this case, it is recommended to disable aggregation on that deployment with the\n`prometheus.istio.io/merge-metrics: \"false\"` annotation.\nIf not specified, this will be enabled by default.",
                  "type": "boolean"
                },
                "enableTracing": {
                  "description": "Flag to control generation of trace spans and request IDs.\nRequires a trace span collector defined in the proxy configuration.",
                  "type": "boolean"
                },
                "extensionProviders": {
                  "description": "Defines a list of extension providers that extend Istio's functionality. For example, the AuthorizationPolicy\ncan be used with an extension provider to delegate the authorization decision to a custom authorization system.",
                  "type": "array",
                  "maxItems": 1000,
                  "items": {
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "datadog": {
                        "description": "Configures a Datadog tracing provider.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "maxTagLength": {
                            "description": "Optional. Controls the overall path length allowed in a reported span.\nNOTE: currently only controls max length of the path tag.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service for the Datadog agent.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"datadog.default.svc.cluster.local\" or \"bar/datadog.example.com\".",
                            "type": "string"
                          }
                        }
                      },
                      "envoyExtAuthzGrpc": {
                        "description": "Configures an external authorizer that implements the Envoy ext_authz filter authorization check service using the gRPC API.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "failOpen": {
                            "description": "If true, the HTTP request or TCP connection will be allowed even if the communication with the authorization service has failed,\nor if the authorization service has returned a HTTP 5xx error.\nDefault is false. For HTTP request, it will be rejected with 403 (HTTP Forbidden). For TCP connection, it will be closed immediately.",
                            "type": "boolean"
                          },
                          "includeRequestBodyInCheck": {
                            "description": "If set, the client request body will be included in the authorization request sent to the authorization service.",
                            "type": "object",
                            "properties": {
                              "allowPartialMessage": {
                                "description": "When this field is true, ext-authz filter will buffer the message until maxRequestBytes is reached.\nThe authorization request will be dispatched and no 413 HTTP error will be returned by the filter.\nA \"x-envoy-auth-partial-body: false|true\" metadata header will be added to the authorization request message\nindicating if the body data is partial.",
                                "type": "boolean"
                              },
                              "maxRequestBytes": {
                                "description": "Sets the maximum size of a message body that the ext-authz filter will hold in memory.\nIf maxRequestBytes is reached, and allowPartialMessage is false, Envoy will return a 413 (Payload Too Large).\nOtherwise the request will be sent to the provider with a partial message.\nNote that this setting will have precedence over the failOpen field, the 413 will be returned even when the\nfailOpen is set to true.",
                                "type": "integer",
                                "format": "int32"
                              },
                              "packAsBytes": {
                                "description": "If true, the body sent to the external authorization service in the gRPC authorization request is set with raw bytes\nin the [raw_body field](https://github.com/envoyproxy/envoy/blame/cffb095d59d7935abda12b9509bcd136808367bb/api/envoy/service/auth/v3/attribute_context.proto#L153).\nOtherwise, it will be filled with UTF-8 string in the [body field](https://github.com/envoyproxy/envoy/blame/cffb095d59d7935abda12b9509bcd136808367bb/api/envoy/service/auth/v3/attribute_context.proto#L147).\nThis field only works with the envoyExtAuthzGrpc provider and has no effect for the envoyExtAuthzHttp provider.",
                                "type": "boolean"
                              }
                            }
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service that implements the Envoy ext_authz gRPC authorization service.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"my-ext-authz.foo.svc.cluster.local\" or \"bar/my-ext-authz.example.com\".",
                            "type": "string"
                          },
                          "statusOnError": {
                            "description": "Sets the HTTP status that is returned to the client when there is a network error to the authorization service.\nThe default status is \"403\" (HTTP Forbidden).",
                            "type": "string"
                          },
                          "timeout": {
                            "description": "The maximum duration that the proxy will wait for a response from the provider, this is the timeout for a specific request (default timeout: 600s).\nWhen this timeout condition is met, the proxy marks the communication to the authorization service as failure.\nIn this situation, the response sent back to the client will depend on the configured `failOpen` field.",
                            "type": "string"
                          }
                        }
                      },
                      "envoyExtAuthzHttp": {
                        "description": "Configures an external authorizer that implements the Envoy ext_authz filter authorization check service using the HTTP API.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "failOpen": {
                            "description": "If true, the user request will be allowed even if the communication with the authorization service has failed,\nor if the authorization service has returned a HTTP 5xx error.\nDefault is false and the request will be rejected with \"Forbidden\" response.",
                            "type": "boolean"
                          },
                          "headersToDownstreamOnAllow": {
                            "description": "List of headers from the authorization service that should be forwarded to downstream when the authorization\ncheck result is allowed (HTTP code 200).\nIf not specified, the original response will not be modified and forwarded to downstream as-is.\nNote, any existing headers will be overridden.\n\nExact, prefix and suffix matches are supported (similar to the\n[authorization policy rule syntax](https://istio.io/latest/docs/reference/config/security/authorization-policy/#Rule)\nexcept the presence match):\n- Exact match: \"abc\" will match on value \"abc\".\n- Prefix match: \"abc*\" will match on value \"abc\" and \"abcd\".\n- Suffix match: \"*abc\" will match on value \"abc\" and \"xabc\".",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "headersToDownstreamOnDeny": {
                            "description": "List of headers from the authorization service that should be forwarded to downstream when the authorization\ncheck result is not allowed (HTTP code other than 200).\nIf not specified, all the authorization response headers, except *Authority (Host)* will be in the response to\nthe downstream.\nWhen a header is included in this list, *Path*, *Status*, *Content-Length*, *WWWAuthenticate* and *Location* are\nautomatically added.\nNote, the body from the authorization service is always included in the response to downstream.\n\nExact, prefix and suffix matches are supported (similar to the\n[authorization policy rule syntax](https://istio.io/latest/docs/reference/config/security/authorization-policy/#Rule)\nexcept the presence match):\n- Exact match: \"abc\" will match on value \"abc\".\n- Prefix match: \"abc*\" will match on value \"abc\" and \"abcd\".\n- Suffix match: \"*abc\" will match on value \"abc\" and \"xabc\".",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "headersToUpstreamOnAllow": {
                            "description": "List of headers from the authorization service that should be added or overridden in the original request and\nforwarded to the upstream when the authorization check result is allowed (HTTP code 200).\nIf not specified, the original request will not be modified and forwarded to backend as-is.\nNote, any existing headers will be overridden.\n\nExact, prefix and suffix matches are supported (similar to the\n[authorization policy rule syntax](https://istio.io/latest/docs/reference/config/security/authorization-policy/#Rule)\nexcept the presence match):\n- Exact match: \"abc\" will match on value \"abc\".\n- Prefix match: \"abc*\" will match on value \"abc\" and \"abcd\".\n- Suffix match: \"*abc\" will match on value \"abc\" and \"xabc\".",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "includeAdditionalHeadersInCheck": {
                            "description": "Set of additional fixed headers that should be included in the authorization request sent to the authorization service.\nKey is the header name and value is the header value.\nNote that client request of the same key or headers specified in includeRequestHeadersInCheck will be overridden.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          },
                          "includeHeadersInCheck": {
                            "description": "DEPRECATED. Use includeRequestHeadersInCheck instead.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "includeRequestBodyInCheck": {
                            "description": "If set, the client request body will be included in the authorization request sent to the authorization service.",
                            "type": "object",
                            "properties": {
                              "allowPartialMessage": {
                                "description": "When this field is true, ext-authz filter will buffer the message until maxRequestBytes is reached.\nThe authorization request will be dispatched and no 413 HTTP error will be returned by the filter.\nA \"x-envoy-auth-partial-body: false|true\" metadata header will be added to the authorization request message\nindicating if the body data is partial.",
                                "type": "boolean"
                              },
                              "maxRequestBytes": {
                                "description": "Sets the maximum size of a message body that the ext-authz filter will hold in memory.\nIf maxRequestBytes is reached, and allowPartialMessage is false, Envoy will return a 413 (Payload Too Large).\nOtherwise the request will be sent to the provider with a partial message.\nNote that this setting will have precedence over the failOpen field, the 413 will be returned even when the\nfailOpen is set to true.",
                                "type": "integer",
                                "format": "int32"
                              },
                              "packAsBytes": {
                                "description": "If true, the body sent to the external authorization service in the gRPC authorization request is set with raw bytes\nin the [raw_body field](https://github.com/envoyproxy/envoy/blame/cffb095d59d7935abda12b9509bcd136808367bb/api/envoy/service/auth/v3/attribute_context.proto#L153).\nOtherwise, it will be filled with UTF-8 string in the [body field](https://github.com/envoyproxy/envoy/blame/cffb095d59d7935abda12b9509bcd136808367bb/api/envoy/service/auth/v3/attribute_context.proto#L147).\nThis field only works with the envoyExtAuthzGrpc provider and has no effect for the envoyExtAuthzHttp provider.",
                                "type": "boolean"
                              }
                            }
                          },
                          "includeRequestHeadersInCheck": {
                            "description": "List of client request headers that should be included in the authorization request sent to the authorization service.\nNote that in addition to the headers specified here following headers are included by default:\n1. *Host*, *Method*, *Path* and *Content-Length* are automatically sent.\n2. *Content-Length* will be set to 0 and the request will not have a message body. However, the authorization\nrequest can include the buffered client request body (controlled by includeRequestBodyInCheck setting),\nconsequently the value of Content-Length of the authorization request reflects the size of its payload size.\n\nExact, prefix and suffix matches are supported (similar to the\n[authorization policy rule syntax](https://istio.io/latest/docs/reference/config/security/authorization-policy/#Rule)\nexcept the presence match):\n- Exact match: \"abc\" will match on value \"abc\".\n- Prefix match: \"abc*\" will match on value \"abc\" and \"abcd\".\n- Suffix match: \"*abc\" will match on value \"abc\" and \"xabc\".",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "pathPrefix": {
                            "description": "Sets a prefix to the value of authorization request header *Path*.\nFor example, setting this to \"/check\" for an original user request at path \"/admin\" will cause the\nauthorization check request to be sent to the authorization service at the path \"/check/admin\" instead of \"/admin\".",
                            "type": "string"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service that implements the Envoy ext_authz HTTP authorization service.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"my-ext-authz.foo.svc.cluster.local\" or \"bar/my-ext-authz.example.com\".",
                            "type": "string"
                          },
                          "statusOnError": {
                            "description": "Sets the HTTP status that is returned to the client when there is a network error to the authorization service.\nThe default status is \"403\" (HTTP Forbidden).",
                            "type": "string"
                          },
                          "timeout": {
                            "description": "The maximum duration that the proxy will wait for a response from the provider (default timeout: 600s).\nWhen this timeout condition is met, the proxy marks the communication to the authorization service as failure.\nIn this situation, the response sent back to the client will depend on the configured `failOpen` field.",
                            "type": "string"
                          }
                        }
                      },
                      "envoyFileAccessLog": {
                        "description": "Configures an Envoy File Access Log provider.",
                        "type": "object",
                        "properties": {
                          "logFormat": {
                            "description": "Optional. Allows overriding of the default access log format.",
                            "type": "object",
                            "properties": {
                              "labels": {
                                "description": "JSON structured format for the envoy access logs. Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators)\ncan be used as values for fields within the Struct. Values are rendered\nas strings, numbers, or boolean values, as appropriate\n(see: [format dictionaries](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-dictionaries)). Nested JSON is\nsupported for some command operators (e.g. `FILTER_STATE` or `DYNAMIC_METADATA`).\nUse `labels: {}` for default envoy JSON log format.\n\nExample:\n```\nlabels:\n\n\tstatus: \"%RESPONSE_CODE%\"\n\tmessage: \"%LOCAL_REPLY_BODY%\"\n\n```",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "text": {
                                "description": "Textual format for the envoy access logs. Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be\nused in the format. The [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings)\nprovides more information.\n\nNOTE: Istio will insert a newline ('\\n') on all formats (if missing).\n\nExample: `text: \"%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\"`",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-validations": [
                              {
                                "message": "At most one of [text labels] should be set",
                                "rule": "(has(self.text)?1:0) + (has(self.labels)?1:0) <= 1"
                              }
                            ]
                          },
                          "path": {
                            "description": "Path to a local file to write the access log entries.\nThis may be used to write to streams, via `/dev/stderr` and `/dev/stdout`\nIf unspecified, defaults to `/dev/stdout`.",
                            "type": "string"
                          }
                        }
                      },
                      "envoyHttpAls": {
                        "description": "Configures an Envoy Access Logging Service provider for HTTP traffic.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "additionalRequestHeadersToLog": {
                            "description": "Optional. Additional request headers to log.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "additionalResponseHeadersToLog": {
                            "description": "Optional. Additional response headers to log.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "additionalResponseTrailersToLog": {
                            "description": "Optional. Additional response trailers to log.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "filterStateObjectsToLog": {
                            "description": "Optional. Additional filter state objects to log.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "logName": {
                            "description": "Optional. The friendly name of the access log.\nDefaults:\n-  \"http_envoy_accesslog\"\n-  \"listener_envoy_accesslog\"",
                            "type": "string"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service that implements the Envoy ALS gRPC authorization service.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"envoy-als.foo.svc.cluster.local\" or \"bar/envoy-als.example.com\".",
                            "type": "string"
                          }
                        }
                      },
                      "envoyOtelAls": {
                        "description": "Configures an Envoy Open Telemetry Access Logging Service provider.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "logFormat": {
                            "description": "Optional. Format for the proxy access log\nEmpty value results in proxy's default access log format, following Envoy access logging formatting.",
                            "type": "object",
                            "properties": {
                              "labels": {
                                "description": "Optional. Additional attributes that describe the specific event occurrence.\nStructured format for the envoy access logs. Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators)\ncan be used as values for fields within the Struct. Values are rendered\nas strings, numbers, or boolean values, as appropriate\n(see: [format dictionaries](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-dictionaries)). Nested JSON is\nsupported for some command operators (e.g. FILTER_STATE or DYNAMIC_METADATA).\nAlias to `attributes` field in [Open Telemetry](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/open_telemetry/v3/logs_service.proto)\n\nExample:\n```\nlabels:\n\n\tstatus: \"%RESPONSE_CODE%\"\n\tmessage: \"%LOCAL_REPLY_BODY%\"\n\n```",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              },
                              "text": {
                                "description": "Textual format for the envoy access logs. Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be\nused in the format. The [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings)\nprovides more information.\nAlias to `body` field in [Open Telemetry](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/open_telemetry/v3/logs_service.proto)\nExample: `text: \"%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\"`",
                                "type": "string"
                              }
                            }
                          },
                          "logName": {
                            "description": "Optional. The friendly name of the access log.\nDefaults:\n- \"otel_envoy_accesslog\"",
                            "type": "string"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service that implements the Envoy ALS gRPC authorization service.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"envoy-als.foo.svc.cluster.local\" or \"bar/envoy-als.example.com\".",
                            "type": "string"
                          }
                        }
                      },
                      "envoyTcpAls": {
                        "description": "Configures an Envoy Access Logging Service provider for TCP traffic.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "filterStateObjectsToLog": {
                            "description": "Optional. Additional filter state objects to log.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "logName": {
                            "description": "Optional. The friendly name of the access log.\nDefaults:\n- \"tcp_envoy_accesslog\"\n- \"listener_envoy_accesslog\"",
                            "type": "string"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service that implements the Envoy ALS gRPC authorization service.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"envoy-als.foo.svc.cluster.local\" or \"bar/envoy-als.example.com\".",
                            "type": "string"
                          }
                        }
                      },
                      "lightstep": {
                        "description": "Configures a Lightstep tracing provider.\nDeprecated: For Istio 1.15+, please use an OpenTelemetryTracingProvider instead, more details can be found at https://github.com/istio/istio/issues/40027\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "accessToken": {
                            "description": "The Lightstep access token.",
                            "type": "string"
                          },
                          "maxTagLength": {
                            "description": "Optional. Controls the overall path length allowed in a reported span.\nNOTE: currently only controls max length of the path tag.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service for the Lightstep collector.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"lightstep.default.svc.cluster.local\" or \"bar/lightstep.example.com\".",
                            "type": "string"
                          }
                        }
                      },
                      "name": {
                        "description": "REQUIRED. A unique name identifying the extension provider.",
                        "type": "string"
                      },
                      "opencensus": {
                        "description": "Configures an OpenCensusAgent tracing provider.\nDeprecated: OpenCensus is deprecated, more details can be found at https://opentelemetry.io/blog/2023/sunsetting-opencensus/\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "context": {
                            "description": "Specifies the set of context propagation headers used for distributed\ntracing. Default is `[\"W3C_TRACE_CONTEXT\"]`. If multiple values are specified,\nthe proxy will attempt to read each header for each request and will\nwrite all headers.",
                            "type": "array",
                            "items": {
                              "description": "TraceContext selects the context propagation headers used for\ndistributed tracing.",
                              "type": "string",
                              "enum": [
                                "UNSPECIFIED",
                                "W3C_TRACE_CONTEXT",
                                "GRPC_BIN",
                                "CLOUD_TRACE_CONTEXT",
                                "B3"
                              ]
                            }
                          },
                          "maxTagLength": {
                            "description": "Optional. Controls the overall path length allowed in a reported span.\nNOTE: currently only controls max length of the path tag.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service for the OpenCensusAgent.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"ocagent.default.svc.cluster.local\" or \"bar/ocagent.example.com\".",
                            "type": "string"
                          }
                        }
                      },
                      "opentelemetry": {
                        "description": "Configures an OpenTelemetry tracing provider.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "dynatraceSampler": {
                            "description": "The Dynatrace adaptive traffic management (ATM) sampler.\n\nExample configuration:\n\n```yaml\n  - name: otel-tracing\n    opentelemetry:\n    port: 443\n    service: \"{your-environment-id}.live.dynatrace.com\"\n    http:\n    path: \"/api/v2/otlp/v1/traces\"\n    timeout: 10s\n    headers:\n  - name: \"Authorization\"\n    value: \"Api-Token dt0c01.\"\n    resourceDetectors:\n    dynatrace: {}\n    dynatraceSampler:\n    tenant: \"{your-environment-id}\"\n    clusterId: 1234",
                            "type": "object",
                            "required": [
                              "clusterId",
                              "tenant"
                            ],
                            "properties": {
                              "clusterId": {
                                "description": "REQUIRED. The identifier of the cluster in the Dynatrace platform.\nThe cluster here is Dynatrace-specific concept and not related to the cluster concept in Istio/Envoy.\n\nThe value can be obtained from the Istio deployment page in Dynatrace.",
                                "type": "integer",
                                "format": "int32"
                              },
                              "httpService": {
                                "description": "Optional. Dynatrace HTTP API to obtain sampling configuration.\n\nWhen not provided, the Dynatrace Sampler will re-use the configuration from the OpenTelemetryTracingProvider HTTP Exporter\n(`service`, `port` and `http`), including the access token.",
                                "type": "object",
                                "required": [
                                  "http",
                                  "port",
                                  "service"
                                ],
                                "properties": {
                                  "http": {
                                    "description": "REQUIRED. Specifies sampling configuration URI.",
                                    "type": "object",
                                    "required": [
                                      "path"
                                    ],
                                    "properties": {
                                      "headers": {
                                        "description": "Optional. Allows specifying custom HTTP headers that will be added\nto each HTTP request sent.",
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "required": [
                                            "name",
                                            "value"
                                          ],
                                          "properties": {
                                            "name": {
                                              "description": "REQUIRED. The HTTP header name.",
                                              "type": "string"
                                            },
                                            "value": {
                                              "description": "REQUIRED. The HTTP header value.",
                                              "type": "string"
                                            }
                                          }
                                        }
                                      },
                                      "path": {
                                        "description": "REQUIRED. Specifies the path on the service.",
                                        "type": "string"
                                      },
                                      "timeout": {
                                        "description": "Optional. Specifies the timeout for the HTTP request.\nIf not specified, the default is 3s.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "port": {
                                    "description": "REQUIRED. Specifies the port of the service.",
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "service": {
                                    "description": "REQUIRED. Specifies the Dynatrace environment to obtain the sampling configuration.\nThe format is `<Hostname>`, where `<Hostname>` is the fully qualified Dynatrace environment\nhost name defined in the ServiceEntry.\n\nExample: \"{your-environment-id}.live.dynatrace.com\".",
                                    "type": "string"
                                  }
                                }
                              },
                              "rootSpansPerMinute": {
                                "description": "Optional. Number of sampled spans per minute to be used\nwhen the adaptive value cannot be obtained from the Dynatrace API.\n\nA default value of `1000` is used when:\n\n- `rootSpansPerMinute` is unset\n- `rootSpansPerMinute` is set to 0",
                                "type": "integer",
                                "format": "int32"
                              },
                              "tenant": {
                                "description": "REQUIRED. The Dynatrace customer's tenant identifier.\n\nThe value can be obtained from the Istio deployment page in Dynatrace.",
                                "type": "string"
                              }
                            }
                          },
                          "grpc": {
                            "description": "Optional. Specifies the configuration for exporting OTLP traces via GRPC.\nWhen empty, traces will check whether HTTP is set.\nIf not, traces will use default GRPC configurations.\n\nThe following example shows how to configure the OpenTelemetry ExtensionProvider to export via GRPC:\n\n1. Add/change the OpenTelemetry extension provider in `MeshConfig`\n```yaml\n  - name: opentelemetry\n    opentelemetry:\n    port: 8090\n    service: tracing.example.com\n    grpc:\n    timeout: 10s\n    initialMetadata:\n  - name: \"Authentication\"\n    value: \"token-xxxxx\"\n\n```\n\n2. Deploy a `ServiceEntry` for the observability back-end\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n\n\tname: tracing-grpc\n\nspec:\n\n\thosts:\n\t- tracing.example.com\n\tports:\n\t- number: 8090\n\t  name: grpc-port\n\t  protocol: GRPC\n\tresolution: DNS\n\tlocation: MESH_EXTERNAL\n\n```",
                            "type": "object",
                            "properties": {
                              "initialMetadata": {
                                "description": "Optional. Additional metadata to include in streams initiated to the GrpcService. This can be used for\nscenarios in which additional ad hoc authorization headers (e.g. \"x-foo-bar: baz-key\") are to\nbe injected.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "required": [
                                    "name",
                                    "value"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "REQUIRED. The HTTP header name.",
                                      "type": "string"
                                    },
                                    "value": {
                                      "description": "REQUIRED. The HTTP header value.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "timeout": {
                                "description": "Optional. Specifies the timeout for the GRPC request.",
                                "type": "string"
                              }
                            }
                          },
                          "http": {
                            "description": "Optional. Specifies the configuration for exporting OTLP traces via HTTP.\nWhen empty, traces will be exported via gRPC.\n\nThe following example shows how to configure the OpenTelemetry ExtensionProvider to export via HTTP:\n\n1. Add/change the OpenTelemetry extension provider in `MeshConfig`\n```yaml\n  - name: otel-tracing\n    opentelemetry:\n    port: 443\n    service: my.olly-backend.com\n    http:\n    path: \"/api/otlp/traces\"\n    timeout: 10s\n    headers:\n  - name: \"my-custom-header\"\n    value: \"some value\"\n\n```\n\n2. Deploy a `ServiceEntry` for the observability back-end\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n\n\tname: my-olly-backend\n\nspec:\n\n\thosts:\n\t- my.olly-backend.com\n\tports:\n\t- number: 443\n\t  name: https-port\n\t  protocol: HTTPS\n\tresolution: DNS\n\tlocation: MESH_EXTERNAL\n\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n\n\tname: my-olly-backend\n\nspec:\n\n\thost: my.olly-backend.com\n\ttrafficPolicy:\n\t  portLevelSettings:\n\t  - port:\n\t      number: 443\n\t    tls:\n\t      mode: SIMPLE\n\n```",
                            "type": "object",
                            "required": [
                              "path"
                            ],
                            "properties": {
                              "headers": {
                                "description": "Optional. Allows specifying custom HTTP headers that will be added\nto each HTTP request sent.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "required": [
                                    "name",
                                    "value"
                                  ],
                                  "properties": {
                                    "name": {
                                      "description": "REQUIRED. The HTTP header name.",
                                      "type": "string"
                                    },
                                    "value": {
                                      "description": "REQUIRED. The HTTP header value.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "path": {
                                "description": "REQUIRED. Specifies the path on the service.",
                                "type": "string"
                              },
                              "timeout": {
                                "description": "Optional. Specifies the timeout for the HTTP request.\nIf not specified, the default is 3s.",
                                "type": "string"
                              }
                            }
                          },
                          "maxTagLength": {
                            "description": "Optional. Controls the overall path length allowed in a reported span.\nNOTE: currently only controls max length of the path tag.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "resourceDetectors": {
                            "description": "Optional. Specifies [Resource Detectors](https://opentelemetry.io/docs/specs/otel/resource/sdk/)\nto be used by the OpenTelemetry Tracer. When multiple resources are provided, they are merged\naccording to the OpenTelemetry [Resource specification](https://opentelemetry.io/docs/specs/otel/resource/sdk/#merge).\n\nThe following example shows how to configure the Environment Resource Detector, that will\nread the attributes from the environment variable `OTEL_RESOURCE_ATTRIBUTES`:\n\n```yaml\n  - name: otel-tracing\n    opentelemetry:\n    port: 443\n    service: my.olly-backend.com\n    resourceDetectors:\n    environment: {}\n\n```",
                            "type": "object",
                            "properties": {
                              "dynatrace": {
                                "description": "Dynatrace Resource Detector.\nThe resource detector reads from the Dynatrace enrichment files\nand adds host/process related attributes to the OpenTelemetry resource.\n\nSee: [Enrich ingested data with Dynatrace-specific dimensions](https://docs.dynatrace.com/docs/shortlink/enrichment-files)",
                                "type": "object"
                              },
                              "environment": {
                                "description": "OpenTelemetry Environment Resource Detector.\nThe resource detector reads attributes from the environment variable `OTEL_RESOURCE_ATTRIBUTES`\nand adds them to the OpenTelemetry resource.\n\nSee: [Resource specification](https://opentelemetry.io/docs/specs/otel/resource/sdk/#specifying-resource-information-via-an-environment-variable)",
                                "type": "object"
                              }
                            }
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the OpenTelemetry endpoint that will receive OTLP traces.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"otlp.default.svc.cluster.local\" or \"bar/otlp.example.com\".",
                            "type": "string"
                          }
                        },
                        "x-kubernetes-validations": [
                          {
                            "message": "At most one of [dynatraceSampler] should be set",
                            "rule": "(has(self.dynatraceSampler)?1:0) <= 1"
                          }
                        ]
                      },
                      "prometheus": {
                        "description": "Configures a Prometheus metrics provider.",
                        "type": "object"
                      },
                      "skywalking": {
                        "description": "Configures a Apache SkyWalking provider.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "accessToken": {
                            "description": "Optional. The SkyWalking OAP access token.",
                            "type": "string"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service for the SkyWalking receiver.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"skywalking.default.svc.cluster.local\" or \"bar/skywalking.example.com\".",
                            "type": "string"
                          }
                        }
                      },
                      "stackdriver": {
                        "description": "Configures a Stackdriver provider.",
                        "type": "object",
                        "properties": {
                          "debug": {
                            "description": "debug enables trace output to stdout.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                            "type": "boolean"
                          },
                          "logging": {
                            "description": "Optional. Controls Stackdriver logging behavior.",
                            "type": "object",
                            "properties": {
                              "labels": {
                                "description": "Collection of tag names and tag expressions to include in the log\nentry. Conflicts are resolved by the tag name by overriding previously\nsupplied values.\n\nExample:\n\n\tlabels:\n\t  path: request.url_path\n\t  foo: request.headers['x-foo']",
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "maxNumberOfAnnotations": {
                            "description": "The global default max number of annotation events per span.\ndefault is 200.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "maxNumberOfAttributes": {
                            "description": "The global default max number of attributes per span.\ndefault is 200.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "maxNumberOfMessageEvents": {
                            "description": "The global default max number of message events per span.\ndefault is 200.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                            "type": "integer",
                            "format": "int64"
                          },
                          "maxTagLength": {
                            "description": "Optional. Controls the overall path length allowed in a reported span.\nNOTE: currently only controls max length of the path tag.",
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      },
                      "zipkin": {
                        "description": "Configures a tracing provider that uses the Zipkin API.",
                        "type": "object",
                        "required": [
                          "port",
                          "service"
                        ],
                        "properties": {
                          "enable64bitTraceId": {
                            "description": "Optional. A 128 bit trace id will be used in Istio.\nIf true, will result in a 64 bit trace id being used.",
                            "type": "boolean"
                          },
                          "maxTagLength": {
                            "description": "Optional. Controls the overall path length allowed in a reported span.\nNOTE: currently only controls max length of the path tag.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "path": {
                            "description": "Optional. Specifies the endpoint of Zipkin API.\nThe default value is \"/api/v2/spans\".",
                            "type": "string"
                          },
                          "port": {
                            "description": "REQUIRED. Specifies the port of the service.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "service": {
                            "description": "REQUIRED. Specifies the service that the Zipkin API.\nThe format is `[<Namespace>/]<Hostname>`. The specification of `<Namespace>` is required only when it is insufficient\nto unambiguously resolve a service in the service registry. The `<Hostname>` is a fully qualified host name of a\nservice defined by the Kubernetes service or ServiceEntry.\n\nExample: \"zipkin.default.svc.cluster.local\" or \"bar/zipkin.example.com\".",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "x-kubernetes-validations": [
                      {
                        "message": "At most one of [envoyExtAuthzHttp envoyExtAuthzGrpc zipkin lightstep datadog stackdriver opencensus skywalking opentelemetry prometheus envoyFileAccessLog envoyHttpAls envoyTcpAls envoyOtelAls] should be set",
                        "rule": "(has(self.envoyExtAuthzHttp)?1:0) + (has(self.envoyExtAuthzGrpc)?1:0) + (has(self.zipkin)?1:0) + (has(self.lightstep)?1:0) + (has(self.datadog)?1:0) + (has(self.stackdriver)?1:0) + (has(self.opencensus)?1:0) + (has(self.skywalking)?1:0) + (has(self.opentelemetry)?1:0) + (has(self.prometheus)?1:0) + (has(self.envoyFileAccessLog)?1:0) + (has(self.envoyHttpAls)?1:0) + (has(self.envoyTcpAls)?1:0) + (has(self.envoyOtelAls)?1:0) <= 1"
                      }
                    ]
                  }
                },
                "h2UpgradePolicy": {
                  "description": "Specify if http1.1 connections should be upgraded to http2 by default.\nif sidecar is installed on all pods in the mesh, then this should be set to `UPGRADE`.\nIf one or more services or namespaces do not have sidecar(s), then this should be set to `DO_NOT_UPGRADE`.\nIt can be enabled by destination using the `destinationRule.trafficPolicy.connectionPool.http.h2UpgradePolicy` override.",
                  "type": "string",
                  "enum": [
                    "DO_NOT_UPGRADE",
                    "UPGRADE"
                  ]
                },
                "inboundClusterStatName": {
                  "description": "Name to be used while emitting statistics for inbound clusters. The same pattern is used while computing stat prefix for\nnetwork filters like TCP and Redis.\nBy default, Istio emits statistics with the pattern `inbound|<port>|<port-name>|<service-FQDN>`.\nFor example `inbound|7443|grpc-reviews|reviews.prod.svc.cluster.local`. This can be used to override that pattern.\n\nA Pattern can be composed of various pre-defined variables. The following variables are supported.\n\n- `%SERVICE%` - Will be substituted with short hostname of the service.\n- `%SERVICE_NAME%` - Will be substituted with name of the service.\n- `%SERVICE_FQDN%` - Will be substituted with FQDN of the service.\n- `%SERVICE_PORT%` - Will be substituted with port of the service.\n- `%TARGET_PORT%`  - Will be substituted with the target port of the service.\n- `%SERVICE_PORT_NAME%` - Will be substituted with port name of the service.\n\nFollowing are some examples of supported patterns for reviews:\n\n- `%SERVICE_FQDN%_%SERVICE_PORT%` will use reviews.prod.svc.cluster.local_7443 as the stats name.\n- `%SERVICE%` will use reviews.prod as the stats name.",
                  "type": "string"
                },
                "inboundTrafficPolicy": {
                  "description": "Set the default behavior of the sidecar for handling inbound\ntraffic to the application.  If your application listens on\nlocalhost, you will need to set this to `LOCALHOST`.",
                  "type": "object",
                  "properties": {
                    "mode": {
                      "type": "string",
                      "enum": [
                        "PASSTHROUGH",
                        "LOCALHOST"
                      ]
                    }
                  }
                },
                "ingressClass": {
                  "description": "Class of ingress resources to be processed by Istio ingress\ncontroller. This corresponds to the value of\n`kubernetes.io/ingress.class` annotation.",
                  "type": "string"
                },
                "ingressControllerMode": {
                  "description": "Defines whether to use Istio ingress controller for annotated or all ingress resources.\nDefault mode is `STRICT`.",
                  "type": "string",
                  "enum": [
                    "UNSPECIFIED",
                    "OFF",
                    "DEFAULT",
                    "STRICT"
                  ]
                },
                "ingressSelector": {
                  "description": "Defines which gateway deployment to use as the Ingress controller. This field corresponds to\nthe Gateway.selector field, and will be set as `istio: INGRESS_SELECTOR`.\nBy default, `ingressgateway` is used, which will select the default IngressGateway as it has the\n`istio: ingressgateway` labels.\nIt is recommended that this is the same value as ingressService.",
                  "type": "string"
                },
                "ingressService": {
                  "description": "Name of the Kubernetes service used for the istio ingress controller.\nIf no ingress controller is specified, the default value `istio-ingressgateway` is used.",
                  "type": "string"
                },
                "localityLbSetting": {
                  "description": "Locality based load balancing distribution or failover settings.\nIf unspecified, locality based load balancing will be enabled by default.\nHowever, this requires outlierDetection to actually take effect for a particular\nservice, see https://istio.io/latest/docs/tasks/traffic-management/locality-load-balancing/failover/",
                  "type": "object",
                  "properties": {
                    "distribute": {
                      "description": "Optional: only one of distribute, failover or failoverPriority can be set.\nExplicitly specify loadbalancing weight across different zones and geographical locations.\nRefer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight)\nIf empty, the locality weight is set according to the endpoints number within it.",
                      "type": "array",
                      "items": {
                        "description": "Describes how traffic originating in the 'from' zone or sub-zone is\ndistributed over a set of 'to' zones. Syntax for specifying a zone is\n{region}/{zone}/{sub-zone} and terminal wildcards are allowed on any\nsegment of the specification. Examples:\n\n`*` - matches all localities\n\n`us-west/*` - all zones and sub-zones within the us-west region\n\n`us-west/zone-1/*` - all sub-zones within us-west/zone-1",
                        "type": "object",
                        "properties": {
                          "from": {
                            "description": "Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.",
                            "type": "string"
                          },
                          "to": {
                            "description": "Map of upstream localities to traffic distribution weights. The sum of\nall weights should be 100. Any locality not present will\nreceive no traffic.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "integer",
                              "format": "int32"
                            }
                          }
                        }
                      }
                    },
                    "enabled": {
                      "description": "Enable locality load balancing. This is DestinationRule-level and will override mesh-wide settings in entirety.\ne.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh-wide settings is.",
                      "type": "boolean"
                    },
                    "failover": {
                      "description": "Optional: only one of distribute, failover or failoverPriority can be set.\nExplicitly specify the region traffic will land on when endpoints in local region becomes unhealthy.\nShould be used together with OutlierDetection to detect unhealthy endpoints.\nNote: if no OutlierDetection specified, this will not take effect.",
                      "type": "array",
                      "items": {
                        "description": "Specify the traffic failover policy across regions. Since zone and sub-zone\nfailover is supported by default this only needs to be specified for\nregions when the operator needs to constrain traffic failover so that\nthe default behavior of failing over to any endpoint globally does not\napply. This is useful when failing over traffic across regions would not\nimprove service health or may need to be restricted for other reasons\nlike regulatory controls.",
                        "type": "object",
                        "properties": {
                          "from": {
                            "description": "Originating region.",
                            "type": "string"
                          },
                          "to": {
                            "description": "Destination region the traffic will fail over to when endpoints in\nthe 'from' region becomes unhealthy.",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "failoverPriority": {
                      "description": "failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.\nThis is to support traffic failover across different groups of endpoints.\nTwo kinds of labels can be specified:\n\n  - Specify only label keys `[key1, key2, key3]`, istio would compare the label values of client with endpoints.\n    Suppose there are total N label keys `[key1, key2, key3, ...keyN]` specified:\n\n    1. Endpoints matching all N labels with the client proxy have priority P(0) i.e. the highest priority.\n    2. Endpoints matching the first N-1 labels with the client proxy have priority P(1) i.e. second highest priority.\n    3. By extension of this logic, endpoints matching only the first label with the client proxy has priority P(N-1) i.e. second lowest priority.\n    4. All the other endpoints have priority P(N) i.e. lowest priority.\n\n  - Specify labels with key and value `[key1=value1, key2=value2, key3=value3]`, istio would compare the labels with endpoints.\n    Suppose there are total N labels `[key1=value1, key2=value2, key3=value3, ...keyN=valueN]` specified:\n\n    1. Endpoints matching all N labels have priority P(0) i.e. the highest priority.\n    2. Endpoints matching the first N-1 labels have priority P(1) i.e. second highest priority.\n    3. By extension of this logic, endpoints matching only the first label has priority P(N-1) i.e. second lowest priority.\n    4. All the other endpoints have priority P(N) i.e. lowest priority.\n\nNote: For a label to be considered for match, the previous labels must match, i.e. nth label would be considered matched only if first n-1 labels match.\n\nIt can be any label specified on both client and server workloads.\nThe following labels which have special semantic meaning are also supported:\n\n  - `topology.istio.io/network` is used to match the network metadata of an endpoint, which can be specified by pod/namespace label `topology.istio.io/network`, sidecar env `ISTIO_META_NETWORK` or MeshNetworks.\n  - `topology.istio.io/cluster` is used to match the clusterID of an endpoint, which can be specified by pod label `topology.istio.io/cluster` or pod env `ISTIO_META_CLUSTER_ID`.\n  - `topology.kubernetes.io/region` is used to match the region metadata of an endpoint, which maps to Kubernetes node label `topology.kubernetes.io/region` or the deprecated label `failure-domain.beta.kubernetes.io/region`.\n  - `topology.kubernetes.io/zone` is used to match the zone metadata of an endpoint, which maps to Kubernetes node label `topology.kubernetes.io/zone` or the deprecated label `failure-domain.beta.kubernetes.io/zone`.\n  - `topology.istio.io/subzone` is used to match the subzone metadata of an endpoint, which maps to Istio node label `topology.istio.io/subzone`.\n  - `kubernetes.io/hostname` is used to match the current node of an endpoint, which maps to Kubernetes node label `kubernetes.io/hostname`.\n\nThe below topology config indicates the following priority levels:\n\n```yaml\nfailoverPriority:\n- \"topology.istio.io/network\"\n- \"topology.kubernetes.io/region\"\n- \"topology.kubernetes.io/zone\"\n- \"topology.istio.io/subzone\"\n```\n\n1. endpoints match same [network, region, zone, subzone] label with the client proxy have the highest priority.\n2. endpoints have same [network, region, zone] label but different [subzone] label with the client proxy have the second highest priority.\n3. endpoints have same [network, region] label but different [zone] label with the client proxy have the third highest priority.\n4. endpoints have same [network] but different [region] labels with the client proxy have the fourth highest priority.\n5. all the other endpoints have the same lowest priority.\n\nSuppose a service associated endpoints reside in multi clusters, the below example represents:\n1. endpoints in `clusterA` and has `version=v1` label have P(0) priority.\n2. endpoints not in `clusterA` but has `version=v1` label have P(1) priority.\n2. all the other endpoints have P(2) priority.\n\n```yaml\nfailoverPriority:\n- \"version=v1\"\n- \"topology.istio.io/cluster=clusterA\"\n```\n\nOptional: only one of distribute, failover or failoverPriority can be set.\nAnd it should be used together with `OutlierDetection` to detect unhealthy endpoints, otherwise has no effect.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                },
                "meshMTLS": {
                  "description": "The below configuration parameters can be used to specify TLSConfig for mesh traffic.\nFor example, a user could enable min TLS version for ISTIO_MUTUAL traffic and specify a curve for non ISTIO_MUTUAL traffic like below:\n```yaml\nmeshConfig:\n\n\tmeshMTLS:\n\t  minProtocolVersion: TLSV1_3\n\ttlsDefaults:\n\t  Note: applicable only for non ISTIO_MUTUAL scenarios\n\t  ecdhCurves:\n\t    - P-256\n\t    - P-512\n\n```\nConfiguration of mTLS for traffic between workloads with ISTIO_MUTUAL TLS traffic.\n\nNote: Mesh mTLS does not respect ECDH curves.",
                  "type": "object",
                  "properties": {
                    "cipherSuites": {
                      "description": "Optional: If specified, the TLS connection will only support the specified cipher list when negotiating TLS 1.0-1.2.\nIf not specified, the following cipher suites will be used:\n```\nECDHE-ECDSA-AES256-GCM-SHA384\nECDHE-RSA-AES256-GCM-SHA384\nECDHE-ECDSA-AES128-GCM-SHA256\nECDHE-RSA-AES128-GCM-SHA256\nAES256-GCM-SHA384\nAES128-GCM-SHA256\n```",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "ecdhCurves": {
                      "description": "Optional: If specified, the TLS connection will only support the specified ECDH curves for the DH key exchange.\nIf not specified, the default curves enforced by Envoy will be used. For details about the default curves, refer to\n[Ecdh Curves](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto).",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "minProtocolVersion": {
                      "description": "Optional: the minimum TLS protocol version. The default minimum\nTLS version will be TLS 1.2. As servers may not be Envoy and be\nset to TLS 1.2 (e.g., workloads using mTLS without sidecars), the\nminimum TLS version for clients may also be TLS 1.2.\nIn the current Istio implementation, the maximum TLS protocol version\nis TLS 1.3.",
                      "type": "string",
                      "enum": [
                        "TLS_AUTO",
                        "TLSV1_2",
                        "TLSV1_3"
                      ]
                    }
                  }
                },
                "outboundClusterStatName": {
                  "description": "Name to be used while emitting statistics for outbound clusters. The same pattern is used while computing stat prefix for\nnetwork filters like TCP and Redis.\nBy default, Istio emits statistics with the pattern `outbound|<port>|<subsetname>|<service-FQDN>`.\nFor example `outbound|8080|v2|reviews.prod.svc.cluster.local`. This can be used to override that pattern.\n\nA Pattern can be composed of various pre-defined variables. The following variables are supported.\n\n- `%SERVICE%` - Will be substituted with short hostname of the service.\n- `%SERVICE_NAME%` - Will be substituted with name of the service.\n- `%SERVICE_FQDN%` - Will be substituted with FQDN of the service.\n- `%SERVICE_PORT%` - Will be substituted with port of the service.\n- `%SERVICE_PORT_NAME%` - Will be substituted with port name of the service.\n- `%SUBSET_NAME%` - Will be substituted with subset.\n\nFollowing are some examples of supported patterns for reviews:\n\n- `%SERVICE_FQDN%_%SERVICE_PORT%` will use `reviews.prod.svc.cluster.local_7443` as the stats name.\n- `%SERVICE%` will use reviews.prod as the stats name.",
                  "type": "string"
                },
                "outboundTrafficPolicy": {
                  "description": "Set the default behavior of the sidecar for handling outbound\ntraffic from the application.\n\nCan be overridden at a Sidecar level by setting the `OutboundTrafficPolicy` in the\n[Sidecar API](https://istio.io/docs/reference/config/networking/sidecar/#OutboundTrafficPolicy).\n\nDefault mode is `ALLOW_ANY`, which means outbound traffic to unknown destinations will be allowed.",
                  "type": "object",
                  "properties": {
                    "mode": {
                      "type": "string",
                      "enum": [
                        "REGISTRY_ONLY",
                        "ALLOW_ANY"
                      ]
                    }
                  }
                },
                "pathNormalization": {
                  "description": "ProxyPathNormalization configures how URL paths in incoming and outgoing HTTP requests are\nnormalized by the sidecars and gateways.\nThe normalized paths will be used in all aspects through the requests' lifetime on the\nsidecars and gateways, which includes routing decisions in outbound direction (client proxy),\nauthorization policy match and enforcement in inbound direction (server proxy), and the URL\npath proxied to the upstream service.\nIf not set, the NormalizationType.DEFAULT configuration will be used.",
                  "type": "object",
                  "properties": {
                    "normalization": {
                      "type": "string",
                      "enum": [
                        "DEFAULT",
                        "NONE",
                        "BASE",
                        "MERGE_SLASHES",
                        "DECODE_AND_MERGE_SLASHES"
                      ]
                    }
                  }
                },
                "protocolDetectionTimeout": {
                  "description": "Automatic protocol detection uses a set of heuristics to\ndetermine whether the connection is using TLS or not (on the\nserver side), as well as the application protocol being used\n(e.g., http vs tcp). These heuristics rely on the client sending\nthe first bits of data. For server first protocols like MySQL,\nMongoDB, etc. Envoy will timeout on the protocol detection after\nthe specified period, defaulting to non mTLS plain TCP\ntraffic. Set this field to tweak the period that Envoy will wait\nfor the client to send the first bits of data. (MUST be >=1ms or\n0s to disable). Default detection timeout is 0s (no timeout).\n\nSetting a timeout is not recommended nor safe. Even high timeouts (>5s) will be hit\noccasionally, and when they occur the result is typically broken traffic that may not\nrecover on its own. Exceptionally high values might solve this, but injecting 60s delays\nonto new connections is generally not tenable anyways.",
                  "type": "string"
                },
                "proxyHttpPort": {
                  "description": "Port on which Envoy should listen for HTTP PROXY requests if set.",
                  "type": "integer",
                  "format": "int32"
                },
                "proxyInboundListenPort": {
                  "description": "Port on which Envoy should listen for all inbound traffic to the pod/vm will be captured to.\nDefault port is 15006.",
                  "type": "integer",
                  "format": "int32"
                },
                "proxyListenPort": {
                  "description": "Port on which Envoy should listen for all outbound traffic to other services.\nDefault port is 15001.",
                  "type": "integer",
                  "format": "int32"
                },
                "rootNamespace": {
                  "description": "The namespace to treat as the administrative root namespace for\nIstio configuration. When processing a leaf namespace Istio will search for\ndeclarations in that namespace first and if none are found it will\nsearch in the root namespace. Any matching declaration found in the root\nnamespace is processed as if it were declared in the leaf namespace.\n\nThe precise semantics of this processing are documented on each resource\ntype.",
                  "type": "string"
                },
                "serviceSettings": {
                  "description": "Settings to be applied to select services.",
                  "type": "array",
                  "items": {
                    "description": "Settings to be applied to select services.\n\nFor example, the following configures all services in namespace \"foo\" as well as the\n\"bar\" service in namespace \"baz\" to be considered cluster-local:\n\n```yaml\nserviceSettings:\n  - settings:\n    clusterLocal: true\n    hosts:\n  - \"*.foo.svc.cluster.local\"\n  - \"bar.baz.svc.cluster.local\"\n\n```",
                    "type": "object",
                    "properties": {
                      "hosts": {
                        "description": "The services to which the Settings should be applied. Services are selected using the hostname\nmatching rules used by DestinationRule.\n\nFor example: foo.bar.svc.cluster.local, *.baz.svc.cluster.local",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "settings": {
                        "description": "The settings to apply to the selected services.",
                        "type": "object",
                        "properties": {
                          "clusterLocal": {
                            "description": "If true, specifies that the client and service endpoints must reside in the same cluster.\nBy default, in multi-cluster deployments, the Istio control plane assumes all service\nendpoints to be reachable from any client in any of the clusters which are part of the\nmesh. This configuration option limits the set of service endpoints visible to a client\nto be cluster scoped.\n\nThere are some common scenarios when this can be useful:\n\n  - A service (or group of services) is inherently local to the cluster and has local storage\n    for that cluster. For example, the kube-system namespace (e.g. the Kube API Server).\n  - A mesh administrator wants to slowly migrate services to Istio. They might start by first\n    having services cluster-local and then slowly transition them to mesh-wide. They could do\n    this service-by-service (e.g. mysvc.myns.svc.cluster.local) or as a group\n    (e.g. *.myns.svc.cluster.local).\n\nBy default Istio will consider kubernetes.default.svc (i.e. the API Server) as well as all\nservices in the kube-system namespace to be cluster-local, unless explicitly overridden here.",
                            "type": "boolean"
                          }
                        }
                      }
                    }
                  }
                },
                "tcpKeepalive": {
                  "description": "If set then set `SO_KEEPALIVE` on the socket to enable TCP Keepalives.",
                  "type": "object",
                  "properties": {
                    "interval": {
                      "description": "The time duration between keep-alive probes.\nDefault is to use the OS level configuration\n(unless overridden, Linux defaults to 75s.)",
                      "type": "string"
                    },
                    "probes": {
                      "description": "Maximum number of keepalive probes to send without response before\ndeciding the connection is dead. Default is to use the OS level configuration\n(unless overridden, Linux defaults to 9.)",
                      "type": "integer",
                      "format": "int32"
                    },
                    "time": {
                      "description": "The time duration a connection needs to be idle before keep-alive\nprobes start being sent. Default is to use the OS level configuration\n(unless overridden, Linux defaults to 7200s (ie 2 hours.)",
                      "type": "string"
                    }
                  }
                },
                "tlsDefaults": {
                  "description": "Configuration of TLS for all traffic except for ISTIO_MUTUAL mode.\nCurrently, this supports configuration of ecdhCurves and cipherSuites only.\nFor ISTIO_MUTUAL TLS settings, use meshMTLS configuration.",
                  "type": "object",
                  "properties": {
                    "cipherSuites": {
                      "description": "Optional: If specified, the TLS connection will only support the specified cipher list when negotiating TLS 1.0-1.2.\nIf not specified, the following cipher suites will be used:\n```\nECDHE-ECDSA-AES256-GCM-SHA384\nECDHE-RSA-AES256-GCM-SHA384\nECDHE-ECDSA-AES128-GCM-SHA256\nECDHE-RSA-AES128-GCM-SHA256\nAES256-GCM-SHA384\nAES128-GCM-SHA256\n```",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "ecdhCurves": {
                      "description": "Optional: If specified, the TLS connection will only support the specified ECDH curves for the DH key exchange.\nIf not specified, the default curves enforced by Envoy will be used. For details about the default curves, refer to\n[Ecdh Curves](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto).",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "minProtocolVersion": {
                      "description": "Optional: the minimum TLS protocol version. The default minimum\nTLS version will be TLS 1.2. As servers may not be Envoy and be\nset to TLS 1.2 (e.g., workloads using mTLS without sidecars), the\nminimum TLS version for clients may also be TLS 1.2.\nIn the current Istio implementation, the maximum TLS protocol version\nis TLS 1.3.",
                      "type": "string",
                      "enum": [
                        "TLS_AUTO",
                        "TLSV1_2",
                        "TLSV1_3"
                      ]
                    }
                  }
                },
                "trustDomain": {
                  "description": "The trust domain corresponds to the trust root of a system.\nRefer to [SPIFFE-ID](https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain)",
                  "type": "string"
                },
                "trustDomainAliases": {
                  "description": "The trust domain aliases represent the aliases of `trustDomain`.\nFor example, if we have\n```yaml\ntrustDomain: td1\ntrustDomainAliases: [\"td2\", \"td3\"]\n```\nAny service with the identity `td1/ns/foo/sa/a-service-account`, `td2/ns/foo/sa/a-service-account`,\nor `td3/ns/foo/sa/a-service-account` will be treated the same in the Istio mesh.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "verifyCertificateAtClient": {
                  "description": "`VerifyCertificateAtClient` sets the mesh global default for peer certificate validation\nat the client-side proxy when `SIMPLE` TLS or `MUTUAL` TLS (non `ISTIO_MUTUAL`) origination\nmodes are used. This setting can be overridden at the host level via DestinationRule API.\nBy default, `VerifyCertificateAtClient` is `true`.\n\n`CaCertificates`: If set, proxy verifies CA signature based on given CaCertificates. If unset,\nand VerifyCertificateAtClient is true, proxy uses default System CA bundle. If unset and\n`VerifyCertificateAtClient` is false, proxy will not verify the CA.\n\n`SubjectAltNames`: If set, proxy verifies subject alt names are present in the SAN. If unset,\nand `VerifyCertificateAtClient` is true, proxy uses host in destination rule to verify the SANs.\nIf unset, and `VerifyCertificateAtClient` is false, proxy does not verify SANs.\n\nFor SAN, client-side proxy will exact match host in `DestinationRule` as well as one level\nwildcard if the specified host in DestinationRule doesn't contain a wildcard.\nFor example, if the host in `DestinationRule` is `x.y.com`, client-side proxy will\nmatch either `x.y.com` or `*.y.com` for the SAN in the presented server certificate.\nFor wildcard host name in DestinationRule, client-side proxy will do a suffix match. For example,\nif host is `*.x.y.com`, client-side proxy will verify the presented server certificate SAN matches\n\u201c.x.y.com` suffix.\n\nDeprecated: Marked as deprecated in mesh/v1alpha1/config.proto.",
                  "type": "boolean"
                }
              }
            },
            "pilot": {
              "description": "Configuration for the Pilot component.",
              "type": "object",
              "properties": {
                "affinity": {
                  "description": "K8s affinity to set on the Pilot Pods.",
                  "type": "object",
                  "properties": {
                    "nodeAffinity": {
                      "description": "Describes node affinity scheduling rules for the pod.",
                      "type": "object",
                      "properties": {
                        "preferredDuringSchedulingIgnoredDuringExecution": {
                          "description": "The scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node matches the corresponding matchExpressions; the\nnode(s) with the highest sum are the most preferred.",
                          "type": "array",
                          "items": {
                            "description": "An empty preferred scheduling term matches all objects with implicit weight 0\n(i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
                            "type": "object",
                            "required": [
                              "preference",
                              "weight"
                            ],
                            "properties": {
                              "preference": {
                                "description": "A node selector term, associated with the corresponding weight.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "A list of node selector requirements by node's labels.",
                                    "type": "array",
                                    "items": {
                                      "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "The label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        }
                                      }
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "matchFields": {
                                    "description": "A list of node selector requirements by node's fields.",
                                    "type": "array",
                                    "items": {
                                      "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "The label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        }
                                      }
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  }
                                },
                                "x-kubernetes-map-type": "atomic"
                              },
                              "weight": {
                                "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          },
                          "x-kubernetes-list-type": "atomic"
                        },
                        "requiredDuringSchedulingIgnoredDuringExecution": {
                          "description": "If the affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to an update), the system\nmay or may not try to eventually evict the pod from its node.",
                          "type": "object",
                          "required": [
                            "nodeSelectorTerms"
                          ],
                          "properties": {
                            "nodeSelectorTerms": {
                              "description": "Required. A list of node selector terms. The terms are ORed.",
                              "type": "array",
                              "items": {
                                "description": "A null or empty node selector term matches no objects. The requirements of\nthem are ANDed.\nThe TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "A list of node selector requirements by node's labels.",
                                    "type": "array",
                                    "items": {
                                      "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "The label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        }
                                      }
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "matchFields": {
                                    "description": "A list of node selector requirements by node's fields.",
                                    "type": "array",
                                    "items": {
                                      "description": "A node selector requirement is a selector that contains values, a key, and an operator\nthat relates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "The label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "Represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "An array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. If the operator is Gt or Lt, the values\narray must have a single element, which will be interpreted as an integer.\nThis array is replaced during a strategic merge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        }
                                      }
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  }
                                },
                                "x-kubernetes-map-type": "atomic"
                              },
                              "x-kubernetes-list-type": "atomic"
                            }
                          },
                          "x-kubernetes-map-type": "atomic"
                        }
                      }
                    },
                    "podAffinity": {
                      "description": "Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).",
                      "type": "object",
                      "properties": {
                        "preferredDuringSchedulingIgnoredDuringExecution": {
                          "description": "The scheduler will prefer to schedule pods to nodes that satisfy\nthe affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the\nnode(s) with the highest sum are the most preferred.",
                          "type": "array",
                          "items": {
                            "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                            "type": "object",
                            "required": [
                              "podAffinityTerm",
                              "weight"
                            ],
                            "properties": {
                              "podAffinityTerm": {
                                "description": "Required. A pod affinity term, associated with the corresponding weight.",
                                "type": "object",
                                "required": [
                                  "topologyKey"
                                ],
                                "properties": {
                                  "labelSelector": {
                                    "description": "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "matchLabelKeys": {
                                    "description": "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "mismatchLabelKeys": {
                                    "description": "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "namespaceSelector": {
                                    "description": "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "namespaces": {
                                    "description": "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "topologyKey": {
                                    "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.",
                                    "type": "string"
                                  }
                                }
                              },
                              "weight": {
                                "description": "weight associated with matching the corresponding podAffinityTerm,\nin the range 1-100.",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          },
                          "x-kubernetes-list-type": "atomic"
                        },
                        "requiredDuringSchedulingIgnoredDuringExecution": {
                          "description": "If the affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to a pod label update), the\nsystem may or may not try to eventually evict the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.",
                          "type": "array",
                          "items": {
                            "description": "Defines a set of pods (namely those matching the labelSelector\nrelative to the given namespace(s)) that this pod should be\nco-located (affinity) or not co-located (anti-affinity) with,\nwhere co-located is defined as running on a node whose value of\nthe label with key <topologyKey> matches that of any node on which\na pod of the set of pods is running",
                            "type": "object",
                            "required": [
                              "topologyKey"
                            ],
                            "properties": {
                              "labelSelector": {
                                "description": "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        }
                                      }
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "x-kubernetes-map-type": "atomic"
                              },
                              "matchLabelKeys": {
                                "description": "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                },
                                "x-kubernetes-list-type": "atomic"
                              },
                              "mismatchLabelKeys": {
                                "description": "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                },
                                "x-kubernetes-list-type": "atomic"
                              },
                              "namespaceSelector": {
                                "description": "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        }
                                      }
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "x-kubernetes-map-type": "atomic"
                              },
                              "namespaces": {
                                "description": "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                },
                                "x-kubernetes-list-type": "atomic"
                              },
                              "topologyKey": {
                                "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.",
                                "type": "string"
                              }
                            }
                          },
                          "x-kubernetes-list-type": "atomic"
                        }
                      }
                    },
                    "podAntiAffinity": {
                      "description": "Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).",
                      "type": "object",
                      "properties": {
                        "preferredDuringSchedulingIgnoredDuringExecution": {
                          "description": "The scheduler will prefer to schedule pods to nodes that satisfy\nthe anti-affinity expressions specified by this field, but it may choose\na node that violates one or more of the expressions. The node that is\nmost preferred is the one with the greatest sum of weights, i.e.\nfor each node that meets all of the scheduling requirements (resource\nrequest, requiredDuringScheduling anti-affinity expressions, etc.),\ncompute a sum by iterating through the elements of this field and adding\n\"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the\nnode(s) with the highest sum are the most preferred.",
                          "type": "array",
                          "items": {
                            "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                            "type": "object",
                            "required": [
                              "podAffinityTerm",
                              "weight"
                            ],
                            "properties": {
                              "podAffinityTerm": {
                                "description": "Required. A pod affinity term, associated with the corresponding weight.",
                                "type": "object",
                                "required": [
                                  "topologyKey"
                                ],
                                "properties": {
                                  "labelSelector": {
                                    "description": "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "matchLabelKeys": {
                                    "description": "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "mismatchLabelKeys": {
                                    "description": "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "namespaceSelector": {
                                    "description": "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "namespaces": {
                                    "description": "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "topologyKey": {
                                    "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.",
                                    "type": "string"
                                  }
                                }
                              },
                              "weight": {
                                "description": "weight associated with matching the corresponding podAffinityTerm,\nin the range 1-100.",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          },
                          "x-kubernetes-list-type": "atomic"
                        },
                        "requiredDuringSchedulingIgnoredDuringExecution": {
                          "description": "If the anti-affinity requirements specified by this field are not met at\nscheduling time, the pod will not be scheduled onto the node.\nIf the anti-affinity requirements specified by this field cease to be met\nat some point during pod execution (e.g. due to a pod label update), the\nsystem may or may not try to eventually evict the pod from its node.\nWhen there are multiple elements, the lists of nodes corresponding to each\npodAffinityTerm are intersected, i.e. all terms must be satisfied.",
                          "type": "array",
                          "items": {
                            "description": "Defines a set of pods (namely those matching the labelSelector\nrelative to the given namespace(s)) that this pod should be\nco-located (affinity) or not co-located (anti-affinity) with,\nwhere co-located is defined as running on a node whose value of\nthe label with key <topologyKey> matches that of any node on which\na pod of the set of pods is running",
                            "type": "object",
                            "required": [
                              "topologyKey"
                            ],
                            "properties": {
                              "labelSelector": {
                                "description": "A label query over a set of resources, in this case pods.\nIf it's null, this PodAffinityTerm matches with no Pods.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        }
                                      }
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "x-kubernetes-map-type": "atomic"
                              },
                              "matchLabelKeys": {
                                "description": "MatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                },
                                "x-kubernetes-list-type": "atomic"
                              },
                              "mismatchLabelKeys": {
                                "description": "MismatchLabelKeys is a set of pod label keys to select which pods will\nbe taken into consideration. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\nto select the group of existing pods which pods will be taken into consideration\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\npod labels will be ignored. The default value is empty.\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\nThis is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                },
                                "x-kubernetes-list-type": "atomic"
                              },
                              "namespaceSelector": {
                                "description": "A label query over the set of namespaces that the term applies to.\nThe term is applied to the union of the namespaces selected by this field\nand the ones listed in the namespaces field.\nnull selector and null or empty namespaces list means \"this pod's namespace\".\nAn empty selector ({}) matches all namespaces.",
                                "type": "object",
                                "properties": {
                                  "matchExpressions": {
                                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                    "type": "array",
                                    "items": {
                                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                      "type": "object",
                                      "required": [
                                        "key",
                                        "operator"
                                      ],
                                      "properties": {
                                        "key": {
                                          "description": "key is the label key that the selector applies to.",
                                          "type": "string"
                                        },
                                        "operator": {
                                          "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                          "type": "string"
                                        },
                                        "values": {
                                          "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                          "type": "array",
                                          "items": {
                                            "type": "string"
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        }
                                      }
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "matchLabels": {
                                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    }
                                  }
                                },
                                "x-kubernetes-map-type": "atomic"
                              },
                              "namespaces": {
                                "description": "namespaces specifies a static list of namespace names that the term applies to.\nThe term is applied to the union of the namespaces listed in this field\nand the ones selected by namespaceSelector.\nnull or empty namespaces list and null namespaceSelector means \"this pod's namespace\".",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                },
                                "x-kubernetes-list-type": "atomic"
                              },
                              "topologyKey": {
                                "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\nwhose value of the label with key topologyKey matches that of any node on which any of the\nselected pods is running.\nEmpty topologyKey is not allowed.",
                                "type": "string"
                              }
                            }
                          },
                          "x-kubernetes-list-type": "atomic"
                        }
                      }
                    }
                  }
                },
                "autoscaleBehavior": {
                  "description": "See https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#configurable-scaling-behavior",
                  "type": "object",
                  "properties": {
                    "scaleDown": {
                      "description": "scaleDown is scaling policy for scaling Down.\nIf not set, the default value is to allow to scale down to minReplicas pods, with a\n300 second stabilization window (i.e., the highest recommendation for\nthe last 300sec is used).",
                      "type": "object",
                      "properties": {
                        "policies": {
                          "description": "policies is a list of potential scaling polices which can be used during scaling.\nAt least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid",
                          "type": "array",
                          "items": {
                            "description": "HPAScalingPolicy is a single policy which must hold true for a specified past interval.",
                            "type": "object",
                            "required": [
                              "periodSeconds",
                              "type",
                              "value"
                            ],
                            "properties": {
                              "periodSeconds": {
                                "description": "periodSeconds specifies the window of time for which the policy should hold true.\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).",
                                "type": "integer",
                                "format": "int32"
                              },
                              "type": {
                                "description": "type is used to specify the scaling policy.",
                                "type": "string"
                              },
                              "value": {
                                "description": "value contains the amount of change which is permitted by the policy.\nIt must be greater than zero",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          },
                          "x-kubernetes-list-type": "atomic"
                        },
                        "selectPolicy": {
                          "description": "selectPolicy is used to specify which policy should be used.\nIf not set, the default value Max is used.",
                          "type": "string"
                        },
                        "stabilizationWindowSeconds": {
                          "description": "stabilizationWindowSeconds is the number of seconds for which past recommendations should be\nconsidered while scaling up or scaling down.\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\nIf not set, use the default values:\n- For scale up: 0 (i.e. no stabilization is done).\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    },
                    "scaleUp": {
                      "description": "scaleUp is scaling policy for scaling Up.\nIf not set, the default value is the higher of:\n  * increase no more than 4 pods per 60 seconds\n  * double the number of pods per 60 seconds\nNo stabilization is used.",
                      "type": "object",
                      "properties": {
                        "policies": {
                          "description": "policies is a list of potential scaling polices which can be used during scaling.\nAt least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid",
                          "type": "array",
                          "items": {
                            "description": "HPAScalingPolicy is a single policy which must hold true for a specified past interval.",
                            "type": "object",
                            "required": [
                              "periodSeconds",
                              "type",
                              "value"
                            ],
                            "properties": {
                              "periodSeconds": {
                                "description": "periodSeconds specifies the window of time for which the policy should hold true.\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).",
                                "type": "integer",
                                "format": "int32"
                              },
                              "type": {
                                "description": "type is used to specify the scaling policy.",
                                "type": "string"
                              },
                              "value": {
                                "description": "value contains the amount of change which is permitted by the policy.\nIt must be greater than zero",
                                "type": "integer",
                                "format": "int32"
                              }
                            }
                          },
                          "x-kubernetes-list-type": "atomic"
                        },
                        "selectPolicy": {
                          "description": "selectPolicy is used to specify which policy should be used.\nIf not set, the default value Max is used.",
                          "type": "string"
                        },
                        "stabilizationWindowSeconds": {
                          "description": "stabilizationWindowSeconds is the number of seconds for which past recommendations should be\nconsidered while scaling up or scaling down.\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\nIf not set, use the default values:\n- For scale up: 0 (i.e. no stabilization is done).\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    }
                  }
                },
                "autoscaleEnabled": {
                  "description": "Controls whether a HorizontalPodAutoscaler is installed for Pilot.",
                  "type": "boolean"
                },
                "autoscaleMax": {
                  "description": "Maximum number of replicas in the HorizontalPodAutoscaler for Pilot.",
                  "type": "integer",
                  "format": "int32"
                },
                "autoscaleMin": {
                  "description": "Minimum number of replicas in the HorizontalPodAutoscaler for Pilot.",
                  "type": "integer",
                  "format": "int32"
                },
                "cni": {
                  "description": "Configures whether to use an existing CNI installation for workloads",
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "description": "Controls whether CNI should be used.",
                      "type": "boolean"
                    },
                    "provider": {
                      "description": "Specifies the CNI provider. Can be either \"default\" or \"multus\". When set to \"multus\", an annotation\n`k8s.v1.cni.cncf.io/networks` is set on injected pods to point to a NetworkAttachmentDefinition",
                      "type": "string"
                    }
                  }
                },
                "configMap": {
                  "description": "Configuration settings passed to Pilot as a ConfigMap.\n\nThis controls whether the mesh config map, generated from values.yaml is generated.\nIf false, pilot wil use default values or user-supplied values, in that order of preference.",
                  "type": "boolean"
                },
                "cpu": {
                  "description": "Target CPU utilization used in HorizontalPodAutoscaler.\n\nSee https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "object",
                  "properties": {
                    "targetAverageUtilization": {
                      "description": "K8s utilization setting for HorizontalPodAutoscaler target.\n\nSee https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/",
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                },
                "deploymentLabels": {
                  "description": "Labels that are added to Pilot deployment.\n\nSee https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "enabled": {
                  "description": "Controls whether Pilot is enabled.",
                  "type": "boolean"
                },
                "env": {
                  "description": "Environment variables passed to the Pilot container.\n\nExamples:\nenv:\n\n\tENV_VAR_1: value1\n\tENV_VAR_2: value2",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "extraContainerArgs": {
                  "description": "Additional container arguments for the Pilot container.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "hub": {
                  "description": "Hub to pull the container image from. Image will be `Hub/Image:Tag-Variant`.",
                  "type": "string"
                },
                "image": {
                  "description": "Image name used for Pilot.\n\nThis can be set either to image name if hub is also set, or can be set to the full hub:name string.\n\nExamples: custom-pilot, docker.io/someuser:custom-pilot",
                  "type": "string"
                },
                "ipFamilies": {
                  "description": "Defines which IP family to use for single stack or the order of IP families for dual-stack.\nValid list items are \"IPv4\", \"IPv6\".\nMore info: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ipFamilyPolicy": {
                  "description": "Controls whether Services are configured to use IPv4, IPv6, or both. Valid options\nare PreferDualStack, RequireDualStack, and SingleStack.\nMore info: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services",
                  "type": "string"
                },
                "istiodRemote": {
                  "description": "Configuration for the istio-discovery chart when istiod is running in a remote cluster (e.g. \"remote control plane\").",
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "description": "Indicates if this cluster/install should consume a \"remote\" istiod instance,",
                      "type": "boolean"
                    },
                    "injectionCABundle": {
                      "description": "injector ca bundle",
                      "type": "string"
                    },
                    "injectionPath": {
                      "description": "Path to use for the sidecar injector webhook service.",
                      "type": "string"
                    },
                    "injectionURL": {
                      "description": "URL to use for sidecar injector webhook.",
                      "type": "string"
                    }
                  }
                },
                "jwksResolverExtraRootCA": {
                  "description": "Specifies an extra root certificate in PEM format. This certificate will be trusted\nby pilot when resolving JWKS URIs.",
                  "type": "string"
                },
                "keepaliveMaxServerConnectionAge": {
                  "description": "Maximum duration that a sidecar can be connected to a pilot.\n\nThis setting balances out load across pilot instances, but adds some resource overhead.\n\nExamples: 300s, 30m, 1h",
                  "type": "string"
                },
                "memory": {
                  "description": "Target memory utilization used in HorizontalPodAutoscaler.\n\nSee https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "object",
                  "properties": {
                    "targetAverageUtilization": {
                      "description": "K8s utilization setting for HorizontalPodAutoscaler target.\n\nSee https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/",
                      "type": "integer",
                      "format": "int32"
                    }
                  }
                },
                "nodeSelector": {
                  "description": "K8s node selector.\n\nSee https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "podAnnotations": {
                  "description": "K8s annotations for pods.\n\nSee: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "podLabels": {
                  "description": "Labels that are added to Pilot pods.\n\nSee https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "replicaCount": {
                  "description": "Number of replicas in the Pilot Deployment.\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "integer",
                  "format": "int32"
                },
                "resources": {
                  "description": "K8s resources settings.\n\nSee https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "object",
                  "properties": {
                    "claims": {
                      "description": "Claims lists the names of resources, defined in spec.resourceClaims,\nthat are used by this container.\n\nThis is an alpha field and requires enabling the\nDynamicResourceAllocation feature gate.\n\nThis field is immutable. It can only be set for containers.",
                      "type": "array",
                      "items": {
                        "description": "ResourceClaim references one entry in PodSpec.ResourceClaims.",
                        "type": "object",
                        "required": [
                          "name"
                        ],
                        "properties": {
                          "name": {
                            "description": "Name must match the name of one entry in pod.spec.resourceClaims of\nthe Pod where this field is used. It makes that resource available\ninside a container.",
                            "type": "string"
                          },
                          "request": {
                            "description": "Request is the name chosen for a request in the referenced claim.\nIf empty, everything from the claim is made available, otherwise\nonly the result of this request.",
                            "type": "string"
                          }
                        }
                      },
                      "x-kubernetes-list-map-keys": [
                        "name"
                      ],
                      "x-kubernetes-list-type": "map"
                    },
                    "limits": {
                      "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                      "type": "object",
                      "additionalProperties": {
                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                        "x-kubernetes-int-or-string": true
                      }
                    },
                    "requests": {
                      "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                      "type": "object",
                      "additionalProperties": {
                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                        "x-kubernetes-int-or-string": true
                      }
                    }
                  }
                },
                "rollingMaxSurge": {
                  "description": "K8s rolling update strategy\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "x-kubernetes-int-or-string": true
                },
                "rollingMaxUnavailable": {
                  "description": "The number of pods that can be unavailable during a rolling update (see\n`strategy.rollingUpdate.maxUnavailable` here:\nhttps://kubernetes.io/docs/reference/kubernetes-api/workload-resources/deployment-v1/#DeploymentSpec).\nMay be specified as a number of pods or as a percent of the total number\nof pods at the start of the update.\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "x-kubernetes-int-or-string": true
                },
                "seccompProfile": {
                  "description": "The seccompProfile for the Pilot container.\n\nSee: https://kubernetes.io/docs/tutorials/security/seccomp/",
                  "type": "object",
                  "required": [
                    "type"
                  ],
                  "properties": {
                    "localhostProfile": {
                      "description": "localhostProfile indicates a profile defined in a file on the node should be used.\nThe profile must be preconfigured on the node to work.\nMust be a descending path, relative to the kubelet's configured seccomp profile location.\nMust be set if type is \"Localhost\". Must NOT be set for any other type.",
                      "type": "string"
                    },
                    "type": {
                      "description": "type indicates which kind of seccomp profile will be applied.\nValid options are:\n\nLocalhost - a profile defined in a file on the node should be used.\nRuntimeDefault - the container runtime default profile should be used.\nUnconfined - no profile should be applied.",
                      "type": "string"
                    }
                  }
                },
                "serviceAccountAnnotations": {
                  "description": "K8s annotations for the service account",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "serviceAnnotations": {
                  "description": "K8s annotations for the Service.\n\nSee: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "tag": {
                  "description": "The container image tag to pull. Image will be `Hub/Image:Tag-Variant`.",
                  "type": "string"
                },
                "taint": {
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "description": "Enable the untaint controller for new nodes. This aims to solve a race for CNI installation on\nnew nodes. For this to work, the newly added nodes need to have the istio CNI taint as they are\nadded to the cluster. This is usually done by configuring the cluster infra provider.",
                      "type": "boolean"
                    },
                    "namespace": {
                      "description": "The namespace of the CNI daemonset, incase it's not the same as istiod.",
                      "type": "string"
                    }
                  }
                },
                "tolerations": {
                  "description": "The node tolerations to be applied to the Pilot deployment so that it can be\nscheduled to particular nodes with matching taints.\nMore info: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling\n\nDeprecated: Marked as deprecated in pkg/apis/values_types.proto.",
                  "type": "array",
                  "items": {
                    "description": "The pod this Toleration is attached to tolerates any taint that matches\nthe triple <key,value,effect> using the matching operator <operator>.",
                    "type": "object",
                    "properties": {
                      "effect": {
                        "description": "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                        "type": "string"
                      },
                      "key": {
                        "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                        "type": "string"
                      },
                      "operator": {
                        "description": "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a pod can\ntolerate all taints of a particular category.",
                        "type": "string"
                      },
                      "tolerationSeconds": {
                        "description": "TolerationSeconds represents the period of time the toleration (which must be\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\nit is not set, which means tolerate the taint forever (do not evict). Zero and\nnegative values will be treated as 0 (evict immediately) by the system.",
                        "type": "integer",
                        "format": "int64"
                      },
                      "value": {
                        "description": "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string.",
                        "type": "string"
                      }
                    }
                  }
                },
                "topologySpreadConstraints": {
                  "description": "The k8s topologySpreadConstraints for the Pilot pods.",
                  "type": "array",
                  "items": {
                    "description": "TopologySpreadConstraint specifies how to spread matching pods among the given topology.",
                    "type": "object",
                    "required": [
                      "maxSkew",
                      "topologyKey",
                      "whenUnsatisfiable"
                    ],
                    "properties": {
                      "labelSelector": {
                        "description": "LabelSelector is used to find matching pods.\nPods that match this label selector are counted to determine the number of pods\nin their corresponding topology domain.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string"
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "x-kubernetes-list-type": "atomic"
                                }
                              }
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        },
                        "x-kubernetes-map-type": "atomic"
                      },
                      "matchLabelKeys": {
                        "description": "MatchLabelKeys is a set of pod label keys to select the pods over which\nspreading will be calculated. The keys are used to lookup values from the\nincoming pod labels, those key-value labels are ANDed with labelSelector\nto select the group of existing pods over which spreading will be calculated\nfor the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.\nMatchLabelKeys cannot be set when LabelSelector isn't set.\nKeys that don't exist in the incoming pod labels will\nbe ignored. A null or empty list means only match against labelSelector.\n\nThis is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).",
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "x-kubernetes-list-type": "atomic"
                      },
                      "maxSkew": {
                        "description": "MaxSkew describes the degree to which pods may be unevenly distributed.\nWhen `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference\nbetween the number of matching pods in the target topology and the global minimum.\nThe global minimum is the minimum number of matching pods in an eligible domain\nor zero if the number of eligible domains is less than MinDomains.\nFor example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector spread as 2/2/1:\nIn this case, the global minimum is 1.\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |   P   |\n- if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;\nscheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)\nviolate MaxSkew(1).\n- if MaxSkew is 2, incoming pod can be scheduled onto any zone.\nWhen `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence\nto topologies that satisfy it.\nIt's a required field. Default value is 1 and 0 is not allowed.",
                        "type": "integer",
                        "format": "int32"
                      },
                      "minDomains": {
                        "description": "MinDomains indicates a minimum number of eligible domains.\nWhen the number of eligible domains with matching topology keys is less than minDomains,\nPod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed.\nAnd when the number of eligible domains with matching topology keys equals or greater than minDomains,\nthis value has no effect on scheduling.\nAs a result, when the number of eligible domains is less than minDomains,\nscheduler won't schedule more than maxSkew Pods to those domains.\nIf value is nil, the constraint behaves as if MinDomains is equal to 1.\nValid values are integers greater than 0.\nWhen value is not nil, WhenUnsatisfiable must be DoNotSchedule.\n\nFor example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same\nlabelSelector spread as 2/2/2:\n| zone1 | zone2 | zone3 |\n|  P P  |  P P  |  P P  |\nThe number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0.\nIn this situation, new pod with the same labelSelector cannot be scheduled,\nbecause computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,\nit will violate MaxSkew.",
                        "type": "integer",
                        "format": "int32"
                      },
                      "nodeAffinityPolicy": {
                        "description": "NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector\nwhen calculating pod topology spread skew. Options are:\n- Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.\n- Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.\n\nIf this value is nil, the behavior is equivalent to the Honor policy.\nThis is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.",
                        "type": "string"
                      },
                      "nodeTaintsPolicy": {
                        "description": "NodeTaintsPolicy indicates how we will treat node taints when calculating\npod topology spread skew. Options are:\n- Honor: nodes without taints, along with tainted nodes for which the incoming pod\nhas a toleration, are included.\n- Ignore: node taints are ignored. All nodes are included.\n\nIf this value is nil, the behavior is equivalent to the Ignore policy.\nThis is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.",
                        "type": "string"
                      },
                      "topologyKey": {
                        "description": "TopologyKey is the key of node labels. Nodes that have a label with this key\nand identical values are considered to be in the same topology.\nWe consider each <key, value> as a \"bucket\", and try to put balanced number\nof pods into each bucket.\nWe define a domain as a particular instance of a topology.\nAlso, we define an eligible domain as a domain whose nodes meet the requirements of\nnodeAffinityPolicy and nodeTaintsPolicy.\ne.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology.\nAnd, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology.\nIt's a required field.",
                        "type": "string"
                      },
                      "whenUnsatisfiable": {
                        "description": "WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy\nthe spread constraint.\n- DoNotSchedule (default) tells the scheduler not to schedule it.\n- ScheduleAnyway tells the scheduler to schedule the pod in any location,\n  but giving higher precedence to topologies that would help reduce the\n  skew.\nA constraint is considered \"Unsatisfiable\" for an incoming pod\nif and only if every possible node assignment for that pod would violate\n\"MaxSkew\" on some topology.\nFor example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same\nlabelSelector spread as 3/1/1:\n| zone1 | zone2 | zone3 |\n| P P P |   P   |   P   |\nIf WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled\nto zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies\nMaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler\nwon't make it *more* imbalanced.\nIt's a required field.",
                        "type": "string"
                      }
                    }
                  }
                },
                "traceSampling": {
                  "description": "Trace sampling fraction.\n\nUsed to set the fraction of time that traces are sampled. Higher values are more accurate but add CPU overhead.\n\nAllowed values: 0.0 to 1.0",
                  "type": "number"
                },
                "trustedZtunnelNamespace": {
                  "description": "If set, `istiod` will allow connections from trusted node proxy ztunnels\nin the provided namespace.",
                  "type": "string"
                },
                "variant": {
                  "description": "The container image variant to pull. Options are \"debug\" or \"distroless\". Unset will use the default for the given version.",
                  "type": "string"
                },
                "volumeMounts": {
                  "description": "Additional volumeMounts to add to the Pilot container.",
                  "type": "array",
                  "items": {
                    "description": "VolumeMount describes a mounting of a Volume within a container.",
                    "type": "object",
                    "required": [
                      "mountPath",
                      "name"
                    ],
                    "properties": {
                      "mountPath": {
                        "description": "Path within the container at which the volume should be mounted.  Must\nnot contain ':'.",
                        "type": "string"
                      },
                      "mountPropagation": {
                        "description": "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\nWhen RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified\n(which defaults to None).",
                        "type": "string"
                      },
                      "name": {
                        "description": "This must match the Name of a Volume.",
                        "type": "string"
                      },
                      "readOnly": {
                        "description": "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.",
                        "type": "boolean"
                      },
                      "recursiveReadOnly": {
                        "description": "RecursiveReadOnly specifies whether read-only mounts should be handled\nrecursively.\n\nIf ReadOnly is false, this field has no meaning and must be unspecified.\n\nIf ReadOnly is true, and this field is set to Disabled, the mount is not made\nrecursively read-only.  If this field is set to IfPossible, the mount is made\nrecursively read-only, if it is supported by the container runtime.  If this\nfield is set to Enabled, the mount is made recursively read-only if it is\nsupported by the container runtime, otherwise the pod will not be started and\nan error will be generated to indicate the reason.\n\nIf this field is set to IfPossible or Enabled, MountPropagation must be set to\nNone (or be unspecified, which defaults to None).\n\nIf this field is not specified, it is treated as an equivalent of Disabled.",
                        "type": "string"
                      },
                      "subPath": {
                        "description": "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).",
                        "type": "string"
                      },
                      "subPathExpr": {
                        "description": "Expanded path within the volume from which the container's volume should be mounted.\nBehaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.\nDefaults to \"\" (volume's root).\nSubPathExpr and SubPath are mutually exclusive.",
                        "type": "string"
                      }
                    }
                  }
                },
                "volumes": {
                  "description": "Additional volumes to add to the Pilot Pod.",
                  "type": "array",
                  "items": {
                    "description": "Volume represents a named volume in a pod that may be accessed by any container in the pod.",
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "awsElasticBlockStore": {
                        "description": "awsElasticBlockStore represents an AWS Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nDeprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree\nawsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                        "type": "object",
                        "required": [
                          "volumeID"
                        ],
                        "properties": {
                          "fsType": {
                            "description": "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                            "type": "string"
                          },
                          "partition": {
                            "description": "partition is the partition in the volume that you want to mount.\nIf omitted, the default is to mount by volume name.\nExamples: For volume /dev/sda1, you specify the partition as \"1\".\nSimilarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).",
                            "type": "integer",
                            "format": "int32"
                          },
                          "readOnly": {
                            "description": "readOnly value true will force the readOnly setting in VolumeMounts.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                            "type": "boolean"
                          },
                          "volumeID": {
                            "description": "volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                            "type": "string"
                          }
                        }
                      },
                      "azureDisk": {
                        "description": "azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.\nDeprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type\nare redirected to the disk.csi.azure.com CSI driver.",
                        "type": "object",
                        "required": [
                          "diskName",
                          "diskURI"
                        ],
                        "properties": {
                          "cachingMode": {
                            "description": "cachingMode is the Host Caching mode: None, Read Only, Read Write.",
                            "type": "string"
                          },
                          "diskName": {
                            "description": "diskName is the Name of the data disk in the blob storage",
                            "type": "string"
                          },
                          "diskURI": {
                            "description": "diskURI is the URI of data disk in the blob storage",
                            "type": "string"
                          },
                          "fsType": {
                            "description": "fsType is Filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          }
                        }
                      },
                      "azureFile": {
                        "description": "azureFile represents an Azure File Service mount on the host and bind mount to the pod.\nDeprecated: AzureFile is deprecated. All operations for the in-tree azureFile type\nare redirected to the file.csi.azure.com CSI driver.",
                        "type": "object",
                        "required": [
                          "secretName",
                          "shareName"
                        ],
                        "properties": {
                          "readOnly": {
                            "description": "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "secretName": {
                            "description": "secretName is the  name of secret that contains Azure Storage Account Name and Key",
                            "type": "string"
                          },
                          "shareName": {
                            "description": "shareName is the azure share Name",
                            "type": "string"
                          }
                        }
                      },
                      "cephfs": {
                        "description": "cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.\nDeprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.",
                        "type": "object",
                        "required": [
                          "monitors"
                        ],
                        "properties": {
                          "monitors": {
                            "description": "monitors is Required: Monitors is a collection of Ceph monitors\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "path": {
                            "description": "path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly is Optional: Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
                            "type": "boolean"
                          },
                          "secretFile": {
                            "description": "secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
                            "type": "string"
                          },
                          "secretRef": {
                            "description": "secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "user": {
                            "description": "user is optional: User is the rados user name, default is admin\nMore info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it",
                            "type": "string"
                          }
                        }
                      },
                      "cinder": {
                        "description": "cinder represents a cinder volume attached and mounted on kubelets host machine.\nDeprecated: Cinder is deprecated. All operations for the in-tree cinder type\nare redirected to the cinder.csi.openstack.org CSI driver.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md",
                        "type": "object",
                        "required": [
                          "volumeID"
                        ],
                        "properties": {
                          "fsType": {
                            "description": "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "secretRef is optional: points to a secret object containing parameters used to connect\nto OpenStack.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "volumeID": {
                            "description": "volumeID used to identify the volume in cinder.\nMore info: https://examples.k8s.io/mysql-cinder-pd/README.md",
                            "type": "string"
                          }
                        }
                      },
                      "configMap": {
                        "description": "configMap represents a configMap that should populate this volume",
                        "type": "object",
                        "properties": {
                          "defaultMode": {
                            "description": "defaultMode is optional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDefaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "items": {
                            "description": "items if unspecified, each key-value pair in the Data field of the referenced\nConfigMap will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the ConfigMap,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.",
                            "type": "array",
                            "items": {
                              "description": "Maps a string key to a path within a volume.",
                              "type": "object",
                              "required": [
                                "key",
                                "path"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the key to project.",
                                  "type": "string"
                                },
                                "mode": {
                                  "description": "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "path": {
                                  "description": "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.",
                                  "type": "string"
                                }
                              }
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "name": {
                            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "optional": {
                            "description": "optional specify whether the ConfigMap or its keys must be defined",
                            "type": "boolean"
                          }
                        },
                        "x-kubernetes-map-type": "atomic"
                      },
                      "csi": {
                        "description": "csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.",
                        "type": "object",
                        "required": [
                          "driver"
                        ],
                        "properties": {
                          "driver": {
                            "description": "driver is the name of the CSI driver that handles this volume.\nConsult with your admin for the correct name as registered in the cluster.",
                            "type": "string"
                          },
                          "fsType": {
                            "description": "fsType to mount. Ex. \"ext4\", \"xfs\", \"ntfs\".\nIf not provided, the empty value is passed to the associated CSI driver\nwhich will determine the default filesystem to apply.",
                            "type": "string"
                          },
                          "nodePublishSecretRef": {
                            "description": "nodePublishSecretRef is a reference to the secret object containing\nsensitive information to pass to the CSI driver to complete the CSI\nNodePublishVolume and NodeUnpublishVolume calls.\nThis field is optional, and  may be empty if no secret is required. If the\nsecret object contains more than one secret, all secret references are passed.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "readOnly": {
                            "description": "readOnly specifies a read-only configuration for the volume.\nDefaults to false (read/write).",
                            "type": "boolean"
                          },
                          "volumeAttributes": {
                            "description": "volumeAttributes stores driver-specific properties that are passed to the CSI\ndriver. Consult your driver's documentation for supported values.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      "downwardAPI": {
                        "description": "downwardAPI represents downward API about the pod that should populate this volume",
                        "type": "object",
                        "properties": {
                          "defaultMode": {
                            "description": "Optional: mode bits to use on created files by default. Must be a\nOptional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDefaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "items": {
                            "description": "Items is a list of downward API volume file",
                            "type": "array",
                            "items": {
                              "description": "DownwardAPIVolumeFile represents information to create the file containing the pod field",
                              "type": "object",
                              "required": [
                                "path"
                              ],
                              "properties": {
                                "fieldRef": {
                                  "description": "Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.",
                                  "type": "object",
                                  "required": [
                                    "fieldPath"
                                  ],
                                  "properties": {
                                    "apiVersion": {
                                      "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                      "type": "string"
                                    },
                                    "fieldPath": {
                                      "description": "Path of the field to select in the specified API version.",
                                      "type": "string"
                                    }
                                  },
                                  "x-kubernetes-map-type": "atomic"
                                },
                                "mode": {
                                  "description": "Optional: mode bits used to set permissions on this file, must be an octal value\nbetween 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "path": {
                                  "description": "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'",
                                  "type": "string"
                                },
                                "resourceFieldRef": {
                                  "description": "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.",
                                  "type": "object",
                                  "required": [
                                    "resource"
                                  ],
                                  "properties": {
                                    "containerName": {
                                      "description": "Container name: required for volumes, optional for env vars",
                                      "type": "string"
                                    },
                                    "divisor": {
                                      "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
                                      "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                      "x-kubernetes-int-or-string": true
                                    },
                                    "resource": {
                                      "description": "Required: resource to select",
                                      "type": "string"
                                    }
                                  },
                                  "x-kubernetes-map-type": "atomic"
                                }
                              }
                            },
                            "x-kubernetes-list-type": "atomic"
                          }
                        }
                      },
                      "emptyDir": {
                        "description": "emptyDir represents a temporary directory that shares a pod's lifetime.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
                        "type": "object",
                        "properties": {
                          "medium": {
                            "description": "medium represents what type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
                            "type": "string"
                          },
                          "sizeLimit": {
                            "description": "sizeLimit is the total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value between\nthe SizeLimit specified here and the sum of memory limits of all containers in a pod.\nThe default is nil which means that the limit is undefined.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
                            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                            "x-kubernetes-int-or-string": true
                          }
                        }
                      },
                      "ephemeral": {
                        "description": "ephemeral represents a volume that is handled by a cluster storage driver.\nThe volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,\nand deleted when the pod is removed.\n\nUse this if:\na) the volume is only needed while the pod runs,\nb) features of normal volumes like restoring from snapshot or capacity\n   tracking are needed,\nc) the storage driver is specified through a storage class, and\nd) the storage driver supports dynamic volume provisioning through\n   a PersistentVolumeClaim (see EphemeralVolumeSource for more\n   information on the connection between this volume type\n   and PersistentVolumeClaim).\n\nUse PersistentVolumeClaim or one of the vendor-specific\nAPIs for volumes that persist for longer than the lifecycle\nof an individual pod.\n\nUse CSI for light-weight local ephemeral volumes if the CSI driver is meant to\nbe used that way - see the documentation of the driver for\nmore information.\n\nA pod can use both types of ephemeral volumes and\npersistent volumes at the same time.",
                        "type": "object",
                        "properties": {
                          "volumeClaimTemplate": {
                            "description": "Will be used to create a stand-alone PVC to provision the volume.\nThe pod in which this EphemeralVolumeSource is embedded will be the\nowner of the PVC, i.e. the PVC will be deleted together with the\npod.  The name of the PVC will be `<pod name>-<volume name>` where\n`<volume name>` is the name from the `PodSpec.Volumes` array\nentry. Pod validation will reject the pod if the concatenated name\nis not valid for a PVC (for example, too long).\n\nAn existing PVC with that name that is not owned by the pod\nwill *not* be used for the pod to avoid using an unrelated\nvolume by mistake. Starting the pod is then blocked until\nthe unrelated PVC is removed. If such a pre-created PVC is\nmeant to be used by the pod, the PVC has to updated with an\nowner reference to the pod once the pod exists. Normally\nthis should not be necessary, but it may be useful when\nmanually reconstructing a broken cluster.\n\nThis field is read-only and no changes will be made by Kubernetes\nto the PVC after it has been created.\n\nRequired, must not be nil.",
                            "type": "object",
                            "required": [
                              "spec"
                            ],
                            "properties": {
                              "metadata": {
                                "description": "May contain labels and annotations that will be copied into the PVC\nwhen creating it. No other fields are allowed and will be rejected during\nvalidation.",
                                "type": "object"
                              },
                              "spec": {
                                "description": "The specification for the PersistentVolumeClaim. The entire content is\ncopied unchanged into the PVC that gets created from this\ntemplate. The same fields as in a PersistentVolumeClaim\nare also valid here.",
                                "type": "object",
                                "properties": {
                                  "accessModes": {
                                    "description": "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
                                    "type": "array",
                                    "items": {
                                      "type": "string"
                                    },
                                    "x-kubernetes-list-type": "atomic"
                                  },
                                  "dataSource": {
                                    "description": "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.",
                                    "type": "object",
                                    "required": [
                                      "kind",
                                      "name"
                                    ],
                                    "properties": {
                                      "apiGroup": {
                                        "description": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.",
                                        "type": "string"
                                      },
                                      "kind": {
                                        "description": "Kind is the type of resource being referenced",
                                        "type": "string"
                                      },
                                      "name": {
                                        "description": "Name is the name of resource being referenced",
                                        "type": "string"
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "dataSourceRef": {
                                    "description": "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.",
                                    "type": "object",
                                    "required": [
                                      "kind",
                                      "name"
                                    ],
                                    "properties": {
                                      "apiGroup": {
                                        "description": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.",
                                        "type": "string"
                                      },
                                      "kind": {
                                        "description": "Kind is the type of resource being referenced",
                                        "type": "string"
                                      },
                                      "name": {
                                        "description": "Name is the name of resource being referenced",
                                        "type": "string"
                                      },
                                      "namespace": {
                                        "description": "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "resources": {
                                    "description": "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources",
                                    "type": "object",
                                    "properties": {
                                      "limits": {
                                        "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                                        "type": "object",
                                        "additionalProperties": {
                                          "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                          "x-kubernetes-int-or-string": true
                                        }
                                      },
                                      "requests": {
                                        "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                                        "type": "object",
                                        "additionalProperties": {
                                          "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                          "x-kubernetes-int-or-string": true
                                        }
                                      }
                                    }
                                  },
                                  "selector": {
                                    "description": "selector is a label query over volumes to consider for binding.",
                                    "type": "object",
                                    "properties": {
                                      "matchExpressions": {
                                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                        "type": "array",
                                        "items": {
                                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                          "type": "object",
                                          "required": [
                                            "key",
                                            "operator"
                                          ],
                                          "properties": {
                                            "key": {
                                              "description": "key is the label key that the selector applies to.",
                                              "type": "string"
                                            },
                                            "operator": {
                                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                              "type": "string"
                                            },
                                            "values": {
                                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                              "type": "array",
                                              "items": {
                                                "type": "string"
                                              },
                                              "x-kubernetes-list-type": "atomic"
                                            }
                                          }
                                        },
                                        "x-kubernetes-list-type": "atomic"
                                      },
                                      "matchLabels": {
                                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                        "type": "object",
                                        "additionalProperties": {
                                          "type": "string"
                                        }
                                      }
                                    },
                                    "x-kubernetes-map-type": "atomic"
                                  },
                                  "storageClassName": {
                                    "description": "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
                                    "type": "string"
                                  },
                                  "volumeAttributesClassName": {
                                    "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string value means that no VolumeAttributesClass\nwill be applied to the claim but it's not allowed to reset this field to empty string once it is set.\nIf unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass\nwill be set by the persistentvolume controller if it exists.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/\n(Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).",
                                    "type": "string"
                                  },
                                  "volumeMode": {
                                    "description": "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.",
                                    "type": "string"
                                  },
                                  "volumeName": {
                                    "description": "volumeName is the binding reference to the PersistentVolume backing this claim.",
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      },
                      "fc": {
                        "description": "fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.",
                        "type": "object",
                        "properties": {
                          "fsType": {
                            "description": "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "lun": {
                            "description": "lun is Optional: FC target lun number",
                            "type": "integer",
                            "format": "int32"
                          },
                          "readOnly": {
                            "description": "readOnly is Optional: Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "targetWWNs": {
                            "description": "targetWWNs is Optional: FC target worldwide names (WWNs)",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "wwids": {
                            "description": "wwids Optional: FC volume world wide identifiers (wwids)\nEither wwids or combination of targetWWNs and lun must be set, but not both simultaneously.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "x-kubernetes-list-type": "atomic"
                          }
                        }
                      },
                      "flexVolume": {
                        "description": "flexVolume represents a generic volume resource that is\nprovisioned/attached using an exec based plugin.\nDeprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.",
                        "type": "object",
                        "required": [
                          "driver"
                        ],
                        "properties": {
                          "driver": {
                            "description": "driver is the name of the driver to use for this volume.",
                            "type": "string"
                          },
                          "fsType": {
                            "description": "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends on FlexVolume script.",
                            "type": "string"
                          },
                          "options": {
                            "description": "options is Optional: this field holds extra command options if any.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          },
                          "readOnly": {
                            "description": "readOnly is Optional: defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "secretRef is Optional: secretRef is reference to the secret object containing\nsensitive information to pass to the plugin scripts. This may be\nempty if no secret object is specified. If the secret object\ncontains more than one secret, all secrets are passed to the plugin\nscripts.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          }
                        }
                      },
                      "flocker": {
                        "description": "flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.\nDeprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.",
                        "type": "object",
                        "properties": {
                          "datasetName": {
                            "description": "datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker\nshould be considered as deprecated",
                            "type": "string"
                          },
                          "datasetUUID": {
                            "description": "datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset",
                            "type": "string"
                          }
                        }
                      },
                      "gcePersistentDisk": {
                        "description": "gcePersistentDisk represents a GCE Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nDeprecated: GCEPersistentDisk is deprecated. All operations for the in-tree\ngcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                        "type": "object",
                        "required": [
                          "pdName"
                        ],
                        "properties": {
                          "fsType": {
                            "description": "fsType is filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                            "type": "string"
                          },
                          "partition": {
                            "description": "partition is the partition in the volume that you want to mount.\nIf omitted, the default is to mount by volume name.\nExamples: For volume /dev/sda1, you specify the partition as \"1\".\nSimilarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                            "type": "integer",
                            "format": "int32"
                          },
                          "pdName": {
                            "description": "pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk",
                            "type": "boolean"
                          }
                        }
                      },
                      "gitRepo": {
                        "description": "gitRepo represents a git repository at a particular revision.\nDeprecated: GitRepo is deprecated. To provision a container with a git repo, mount an\nEmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir\ninto the Pod's container.",
                        "type": "object",
                        "required": [
                          "repository"
                        ],
                        "properties": {
                          "directory": {
                            "description": "directory is the target directory name.\nMust not contain or start with '..'.  If '.' is supplied, the volume directory will be the\ngit repository.  Otherwise, if specified, the volume will contain the git repository in\nthe subdirectory with the given name.",
                            "type": "string"
                          },
                          "repository": {
                            "description": "repository is the URL",
                            "type": "string"
                          },
                          "revision": {
                            "description": "revision is the commit hash for the specified revision.",
                            "type": "string"
                          }
                        }
                      },
                      "glusterfs": {
                        "description": "glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.\nDeprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.\nMore info: https://examples.k8s.io/volumes/glusterfs/README.md",
                        "type": "object",
                        "required": [
                          "endpoints",
                          "path"
                        ],
                        "properties": {
                          "endpoints": {
                            "description": "endpoints is the endpoint name that details Glusterfs topology.\nMore info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
                            "type": "string"
                          },
                          "path": {
                            "description": "path is the Glusterfs volume path.\nMore info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly here will force the Glusterfs volume to be mounted with read-only permissions.\nDefaults to false.\nMore info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod",
                            "type": "boolean"
                          }
                        }
                      },
                      "hostPath": {
                        "description": "hostPath represents a pre-existing file or directory on the host\nmachine that is directly exposed to the container. This is generally\nused for system agents or other privileged things that are allowed\nto see the host machine. Most containers will NOT need this.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
                        "type": "object",
                        "required": [
                          "path"
                        ],
                        "properties": {
                          "path": {
                            "description": "path of the directory on the host.\nIf the path is a symlink, it will follow the link to the real path.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
                            "type": "string"
                          },
                          "type": {
                            "description": "type for HostPath Volume\nDefaults to \"\"\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
                            "type": "string"
                          }
                        }
                      },
                      "image": {
                        "description": "image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.\nThe volume is resolved at pod startup depending on which PullPolicy value is provided:\n\n- Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.\n- Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.\n- IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\n\nThe volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.\nA failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.\nThe types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.\nThe OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.\nThe volume will be mounted read-only (ro) and non-executable files (noexec).\nSub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath).\nThe field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.",
                        "type": "object",
                        "properties": {
                          "pullPolicy": {
                            "description": "Policy for pulling OCI objects. Possible values are:\nAlways: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.\nNever: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.\nIfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.\nDefaults to Always if :latest tag is specified, or IfNotPresent otherwise.",
                            "type": "string"
                          },
                          "reference": {
                            "description": "Required: Image or artifact reference to be used.\nBehaves in the same way as pod.spec.containers[*].image.\nPull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.\nMore info: https://kubernetes.io/docs/concepts/containers/images\nThis field is optional to allow higher level config management to default or override\ncontainer images in workload controllers like Deployments and StatefulSets.",
                            "type": "string"
                          }
                        }
                      },
                      "iscsi": {
                        "description": "iscsi represents an ISCSI Disk resource that is attached to a\nkubelet's host machine and then exposed to the pod.\nMore info: https://examples.k8s.io/volumes/iscsi/README.md",
                        "type": "object",
                        "required": [
                          "iqn",
                          "lun",
                          "targetPortal"
                        ],
                        "properties": {
                          "chapAuthDiscovery": {
                            "description": "chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication",
                            "type": "boolean"
                          },
                          "chapAuthSession": {
                            "description": "chapAuthSession defines whether support iSCSI Session CHAP authentication",
                            "type": "boolean"
                          },
                          "fsType": {
                            "description": "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi",
                            "type": "string"
                          },
                          "initiatorName": {
                            "description": "initiatorName is the custom iSCSI Initiator Name.\nIf initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface\n<target portal>:<volume name> will be created for the connection.",
                            "type": "string"
                          },
                          "iqn": {
                            "description": "iqn is the target iSCSI Qualified Name.",
                            "type": "string"
                          },
                          "iscsiInterface": {
                            "description": "iscsiInterface is the interface Name that uses an iSCSI transport.\nDefaults to 'default' (tcp).",
                            "type": "string"
                          },
                          "lun": {
                            "description": "lun represents iSCSI Target Lun number.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "portals": {
                            "description": "portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port\nis other than default (typically TCP ports 860 and 3260).",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "readOnly": {
                            "description": "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "secretRef is the CHAP Secret for iSCSI target and initiator authentication",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "targetPortal": {
                            "description": "targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port\nis other than default (typically TCP ports 860 and 3260).",
                            "type": "string"
                          }
                        }
                      },
                      "name": {
                        "description": "name of the volume.\nMust be a DNS_LABEL and unique within the pod.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                        "type": "string"
                      },
                      "nfs": {
                        "description": "nfs represents an NFS mount on the host that shares a pod's lifetime\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
                        "type": "object",
                        "required": [
                          "path",
                          "server"
                        ],
                        "properties": {
                          "path": {
                            "description": "path that is exported by the NFS server.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly here will force the NFS export to be mounted with read-only permissions.\nDefaults to false.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
                            "type": "boolean"
                          },
                          "server": {
                            "description": "server is the hostname or IP address of the NFS server.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#nfs",
                            "type": "string"
                          }
                        }
                      },
                      "persistentVolumeClaim": {
                        "description": "persistentVolumeClaimVolumeSource represents a reference to a\nPersistentVolumeClaim in the same namespace.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
                        "type": "object",
                        "required": [
                          "claimName"
                        ],
                        "properties": {
                          "claimName": {
                            "description": "claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly Will force the ReadOnly setting in VolumeMounts.\nDefault false.",
                            "type": "boolean"
                          }
                        }
                      },
                      "photonPersistentDisk": {
                        "description": "photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.\nDeprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.",
                        "type": "object",
                        "required": [
                          "pdID"
                        ],
                        "properties": {
                          "fsType": {
                            "description": "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "pdID": {
                            "description": "pdID is the ID that identifies Photon Controller persistent disk",
                            "type": "string"
                          }
                        }
                      },
                      "portworxVolume": {
                        "description": "portworxVolume represents a portworx volume attached and mounted on kubelets host machine.\nDeprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type\nare redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate\nis on.",
                        "type": "object",
                        "required": [
                          "volumeID"
                        ],
                        "properties": {
                          "fsType": {
                            "description": "fSType represents the filesystem type to mount\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "volumeID": {
                            "description": "volumeID uniquely identifies a Portworx volume",
                            "type": "string"
                          }
                        }
                      },
                      "projected": {
                        "description": "projected items for all in one resources secrets, configmaps, and downward API",
                        "type": "object",
                        "properties": {
                          "defaultMode": {
                            "description": "defaultMode are the mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "sources": {
                            "description": "sources is the list of volume projections. Each entry in this list\nhandles one source.",
                            "type": "array",
                            "items": {
                              "description": "Projection that may be projected along with other supported volume types.\nExactly one of these fields must be set.",
                              "type": "object",
                              "properties": {
                                "clusterTrustBundle": {
                                  "description": "ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field\nof ClusterTrustBundle objects in an auto-updating file.\n\nAlpha, gated by the ClusterTrustBundleProjection feature gate.\n\nClusterTrustBundle objects can either be selected by name, or by the\ncombination of signer name and a label selector.\n\nKubelet performs aggressive normalization of the PEM contents written\ninto the pod filesystem.  Esoteric PEM features such as inter-block\ncomments and block headers are stripped.  Certificates are deduplicated.\nThe ordering of certificates within the file is arbitrary, and Kubelet\nmay change the order over time.",
                                  "type": "object",
                                  "required": [
                                    "path"
                                  ],
                                  "properties": {
                                    "labelSelector": {
                                      "description": "Select all ClusterTrustBundles that match this label selector.  Only has\neffect if signerName is set.  Mutually-exclusive with name.  If unset,\ninterpreted as \"match nothing\".  If set but empty, interpreted as \"match\neverything\".",
                                      "type": "object",
                                      "properties": {
                                        "matchExpressions": {
                                          "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                          "type": "array",
                                          "items": {
                                            "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                                            "type": "object",
                                            "required": [
                                              "key",
                                              "operator"
                                            ],
                                            "properties": {
                                              "key": {
                                                "description": "key is the label key that the selector applies to.",
                                                "type": "string"
                                              },
                                              "operator": {
                                                "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                                "type": "string"
                                              },
                                              "values": {
                                                "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                                "type": "array",
                                                "items": {
                                                  "type": "string"
                                                },
                                                "x-kubernetes-list-type": "atomic"
                                              }
                                            }
                                          },
                                          "x-kubernetes-list-type": "atomic"
                                        },
                                        "matchLabels": {
                                          "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                          "type": "object",
                                          "additionalProperties": {
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "x-kubernetes-map-type": "atomic"
                                    },
                                    "name": {
                                      "description": "Select a single ClusterTrustBundle by object name.  Mutually-exclusive\nwith signerName and labelSelector.",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "If true, don't block pod startup if the referenced ClusterTrustBundle(s)\naren't available.  If using name, then the named ClusterTrustBundle is\nallowed not to exist.  If using signerName, then the combination of\nsignerName and labelSelector is allowed to match zero\nClusterTrustBundles.",
                                      "type": "boolean"
                                    },
                                    "path": {
                                      "description": "Relative path from the volume root to write the bundle.",
                                      "type": "string"
                                    },
                                    "signerName": {
                                      "description": "Select all ClusterTrustBundles that match this signer name.\nMutually-exclusive with name.  The contents of all selected\nClusterTrustBundles will be unified and deduplicated.",
                                      "type": "string"
                                    }
                                  }
                                },
                                "configMap": {
                                  "description": "configMap information about the configMap data to project",
                                  "type": "object",
                                  "properties": {
                                    "items": {
                                      "description": "items if unspecified, each key-value pair in the Data field of the referenced\nConfigMap will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the ConfigMap,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.",
                                      "type": "array",
                                      "items": {
                                        "description": "Maps a string key to a path within a volume.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "path"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the key to project.",
                                            "type": "string"
                                          },
                                          "mode": {
                                            "description": "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "path": {
                                            "description": "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "x-kubernetes-list-type": "atomic"
                                    },
                                    "name": {
                                      "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "optional specify whether the ConfigMap or its keys must be defined",
                                      "type": "boolean"
                                    }
                                  },
                                  "x-kubernetes-map-type": "atomic"
                                },
                                "downwardAPI": {
                                  "description": "downwardAPI information about the downwardAPI data to project",
                                  "type": "object",
                                  "properties": {
                                    "items": {
                                      "description": "Items is a list of DownwardAPIVolume file",
                                      "type": "array",
                                      "items": {
                                        "description": "DownwardAPIVolumeFile represents information to create the file containing the pod field",
                                        "type": "object",
                                        "required": [
                                          "path"
                                        ],
                                        "properties": {
                                          "fieldRef": {
                                            "description": "Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.",
                                            "type": "object",
                                            "required": [
                                              "fieldPath"
                                            ],
                                            "properties": {
                                              "apiVersion": {
                                                "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                                "type": "string"
                                              },
                                              "fieldPath": {
                                                "description": "Path of the field to select in the specified API version.",
                                                "type": "string"
                                              }
                                            },
                                            "x-kubernetes-map-type": "atomic"
                                          },
                                          "mode": {
                                            "description": "Optional: mode bits used to set permissions on this file, must be an octal value\nbetween 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "path": {
                                            "description": "Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'",
                                            "type": "string"
                                          },
                                          "resourceFieldRef": {
                                            "description": "Selects a resource of the container: only resources limits and requests\n(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.",
                                            "type": "object",
                                            "required": [
                                              "resource"
                                            ],
                                            "properties": {
                                              "containerName": {
                                                "description": "Container name: required for volumes, optional for env vars",
                                                "type": "string"
                                              },
                                              "divisor": {
                                                "description": "Specifies the output format of the exposed resources, defaults to \"1\"",
                                                "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                                                "x-kubernetes-int-or-string": true
                                              },
                                              "resource": {
                                                "description": "Required: resource to select",
                                                "type": "string"
                                              }
                                            },
                                            "x-kubernetes-map-type": "atomic"
                                          }
                                        }
                                      },
                                      "x-kubernetes-list-type": "atomic"
                                    }
                                  }
                                },
                                "secret": {
                                  "description": "secret information about the secret data to project",
                                  "type": "object",
                                  "properties": {
                                    "items": {
                                      "description": "items if unspecified, each key-value pair in the Data field of the referenced\nSecret will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the Secret,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.",
                                      "type": "array",
                                      "items": {
                                        "description": "Maps a string key to a path within a volume.",
                                        "type": "object",
                                        "required": [
                                          "key",
                                          "path"
                                        ],
                                        "properties": {
                                          "key": {
                                            "description": "key is the key to project.",
                                            "type": "string"
                                          },
                                          "mode": {
                                            "description": "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "path": {
                                            "description": "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.",
                                            "type": "string"
                                          }
                                        }
                                      },
                                      "x-kubernetes-list-type": "atomic"
                                    },
                                    "name": {
                                      "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                      "type": "string"
                                    },
                                    "optional": {
                                      "description": "optional field specify whether the Secret or its key must be defined",
                                      "type": "boolean"
                                    }
                                  },
                                  "x-kubernetes-map-type": "atomic"
                                },
                                "serviceAccountToken": {
                                  "description": "serviceAccountToken is information about the serviceAccountToken data to project",
                                  "type": "object",
                                  "required": [
                                    "path"
                                  ],
                                  "properties": {
                                    "audience": {
                                      "description": "audience is the intended audience of the token. A recipient of a token\nmust identify itself with an identifier specified in the audience of the\ntoken, and otherwise should reject the token. The audience defaults to the\nidentifier of the apiserver.",
                                      "type": "string"
                                    },
                                    "expirationSeconds": {
                                      "description": "expirationSeconds is the requested duration of validity of the service\naccount token. As the token approaches expiration, the kubelet volume\nplugin will proactively rotate the service account token. The kubelet will\nstart trying to rotate the token if the token is older than 80 percent of\nits time to live or if the token is older than 24 hours.Defaults to 1 hour\nand must be at least 10 minutes.",
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "path": {
                                      "description": "path is the path relative to the mount point of the file to project the\ntoken into.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            },
                            "x-kubernetes-list-type": "atomic"
                          }
                        }
                      },
                      "quobyte": {
                        "description": "quobyte represents a Quobyte mount on the host that shares a pod's lifetime.\nDeprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.",
                        "type": "object",
                        "required": [
                          "registry",
                          "volume"
                        ],
                        "properties": {
                          "group": {
                            "description": "group to map volume access to\nDefault is no group",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly here will force the Quobyte volume to be mounted with read-only permissions.\nDefaults to false.",
                            "type": "boolean"
                          },
                          "registry": {
                            "description": "registry represents a single or multiple Quobyte Registry services\nspecified as a string as host:port pair (multiple entries are separated with commas)\nwhich acts as the central registry for volumes",
                            "type": "string"
                          },
                          "tenant": {
                            "description": "tenant owning the given Quobyte volume in the Backend\nUsed with dynamically provisioned Quobyte volumes, value is set by the plugin",
                            "type": "string"
                          },
                          "user": {
                            "description": "user to map volume access to\nDefaults to serivceaccount user",
                            "type": "string"
                          },
                          "volume": {
                            "description": "volume is a string that references an already created Quobyte volume by name.",
                            "type": "string"
                          }
                        }
                      },
                      "rbd": {
                        "description": "rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.\nDeprecated: RBD is deprecated and the in-tree rbd type is no longer supported.\nMore info: https://examples.k8s.io/volumes/rbd/README.md",
                        "type": "object",
                        "required": [
                          "image",
                          "monitors"
                        ],
                        "properties": {
                          "fsType": {
                            "description": "fsType is the filesystem type of the volume that you want to mount.\nTip: Ensure that the filesystem type is supported by the host operating system.\nExamples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#rbd",
                            "type": "string"
                          },
                          "image": {
                            "description": "image is the rados image name.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
                            "type": "string"
                          },
                          "keyring": {
                            "description": "keyring is the path to key ring for RBDUser.\nDefault is /etc/ceph/keyring.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
                            "type": "string"
                          },
                          "monitors": {
                            "description": "monitors is a collection of Ceph monitors.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "pool": {
                            "description": "pool is the rados pool name.\nDefault is rbd.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly here will force the ReadOnly setting in VolumeMounts.\nDefaults to false.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "secretRef is name of the authentication secret for RBDUser. If provided\noverrides keyring.\nDefault is nil.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "user": {
                            "description": "user is the rados user name.\nDefault is admin.\nMore info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it",
                            "type": "string"
                          }
                        }
                      },
                      "scaleIO": {
                        "description": "scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.\nDeprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.",
                        "type": "object",
                        "required": [
                          "gateway",
                          "secretRef",
                          "system"
                        ],
                        "properties": {
                          "fsType": {
                            "description": "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\".\nDefault is \"xfs\".",
                            "type": "string"
                          },
                          "gateway": {
                            "description": "gateway is the host address of the ScaleIO API Gateway.",
                            "type": "string"
                          },
                          "protectionDomain": {
                            "description": "protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly Defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "secretRef references to the secret for ScaleIO user and other\nsensitive information. If this is not provided, Login operation will fail.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "sslEnabled": {
                            "description": "sslEnabled Flag enable/disable SSL communication with Gateway, default false",
                            "type": "boolean"
                          },
                          "storageMode": {
                            "description": "storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.\nDefault is ThinProvisioned.",
                            "type": "string"
                          },
                          "storagePool": {
                            "description": "storagePool is the ScaleIO Storage Pool associated with the protection domain.",
                            "type": "string"
                          },
                          "system": {
                            "description": "system is the name of the storage system as configured in ScaleIO.",
                            "type": "string"
                          },
                          "volumeName": {
                            "description": "volumeName is the name of a volume already created in the ScaleIO system\nthat is associated with this volume source.",
                            "type": "string"
                          }
                        }
                      },
                      "secret": {
                        "description": "secret represents a secret that should populate this volume.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#secret",
                        "type": "object",
                        "properties": {
                          "defaultMode": {
                            "description": "defaultMode is Optional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values\nfor mode bits. Defaults to 0644.\nDirectories within the path are not affected by this setting.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "items": {
                            "description": "items If unspecified, each key-value pair in the Data field of the referenced\nSecret will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the Secret,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.",
                            "type": "array",
                            "items": {
                              "description": "Maps a string key to a path within a volume.",
                              "type": "object",
                              "required": [
                                "key",
                                "path"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the key to project.",
                                  "type": "string"
                                },
                                "mode": {
                                  "description": "mode is Optional: mode bits used to set permissions on this file.\nMust be an octal value between 0000 and 0777 or a decimal value between 0 and 511.\nYAML accepts both octal and decimal values, JSON requires decimal values for mode bits.\nIf not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "path": {
                                  "description": "path is the relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'.",
                                  "type": "string"
                                }
                              }
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "optional": {
                            "description": "optional field specify whether the Secret or its keys must be defined",
                            "type": "boolean"
                          },
                          "secretName": {
                            "description": "secretName is the name of the secret in the pod's namespace to use.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#secret",
                            "type": "string"
                          }
                        }
                      },
                      "storageos": {
                        "description": "storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.\nDeprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.",
                        "type": "object",
                        "properties": {
                          "fsType": {
                            "description": "fsType is the filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly defaults to false (read/write). ReadOnly here will force\nthe ReadOnly setting in VolumeMounts.",
                            "type": "boolean"
                          },
                          "secretRef": {
                            "description": "secretRef specifies the secret to use for obtaining the StorageOS API\ncredentials.  If not specified, default values will be attempted.",
                            "type": "object",
                            "properties": {
                              "name": {
                                "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              }
                            },
                            "x-kubernetes-map-type": "atomic"
                          },
                          "volumeName": {
                            "description": "volumeName is the human-readable name of the StorageOS volume.  Volume\nnames are only unique within a namespace.",
                            "type": "string"
                          },
                          "volumeNamespace": {
                            "description": "volumeNamespace specifies the scope of the volume within StorageOS.  If no\nnamespace is specified then the Pod's namespace will be used.  This allows the\nKubernetes name scoping to be mirrored within StorageOS for tighter integration.\nSet VolumeName to any name to override the default behaviour.\nSet to \"default\" if you are not using namespaces within StorageOS.\nNamespaces that do not pre-exist within StorageOS will be created.",
                            "type": "string"
                          }
                        }
                      },
                      "vsphereVolume": {
                        "description": "vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.\nDeprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type\nare redirected to the csi.vsphere.vmware.com CSI driver.",
                        "type": "object",
                        "required": [
                          "volumePath"
                        ],
                        "properties": {
                          "fsType": {
                            "description": "fsType is filesystem type to mount.\nMust be a filesystem type supported by the host operating system.\nEx. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                            "type": "string"
                          },
                          "storagePolicyID": {
                            "description": "storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.",
                            "type": "string"
                          },
                          "storagePolicyName": {
                            "description": "storagePolicyName is the storage Policy Based Management (SPBM) profile name.",
                            "type": "string"
                          },
                          "volumePath": {
                            "description": "volumePath is the path that identifies vSphere volume vmdk",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            "profile": {
              "description": "Specifies which installation configuration profile to apply.",
              "type": "string"
            },
            "revision": {
              "description": "Identifies the revision this installation is associated with.",
              "type": "string"
            },
            "sidecarInjectorWebhook": {
              "description": "Configuration for the sidecar injector webhook.",
              "type": "object",
              "properties": {
                "alwaysInjectSelector": {
                  "description": "See NeverInjectSelector.",
                  "type": "array",
                  "items": {
                    "description": "A label selector is a label query over a set of resources. The result of matchLabels and\nmatchExpressions are ANDed. An empty label selector matches all objects. A null\nlabel selector matches no objects.",
                    "type": "object",
                    "properties": {
                      "matchExpressions": {
                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                        "type": "array",
                        "items": {
                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                          "type": "object",
                          "required": [
                            "key",
                            "operator"
                          ],
                          "properties": {
                            "key": {
                              "description": "key is the label key that the selector applies to.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                              "type": "string"
                            },
                            "values": {
                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "x-kubernetes-list-type": "atomic"
                            }
                          }
                        },
                        "x-kubernetes-list-type": "atomic"
                      },
                      "matchLabels": {
                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    },
                    "x-kubernetes-map-type": "atomic"
                  }
                },
                "defaultTemplates": {
                  "description": "defaultTemplates: [\"sidecar\", \"hello\"]",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "enableNamespacesByDefault": {
                  "description": "Enables sidecar auto-injection in namespaces by default.",
                  "type": "boolean"
                },
                "injectedAnnotations": {
                  "description": "injectedAnnotations are additional annotations that will be added to the pod spec after injection\nThis is primarily to support PSP annotations.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "injectionURL": {
                  "description": "Configure the injection url for sidecar injector webhook",
                  "type": "string"
                },
                "neverInjectSelector": {
                  "description": "Instructs Istio to not inject the sidecar on those pods, based on labels that are present in those pods.\n\nAnnotations in the pods have higher precedence than the label selectors.\nOrder of evaluation: Pod Annotations \u2192 NeverInjectSelector \u2192 AlwaysInjectSelector \u2192 Default Policy.\nSee https://istio.io/docs/setup/kubernetes/additional-setup/sidecar-injection/#more-control-adding-exceptions",
                  "type": "array",
                  "items": {
                    "description": "A label selector is a label query over a set of resources. The result of matchLabels and\nmatchExpressions are ANDed. An empty label selector matches all objects. A null\nlabel selector matches no objects.",
                    "type": "object",
                    "properties": {
                      "matchExpressions": {
                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                        "type": "array",
                        "items": {
                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                          "type": "object",
                          "required": [
                            "key",
                            "operator"
                          ],
                          "properties": {
                            "key": {
                              "description": "key is the label key that the selector applies to.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                              "type": "string"
                            },
                            "values": {
                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "x-kubernetes-list-type": "atomic"
                            }
                          }
                        },
                        "x-kubernetes-list-type": "atomic"
                      },
                      "matchLabels": {
                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    },
                    "x-kubernetes-map-type": "atomic"
                  }
                },
                "reinvocationPolicy": {
                  "description": "Setting this to `IfNeeded` will result in the sidecar injector being run again if additional mutations occur. Default: Never",
                  "type": "string"
                },
                "rewriteAppHTTPProbe": {
                  "description": "If true, webhook or istioctl injector will rewrite PodSpec for liveness health check to redirect request to sidecar. This makes liveness check work even when mTLS is enabled.",
                  "type": "boolean"
                },
                "templates": {
                  "description": "Templates defines a set of custom injection templates that can be used. For example, defining:\n\ntemplates:\n\n\thello: |\n\t  metadata:\n\t    labels:\n\t      hello: world\n\nThen starting a pod with the `inject.istio.io/templates: hello` annotation, will result in the pod\nbeing injected with the hello=world labels.\nThis is intended for advanced configuration only; most users should use the built in template",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            "telemetry": {
              "description": "Controls whether telemetry is exported for Pilot.",
              "type": "object",
              "properties": {
                "enabled": {
                  "description": "Controls whether telemetry is exported for Pilot.",
                  "type": "boolean"
                },
                "v2": {
                  "description": "Configuration for Telemetry v2.",
                  "type": "object",
                  "properties": {
                    "enabled": {
                      "description": "Controls whether pilot will configure telemetry v2.",
                      "type": "boolean"
                    },
                    "prometheus": {
                      "description": "Telemetry v2 settings for prometheus.",
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "description": "Controls whether stats envoyfilter would be enabled or not.",
                          "type": "boolean"
                        }
                      }
                    },
                    "stackdriver": {
                      "description": "Telemetry v2 settings for stackdriver.",
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "type": "boolean"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "version": {
          "description": "Defines the version of Istio to install.\nMust be one of: v1.24.4, v1.24.3.",
          "type": "string",
          "enum": [
            "v1.24.4",
            "v1.24.3"
          ]
        }
      },
      "x-kubernetes-validations": [
        {
          "message": "spec.values.global.istioNamespace must match spec.namespace",
          "rule": "self.values.global.istioNamespace == self.__namespace__"
        }
      ]
    },
    "status": {
      "description": "IstioRevisionStatus defines the observed state of IstioRevision",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Represents the latest available observations of the object's current state.",
          "type": "array",
          "items": {
            "description": "IstioRevisionCondition represents a specific observation of the IstioRevision object's state.",
            "type": "object",
            "properties": {
              "lastTransitionTime": {
                "description": "Last time the condition transitioned from one status to another.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "Human-readable message indicating details about the last transition.",
                "type": "string"
              },
              "reason": {
                "description": "Unique, single-word, CamelCase reason for the condition's last transition.",
                "type": "string"
              },
              "status": {
                "description": "The status of this condition. Can be True, False or Unknown.",
                "type": "string"
              },
              "type": {
                "description": "The type of this condition.",
                "type": "string"
              }
            }
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the most recent generation observed for this\nIstioRevision object. It corresponds to the object's generation, which is\nupdated on mutation by the API Server. The information in the status\npertains to this particular generation of the object.",
          "type": "integer",
          "format": "int64"
        },
        "state": {
          "description": "Reports the current state of the object.",
          "type": "string"
        }
      }
    }
  },
  "x-kubernetes-group-version-kind": [
    {
      "group": "sailoperator.io",
      "kind": "IstioRevision",
      "version": "v1"
    }
  ],
  "x-kubernetes-selectable-fields": [],
  "x-kubernetes-validations": [
    {
      "message": "spec.values.revision must match metadata.name",
      "rule": "self.metadata.name == 'default' ? (!has(self.spec.values.revision) || size(self.spec.values.revision) == 0) : self.spec.values.revision == self.metadata.name"
    }
  ],
  "$schema": "http://json-schema.org/schema#"
}
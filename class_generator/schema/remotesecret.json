{
  "description": "RemoteSecret is the Schema for the RemoteSecret API",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "data": {
      "description": "Transient optional field for data to upload during create/update RemoteSecret It is processed by Mutating Webhook and must not be persisted, to make sure (in a case if something happened with Webhook) it is constrained",
      "type": "object",
      "maxProperties": 0,
      "additionalProperties": {
        "type": "string",
        "format": "byte"
      }
    },
    "dataFrom": {
      "description": "DataFrom is an optional field that can be used to copy data from another remote secret during the creation of the remote secret. This field can be specified only during creation of a remote secret (only one of data or dataFrom can be specified at the same time) or during an update of a remote secret that does not yet have data associated with it (its DataObtained condition is in the AwaitingData state).",
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        }
      }
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      "$ref": "_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    },
    "spec": {
      "description": "RemoteSecretSpec defines the desired state of RemoteSecret",
      "type": "object",
      "required": [
        "secret"
      ],
      "properties": {
        "secret": {
          "description": "Secret defines the properties of the secret and the linked service accounts that should be created in the target namespaces.",
          "type": "object",
          "properties": {
            "annotations": {
              "description": "Annotations is the keys and values that the created secret should be annotated with.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "generateName": {
              "type": "string"
            },
            "keys": {
              "description": "RequiredKeys are the keys which need to be present in the UploadSecret to successfully upload the SecretData. Furthermore, the UploadSecret needs to contain the keys which are inferred from the Type (and UploadSecret's type, since these have to match) and may contain any additional keys.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string"
                  }
                }
              }
            },
            "labels": {
              "description": "Labels contains the labels that the created secret should be labeled with.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "linkedTo": {
              "description": "LinkedTo specifies the objects that the secret is linked to. Currently, only service accounts are supported.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "serviceAccount": {
                    "description": "ServiceAccounts lists the service accounts that the secret is linked to.",
                    "type": "object",
                    "properties": {
                      "as": {
                        "description": "As specifies how the secret generated by the binding is linked to the service account. This can be either `secret` meaning that the secret is listed as one of the mountable secrets in the `secrets` of the service account, `imagePullSecret` which makes the secret listed as one of the image pull secrets associated with the service account. If not specified, it defaults to `secret`.",
                        "type": "string"
                      },
                      "managed": {
                        "description": "Managed specifies the service account that is bound to the lifetime of the binding. This service account must not exist and is created and deleted along with the injected secret.",
                        "type": "object",
                        "properties": {
                          "annotations": {
                            "description": "Annotations is the keys and values that the created service account should be annotated with.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          },
                          "generateName": {
                            "description": "GenerateName is the generate name to be used when creating the service account. It only really makes sense for the Managed service accounts that are cleaned up with the binding.",
                            "type": "string"
                          },
                          "labels": {
                            "description": "Labels contains the labels that the created service account should be labeled with.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          },
                          "name": {
                            "description": "Name is the name of the service account to create/link. Either this or GenerateName must be specified.",
                            "type": "string"
                          }
                        }
                      },
                      "reference": {
                        "description": "Reference specifies a pre-existing service account that the secret should be linked to. It is an error if the service account doesn't exist when the operator tries to add a link to a secret with the injected token.",
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
                            "type": "string"
                          }
                        },
                        "x-kubernetes-map-type": "atomic"
                      }
                    }
                  }
                }
              }
            },
            "name": {
              "description": "Name is the name of the secret to be created. If it is not defined a random name based on the name of the binding is used.",
              "type": "string"
            },
            "type": {
              "description": "Type is the type of the secret to be created in targets. If left empty, the default type used in the cluster is assumed (typically Opaque). The Type has to match type of the UploadSecret. This constraint ensures that the requirements on keys, put forth by Kubernetes (https://kubernetes.io/docs/concepts/configuration/secret/#secret-types), are met and secret can be properly created in targets.",
              "type": "string"
            }
          }
        },
        "targets": {
          "description": "Targets is the list of the target namespaces that the secret and service accounts should be deployed to.",
          "type": "array",
          "items": {
            "type": "object",
            "required": [
              "namespace"
            ],
            "properties": {
              "apiUrl": {
                "description": "ApiUrl specifies the URL of the API server of a remote Kubernetes cluster that this target points to. If left empty, the local cluster is assumed.",
                "type": "string"
              },
              "clusterCredentialsSecret": {
                "description": "ClusterCredentialsSecret is the name of the secret in the same namespace as the RemoteSecret that contains the token to use to authenticate with the remote Kubernetes cluster. This is ignored if `apiUrl` is empty.",
                "type": "string"
              },
              "namespace": {
                "description": "Namespace is the name of the target namespace to which to deploy.",
                "type": "string"
              },
              "secret": {
                "description": "Secret contains the overriden definitions of the secret specific to this target.",
                "type": "object",
                "properties": {
                  "annotations": {
                    "description": "Annotations is the new set of annotations to be put on the secret instead of the annotations defined in the spec. I.e. this completely replaces the annotations from the secret spec. Note that this is a pointer to a map so that we can distinguish between an undefined, nil, value and an empty map (clearing any annotations defined in the spec).",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "generateName": {
                    "description": "GenerateName is the GenerateName of the secret when deployed to the target. This overrides the generateName from the secret spec.",
                    "type": "string"
                  },
                  "labels": {
                    "description": "Labels is the new set of labels to be put on the secret instead of the labels defined in the spec. I.e. this completely replaces the labels from the secret spec. Note that this is a pointer to a map so that we can distinguish between an undefined, nil, value and an empty map (clearing any labels defined in the spec).",
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "name": {
                    "description": "Name is the name of the secret when deployed to the target. This overrides the name from the secret spec.",
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "status": {
      "description": "RemoteSecretStatus defines the observed state of RemoteSecret",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Conditions is the list of conditions describing the state of the deployment to the targets.",
          "type": "array",
          "items": {
            "description": "Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, \n type FooStatus struct{ // Represents the observations of a foo's current state. // Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\" // +patchMergeKey=type // +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"` \n // other fields }",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "message",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
                "type": "string",
                "maxLength": 32768
              },
              "observedGeneration": {
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
                "type": "integer",
                "format": "int64",
                "minimum": 0
              },
              "reason": {
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
                "type": "string",
                "maxLength": 1024,
                "minLength": 1,
                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "type": "string",
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                "type": "string",
                "maxLength": 316,
                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
              }
            }
          }
        },
        "secret": {
          "description": "SecretStatus describes the shape of the secret which is currently stored in SecretStorage.",
          "type": "object",
          "properties": {
            "keys": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "targets": {
          "description": "Targets is the list of the deployment statuses for individual targets in the spec.",
          "type": "array",
          "items": {
            "type": "object",
            "required": [
              "namespace"
            ],
            "properties": {
              "apiUrl": {
                "description": "ApiUrl is the URL of the remote Kubernetes cluster to which the target points to.",
                "type": "string"
              },
              "clusterCredentialsSecret": {
                "description": "ClusterCredentialsSecret is the name of the secret in the same namespace as the RemoteSecret that contains the token to use to authenticate with the remote Kubernetes cluster. This is ignored if `apiUrl` is empty.",
                "type": "string"
              },
              "deployedSecret": {
                "description": "DeployedSecret contains the status information about the linked secret deployed in the target",
                "type": "object",
                "required": [
                  "name"
                ],
                "properties": {
                  "annotations": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "labels": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "name": {
                    "type": "string"
                  }
                }
              },
              "error": {
                "description": "Error the optional error message if the deployment of either the secret or the service accounts failed.",
                "type": "string"
              },
              "expectedSecret": {
                "description": "ExpectedSecret defines how the name of the Secret to be deployed should look like. The value comes either from LinkableSecretSpec definition in RemoteSecret spec, or from SecretOverride in the target. The value as such is not important for users, but it is required for a correct matching of targets from spec to status.",
                "type": "object",
                "properties": {
                  "generateName": {
                    "description": "GenerateName is the name prefix for Secret to be deployed to the target.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name is the exact name of the Secret to be deployed to target.",
                    "type": "string"
                  }
                }
              },
              "namespace": {
                "description": "Namespace is the namespace of the target where the secret and the service accounts have been deployed to.",
                "type": "string"
              },
              "secretName": {
                "description": "SecretName is the name of the secret that is actually deployed to the target namespace \n Deprecated: please use the DeployedSecret.Name field instead",
                "type": "string"
              },
              "serviceAccountNames": {
                "description": "ServiceAccountNames is the names of the service accounts that have been deployed to the target namespace",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "stringData": {
      "description": "Similar to how one can specify the data in an ordinary Kubernetes secret using either the \"data\" or \"stringData\" fields, so one can do that when supplying the data to the remote secret. See the data field for more details about the behavior of these fields in remote secrets. Both in create and update, the contents of the stringData is merged into the data field first. This is the same behavior as with ordinary Kubernetes secret's stringData.",
      "type": "object",
      "maxProperties": 0,
      "additionalProperties": {
        "type": "string"
      }
    }
  },
  "x-kubernetes-group-version-kind": [
    {
      "group": "appstudio.redhat.com",
      "kind": "RemoteSecret",
      "version": "v1beta1"
    }
  ],
  "$schema": "http://json-schema.org/schema#"
}
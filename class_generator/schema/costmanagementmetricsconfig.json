{
  "description": "CostManagementMetricsConfig is the Schema for the costmanagementmetricsconfig API",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
      "$ref": "_definitions.json#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    },
    "spec": {
      "description": "CostManagementMetricsConfigSpec defines the desired state of CostManagementMetricsConfig.",
      "type": "object",
      "required": [
        "authentication",
        "packaging",
        "prometheus_config",
        "source",
        "upload"
      ],
      "properties": {
        "api_url": {
          "description": "FOR DEVELOPMENT ONLY.\nAPIURL is a field of CostManagementMetricsConfig to represent the url of the API endpoint for service interaction.\nThe default is `https://console.redhat.com`.",
          "type": "string"
        },
        "authentication": {
          "description": "Authentication is a field of CostManagementMetricsConfig to represent the authentication object.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "secret_name": {
              "description": "AuthenticationSecretName is a field of CostManagementMetricsConfig to represent the secret with the user and password used for uploads.",
              "type": "string"
            },
            "token_url": {
              "description": "FOR DEVELOPMENT ONLY.\nTokenURL is a field of CostManagementMetricsConfig to represent the endpoint used to obtain the service account token.\nThe default is `https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token`.",
              "type": "string"
            },
            "type": {
              "description": "AuthType is a field of CostManagementMetricsConfig to represent the authentication type to be used basic, service-account or token.\nValid values are:\n- \"basic\" (deprecated) : Enables authentication using user and password from authentication secret.\n- \"service-account\" : Enables authentication using client_id and client_secret from the secret containing service account information.\n- \"token\" (default): Uses cluster token for authentication.",
              "type": "string",
              "enum": [
                "token",
                "basic",
                "service-account"
              ]
            }
          }
        },
        "clusterID": {
          "description": "ClusterID is a field of CostManagementMetricsConfig to represent the cluster UUID. Normally this value should not be\nspecified. Only set this value if the clusterID cannot be obtained from the ClusterVersion.",
          "type": "string"
        },
        "clusterVersion": {
          "description": "ClusterVersion is a field of CostManagementMetricsConfig to represent the cluster version. Normally this value should not be\nspecified. Only set this value if the clusterVersion cannot be obtained from the ClusterVersion.",
          "type": "string"
        },
        "packaging": {
          "description": "Packaging is a field of CostManagementMetricsConfig to represent the packaging object.",
          "type": "object",
          "required": [
            "max_reports_to_store",
            "max_size_MB"
          ],
          "properties": {
            "max_reports_to_store": {
              "description": "MaxReports is a field of CostManagementMetricsConfig to represent the maximum number of reports to store.\nThe default is 30 reports which corresponds to approximately 7 days worth of data given the other default values.",
              "type": "integer",
              "format": "int64",
              "minimum": 1
            },
            "max_size_MB": {
              "description": "MaxSize is a field of CostManagementMetricsConfig to represent the max file size in megabytes that will be compressed for upload to Ingress.\nThe default is 100.",
              "type": "integer",
              "format": "int64",
              "maximum": 100,
              "minimum": 1
            }
          }
        },
        "prometheus_config": {
          "description": "PrometheusConfig is a field of CostManagementMetricsConfig to represent the configuration of Prometheus connection.",
          "type": "object",
          "required": [
            "service_address",
            "skip_tls_verification"
          ],
          "properties": {
            "collect_previous_data": {
              "description": "CollectPreviousData is a field of CostManagementMetricsConfig to represent whether or not the operator will gather previous data upon CostManagementMetricsConfig\ncreation. This toggle only changes operator behavior when a new CostManagementMetricsConfig is created. When `true`, the operator will gather all\nexisting Prometheus data for the current month. The default is true.",
              "type": "boolean"
            },
            "context_timeout": {
              "description": "ContextTimeout is a field of CostManagementMetricsConfig to represent how long a query to prometheus should run in seconds before timing out.\nThe default is 120 seconds.",
              "type": "integer",
              "format": "int64",
              "maximum": 180,
              "minimum": 10
            },
            "disable_metrics_collection_cost_management": {
              "description": "DisableMetricsCollectionCostManagement is a field of CostManagementMetricsConfig to represent whether or not the operator will generate\nreports for cost-management metrics. The default is false.",
              "type": "boolean"
            },
            "disable_metrics_collection_resource_optimization": {
              "description": "DisableMetricsCollectionResourceOptimization is a field of CostManagementMetricsConfig to represent whether or not the operator will generate\nreports for resource-optimization metrics. The default is false.",
              "type": "boolean"
            },
            "service_address": {
              "description": "FOR DEVELOPMENT ONLY.\nSvcAddress is a field of CostManagementMetricsConfig to represent the thanos-querier address.\nThe default is `https://thanos-querier.openshift-monitoring.svc:9091`.",
              "type": "string"
            },
            "skip_tls_verification": {
              "description": "FOR DEVELOPMENT ONLY.\nSkipTLSVerification is a field of CostManagementMetricsConfig to represent if the thanos-querier endpoint must be certificate validated.\nThe default is false.",
              "type": "boolean"
            }
          }
        },
        "source": {
          "description": "source represents the desired integration on console.redhat.com.",
          "type": "object",
          "required": [
            "check_cycle",
            "create_source",
            "sources_path"
          ],
          "properties": {
            "check_cycle": {
              "description": "check_cycle is the number of minutes between each integration status check on console.redhat.com.\nThe default is 1440 min (24 hours).",
              "type": "integer",
              "format": "int64",
              "minimum": 0
            },
            "create_source": {
              "description": "create_source toggles the creation of the integration on console.redhat.com.",
              "type": "boolean"
            },
            "name": {
              "description": "name is the desired name of the integration to create on console.redhat.com.",
              "type": "string"
            },
            "sources_path": {
              "description": "FOR DEVELOPMENT ONLY.\nsources_path is the prefix of the Sources API on console.redhat.com.\nThe default is `/api/sources/v1.0/`.",
              "type": "string"
            }
          }
        },
        "upload": {
          "description": "Upload is a field of CostManagementMetricsConfig to represent the upload object.",
          "type": "object",
          "required": [
            "ingress_path",
            "upload_cycle",
            "upload_toggle",
            "validate_cert"
          ],
          "properties": {
            "ingress_path": {
              "description": "FOR DEVELOPMENT ONLY.\nIngressAPIPath is a field of CostManagementMetricsConfig to represent the path of the Ingress API service.\nThe default is `/api/ingress/v1/upload`.",
              "type": "string"
            },
            "upload_cycle": {
              "description": "UploadCycle is a field of CostManagementMetricsConfig to represent the number of minutes between each upload schedule.\nThe default is 360 min (6 hours).",
              "type": "integer",
              "format": "int64",
              "minimum": 0
            },
            "upload_toggle": {
              "description": "UploadToggle is a field of CostManagementMetricsConfig to represent if the operator is installed in a restricted-network.\nIf `false`, the operator will not upload to console.redhat.com or check/create sources.\nThe default is true.",
              "type": "boolean"
            },
            "upload_wait": {
              "description": "UploadWait is a field of CostManagementMetricsConfig to represent the time to wait before sending an upload.",
              "type": "integer",
              "format": "int64",
              "minimum": 0
            },
            "validate_cert": {
              "description": "ValidateCert is a field of CostManagementMetricsConfig to represent if the Ingress endpoint must be certificate validated.",
              "type": "boolean"
            }
          }
        },
        "volume_claim_template": {
          "description": "VolumeClaimTemplate is a field of CostManagementMetricsConfig to represent a PVC template.",
          "type": "object",
          "properties": {
            "apiVersion": {
              "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
              "type": "string"
            },
            "kind": {
              "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
              "type": "string"
            },
            "metadata": {
              "description": "EmbeddedMetadata contains metadata relevant to an EmbeddedResource.",
              "type": "object",
              "properties": {
                "annotations": {
                  "description": "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: http://kubernetes.io/docs/user-guide/annotations",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "description": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: http://kubernetes.io/docs/user-guide/labels",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "name": {
                  "description": "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#names",
                  "type": "string"
                }
              }
            },
            "spec": {
              "description": "Spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
              "type": "object",
              "properties": {
                "accessModes": {
                  "description": "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "dataSource": {
                  "description": "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.",
                  "type": "object",
                  "required": [
                    "kind",
                    "name"
                  ],
                  "properties": {
                    "apiGroup": {
                      "description": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is the type of resource being referenced",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name is the name of resource being referenced",
                      "type": "string"
                    }
                  },
                  "x-kubernetes-map-type": "atomic"
                },
                "dataSourceRef": {
                  "description": "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.",
                  "type": "object",
                  "required": [
                    "kind",
                    "name"
                  ],
                  "properties": {
                    "apiGroup": {
                      "description": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is the type of resource being referenced",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name is the name of resource being referenced",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.",
                      "type": "string"
                    }
                  }
                },
                "resources": {
                  "description": "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources",
                  "type": "object",
                  "properties": {
                    "limits": {
                      "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                      "type": "object",
                      "additionalProperties": {
                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                        "x-kubernetes-int-or-string": true
                      }
                    },
                    "requests": {
                      "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                      "type": "object",
                      "additionalProperties": {
                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                        "x-kubernetes-int-or-string": true
                      }
                    }
                  }
                },
                "selector": {
                  "description": "selector is a label query over volumes to consider for binding.",
                  "type": "object",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "type": "array",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                        "type": "object",
                        "required": [
                          "key",
                          "operator"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string"
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "matchLabels": {
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  },
                  "x-kubernetes-map-type": "atomic"
                },
                "storageClassName": {
                  "description": "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
                  "type": "string"
                },
                "volumeAttributesClassName": {
                  "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string value means that no VolumeAttributesClass\nwill be applied to the claim but it's not allowed to reset this field to empty string once it is set.\nIf unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass\nwill be set by the persistentvolume controller if it exists.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass\n(Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.",
                  "type": "string"
                },
                "volumeMode": {
                  "description": "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.",
                  "type": "string"
                },
                "volumeName": {
                  "description": "volumeName is the binding reference to the PersistentVolume backing this claim.",
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "status": {
      "description": "CostManagementMetricsConfigStatus defines the observed state of CostManagementMetricsConfig.",
      "type": "object",
      "properties": {
        "api_url": {
          "description": "APIURL is a field of CostManagementMetricsConfig to represent the url of the API endpoint for service interaction.",
          "type": "string"
        },
        "authentication": {
          "description": "Authentication is a field of CostManagementMetricsConfig to represent the authentication status.",
          "type": "object",
          "properties": {
            "credentials_found": {
              "description": "AuthenticationCredentialsFound is a field of CostManagementMetricsConfig to represent if used for uploads were found.",
              "type": "boolean"
            },
            "deprecation_notice": {
              "description": "DeprecationNotice is a field of CostManagementMetricsConfig to represent a deprecation notice.",
              "type": "string"
            },
            "error": {
              "description": "AuthErrorMessage is a field of CostManagementMetricsConfig to represent an `invalid credentials` error message.",
              "type": "string"
            },
            "last_credential_verification_time": {
              "description": "LastVerificationTime is a field of CostManagementMetricsConfig to represent the last time credentials were verified.",
              "format": "date-time"
            },
            "secret_name": {
              "description": "AuthenticationSecretName is a field of CostManagementMetricsConfig to represent the secret with the user and password used for uploads.",
              "type": "string"
            },
            "token_url": {
              "description": "TokenURL is a field of CostManagementMetricsConfig to represent the url used to generate a service account token.",
              "type": "string"
            },
            "type": {
              "description": "AuthType is a field of CostManagementMetricsConfig to represent the authentication type to be used basic, service-account or token.",
              "type": "string",
              "enum": [
                "token",
                "basic",
                "service-account"
              ]
            },
            "valid_basic_auth": {
              "description": "ValidBasicAuth is a field of CostManagementMetricsConfig to represent if the given basic auth credentials are valid.",
              "type": "boolean"
            }
          }
        },
        "clusterID": {
          "description": "ClusterID is a field of CostManagementMetricsConfig to represent the cluster UUID.",
          "type": "string"
        },
        "clusterVersion": {
          "description": "ClusterVersion is a field of CostManagementMetricsConfig to represent the cluster version.",
          "type": "string"
        },
        "operator_commit": {
          "description": "OperatorCommit is a field of CostManagementMetricsConfig that shows the commit hash of the operator.",
          "type": "string"
        },
        "packaging": {
          "description": "Packaging is a field of CostManagementMetricsConfig to represent the packaging status",
          "type": "object",
          "properties": {
            "error": {
              "description": "PackagingError is a field of CostManagementMetricsConfig to represent the error encountered packaging the reports.",
              "type": "string"
            },
            "last_successful_packaging_time": {
              "description": "LastSuccessfulPackagingTime is a field of CostManagementMetricsConfig that shows the time of the last successful file packaging.",
              "format": "date-time"
            },
            "max_reports_to_store": {
              "description": "MaxReports is a field of CostManagementMetricsConfig to represent the maximum number of reports to store.",
              "type": "integer",
              "format": "int64"
            },
            "max_size_MB": {
              "description": "MaxSize is a field of CostManagementMetricsConfig to represent the max file size in megabytes that will be compressed for upload to Ingress.",
              "type": "integer",
              "format": "int64"
            },
            "number_reports_stored": {
              "description": "ReportCount is a field of CostManagementMetricsConfig to represent the number of reports in storage.",
              "type": "integer",
              "format": "int64"
            },
            "packaged_files": {
              "description": "PackagedFiles is a field of CostManagementMetricsConfig to represent the list of file packages in storage.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "persistent_volume_claim": {
          "description": "PersistentVolumeClaim is a field of CostManagementMetricsConfig to represent a PVC.",
          "type": "object",
          "properties": {
            "apiVersion": {
              "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
              "type": "string"
            },
            "kind": {
              "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
              "type": "string"
            },
            "metadata": {
              "description": "EmbeddedMetadata contains metadata relevant to an EmbeddedResource.",
              "type": "object",
              "properties": {
                "annotations": {
                  "description": "Annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: http://kubernetes.io/docs/user-guide/annotations",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "description": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: http://kubernetes.io/docs/user-guide/labels",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "name": {
                  "description": "Name must be unique within a namespace. Is required when creating resources, although\nsome resources may allow a client to request the generation of an appropriate name\nautomatically. Name is primarily intended for creation idempotence and configuration\ndefinition.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#names",
                  "type": "string"
                }
              }
            },
            "spec": {
              "description": "Spec defines the desired characteristics of a volume requested by a pod author.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
              "type": "object",
              "properties": {
                "accessModes": {
                  "description": "accessModes contains the desired access modes the volume should have.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "dataSource": {
                  "description": "dataSource field can be used to specify either:\n* An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)\n* An existing PVC (PersistentVolumeClaim)\nIf the provisioner or an external controller can support the specified data source,\nit will create a new volume based on the contents of the specified data source.\nWhen the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,\nand dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.\nIf the namespace is specified, then dataSourceRef will not be copied to dataSource.",
                  "type": "object",
                  "required": [
                    "kind",
                    "name"
                  ],
                  "properties": {
                    "apiGroup": {
                      "description": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is the type of resource being referenced",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name is the name of resource being referenced",
                      "type": "string"
                    }
                  },
                  "x-kubernetes-map-type": "atomic"
                },
                "dataSourceRef": {
                  "description": "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n* While dataSource only allows two specific types of objects, dataSourceRef\n  allows any non-core object, as well as PersistentVolumeClaim objects.\n* While dataSource ignores disallowed values (dropping them), dataSourceRef\n  preserves all values, and generates an error if a disallowed value is\n  specified.\n* While dataSource only allows local objects, dataSourceRef allows objects\n  in any namespaces.\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.",
                  "type": "object",
                  "required": [
                    "kind",
                    "name"
                  ],
                  "properties": {
                    "apiGroup": {
                      "description": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind is the type of resource being referenced",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name is the name of resource being referenced",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.",
                      "type": "string"
                    }
                  }
                },
                "resources": {
                  "description": "resources represents the minimum resources the volume should have.\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources",
                  "type": "object",
                  "properties": {
                    "limits": {
                      "description": "Limits describes the maximum amount of compute resources allowed.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                      "type": "object",
                      "additionalProperties": {
                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                        "x-kubernetes-int-or-string": true
                      }
                    },
                    "requests": {
                      "description": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\notherwise to an implementation-defined value. Requests cannot exceed Limits.\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
                      "type": "object",
                      "additionalProperties": {
                        "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                        "x-kubernetes-int-or-string": true
                      }
                    }
                  }
                },
                "selector": {
                  "description": "selector is a label query over volumes to consider for binding.",
                  "type": "object",
                  "properties": {
                    "matchExpressions": {
                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                      "type": "array",
                      "items": {
                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                        "type": "object",
                        "required": [
                          "key",
                          "operator"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the label key that the selector applies to.",
                            "type": "string"
                          },
                          "operator": {
                            "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                            "type": "string"
                          },
                          "values": {
                            "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "matchLabels": {
                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  },
                  "x-kubernetes-map-type": "atomic"
                },
                "storageClassName": {
                  "description": "storageClassName is the name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
                  "type": "string"
                },
                "volumeAttributesClassName": {
                  "description": "volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.\nIf specified, the CSI driver will create or update the volume with the attributes defined\nin the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,\nit can be changed after the claim is created. An empty string value means that no VolumeAttributesClass\nwill be applied to the claim but it's not allowed to reset this field to empty string once it is set.\nIf unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass\nwill be set by the persistentvolume controller if it exists.\nIf the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be\nset to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource\nexists.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass\n(Alpha) Using this field requires the VolumeAttributesClass feature gate to be enabled.",
                  "type": "string"
                },
                "volumeMode": {
                  "description": "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.",
                  "type": "string"
                },
                "volumeName": {
                  "description": "volumeName is the binding reference to the PersistentVolume backing this claim.",
                  "type": "string"
                }
              }
            }
          }
        },
        "prometheus": {
          "description": "Prometheus represents the status of premetheus queries.",
          "type": "object",
          "required": [
            "prometheus_configured",
            "prometheus_connected"
          ],
          "properties": {
            "configuration_error": {
              "description": "ConfigError is a field of CostManagementMetricsConfigStatus to represent errors during prometheus configuration.",
              "type": "string"
            },
            "context_timeout": {
              "description": "ContextTimeout is a field of CostManagementMetricsConfigState to represent how long a query to prometheus should run in seconds before timing out.",
              "type": "integer",
              "format": "int64"
            },
            "disabled_metrics_collection_cost_management": {
              "description": "DisabledMetricsCollectionCostManagement is a field of CostManagementMetricsConfigStatus to represent whether or not collecting\ncost-management metrics is disabled. The default is false.",
              "type": "boolean"
            },
            "disabled_metrics_collection_resource_optimization": {
              "description": "DisabledMetricsCollectionResourceOptimization is a field of CostManagementMetricsConfigStatus to represent whether or not collecting\nresource-optimization metrics is disabled. The default is true.",
              "type": "boolean"
            },
            "last_query_start_time": {
              "description": "LastQueryStartTime is a field of CostManagementMetricsConfigStatus to represent the last time queries were started.",
              "format": "date-time"
            },
            "last_query_success_time": {
              "description": "LastQuerySuccessTime is a field of CostManagementMetricsConfigStatus to represent the last time queries were successful.",
              "format": "date-time"
            },
            "previous_data_collected": {
              "description": "PreviousDataCollected is a field of CostManagementMetricsConfigStatus to represent whether or not the operator gathered the available Prometheus\ndata upon CostManagementMetricsConfig creation.",
              "type": "boolean"
            },
            "prometheus_configured": {
              "description": "PrometheusConfigured is a field of CostManagementMetricsConfigStatus to represent if the operator is configured to connect to prometheus.",
              "type": "boolean"
            },
            "prometheus_connected": {
              "description": "PrometheusConnected is a field of CostManagementMetricsConfigStatus to represent if prometheus can be queried.",
              "type": "boolean"
            },
            "prometheus_connection_error": {
              "description": "ConnectionError is a field of CostManagementMetricsConfigStatus to represent errors during prometheus test query.",
              "type": "string"
            },
            "service_address": {
              "description": "SvcAddress is the internal thanos-querier address.",
              "type": "string"
            },
            "skip_tls_verification": {
              "description": "SkipTLSVerification is a field of CostManagementMetricsConfigStatus to represent if the thanos-querier endpoint must be certificate validated.",
              "type": "boolean"
            }
          }
        },
        "reports": {
          "description": "Reports represents the status of report generation.",
          "type": "object",
          "properties": {
            "data_collected": {
              "description": "DataCollected is a field of CostManagementMetricsConfigStatus to represent whether or not data was collected for the last query.",
              "type": "boolean"
            },
            "data_collection_message": {
              "description": "DataCollectionMessage is a field of CostManagementMetricsConfigStatus to represent a message associated with the data_collected status.",
              "type": "string"
            },
            "last_hour_queried": {
              "description": "LastHourQueried is a field of CostManagementMetricsConfigStatus to represent the time range for which metrics were last queried.",
              "type": "string"
            },
            "report_month": {
              "description": "ReportMonth is a field of CostManagementMetricsConfigStatus to represent the month for which reports are being generated.",
              "type": "string"
            }
          }
        },
        "source": {
          "description": "source represents the observed state of the integration on console.redhat.com.",
          "type": "object",
          "properties": {
            "check_cycle": {
              "description": "check_cycle is the number of minutes between each integration status check on console.redhat.com.\nThe default is 1440 min (24 hours).",
              "type": "integer",
              "format": "int64"
            },
            "create_source": {
              "description": "create_source represents the toggle used during the creation of the integration on console.redhat.com.\nAn Integration will not be created if upload_toggle is `false`.",
              "type": "boolean"
            },
            "error": {
              "description": "error represents any errors encountered when creating the integration.",
              "type": "string"
            },
            "last_check_time": {
              "description": "last_check_time is the time that the last integration status check was attempted.",
              "format": "date-time"
            },
            "name": {
              "description": "name represents the name of the integration that the operator attempted to create on console.redhat.com.",
              "type": "string"
            },
            "source_defined": {
              "description": "source_defined represents whether the defined integration name exists on console.redhat.com.",
              "type": "boolean"
            },
            "sources_path": {
              "description": "sources_path is the prefix of the Sources API on console.redhat.com.",
              "type": "string"
            }
          }
        },
        "storage": {
          "description": "Storage is a field",
          "type": "object",
          "properties": {
            "volume_mounted": {
              "description": "VolumeMounted is a bool to indicate if storage volume was mounted.",
              "type": "boolean"
            },
            "volume_type": {
              "description": "VolumeType is the string representation of the volume type.",
              "type": "string"
            }
          }
        },
        "upload": {
          "description": "Upload is a field of CostManagementMetricsConfig to represent the upload object.",
          "type": "object",
          "properties": {
            "error": {
              "description": "UploadError is a field of CostManagementMetricsConfigStatus to represent the error encountered uploading reports.",
              "type": "string"
            },
            "ingress_path": {
              "description": "IngressAPIPath is a field of CostManagementMetricsConfig to represent the path of the Ingress API service.",
              "type": "string"
            },
            "last_payload_files": {
              "description": "LastPayloadFiles is a field of CostManagementMetricsConfig to represent the list of files in the last payload that was sent.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "last_payload_manifest_id": {
              "description": "LastPayloadManifest is a field of CostManagementMetricsConfig that shows the manifestID of the last payload.",
              "type": "string"
            },
            "last_payload_name": {
              "description": "LastPayloadName is a field of CostManagementMetricsConfig that shows the name of the last payload file.",
              "type": "string"
            },
            "last_payload_request_id": {
              "description": "LastPayloadRequestID is a field of CostManagementMetricsConfig that shows the insights request id of the last payload.",
              "type": "string"
            },
            "last_successful_upload_time": {
              "description": "LastSuccessfulUploadTime is a field of CostManagementMetricsConfig that shows the time of the last successful upload.",
              "format": "date-time"
            },
            "last_upload_status": {
              "description": "LastUploadStatus is a field of CostManagementMetricsConfig that shows the http status of the last upload.",
              "type": "string"
            },
            "upload": {
              "description": "UploadToggle is a field of CostManagementMetricsConfig to represent if the operator should upload to console.redhat.com.\nThe default is true",
              "type": "boolean"
            },
            "upload_cycle": {
              "description": "UploadCycle is a field of CostManagementMetricsConfig to represent the number of minutes between each upload schedule.\nThe default is 360 min (6 hours).",
              "type": "integer",
              "format": "int64"
            },
            "upload_wait": {
              "description": "UploadWait is a field of CostManagementMetricsConfig to represent the time to wait before sending an upload.",
              "type": "integer",
              "format": "int64"
            },
            "validate_cert": {
              "description": "ValidateCert is a field of CostManagementMetricsConfig to represent if the Ingress endpoint must be certificate validated.",
              "type": "boolean"
            }
          }
        }
      }
    }
  },
  "x-kubernetes-group-version-kind": [
    {
      "group": "costmanagement-metrics-cfg.openshift.io",
      "kind": "CostManagementMetricsConfig",
      "version": "v1beta1"
    }
  ],
  "$schema": "http://json-schema.org/schema#"
}